import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPost } from "../../../../structures/ICommunityPlatformPost";
export * as votes from "./votes/index";
export * as moderationLogs from "./moderationLogs/index";

/**
 * Create a new post in community_platform_posts by providing the post details
 * and community association.
 *
 * POST /posts creates a new post entry in the system by inserting a record into
 * the community_platform_posts table. Required inputs are verified for
 * compliance: a valid, existing communityId must be specified, title and body
 * conform to business length/value rules, and the author must be an
 * authenticated memberUser or adminUser. If a display name is omitted or empty,
 * 'Anonymous' is automatically assigned.
 *
 * Security logic ensures posts can be created only when authenticated;
 * otherwise, the operation is rejected. On successful creation, the post is
 * associated with the authenticated user's id, the specified community, and an
 * appropriate author display name. Immediate error feedback is provided for
 * missing fields, invalid lengths, or community not found. The resulting object
 * includes all post fields for client-side confirmation and feed refresh.
 *
 * @param props.connection
 * @param props.body Data for the new post: communityId, title, body, optional
 *   display name.
 * @path /communityPlatform/adminUser/posts
 * @accessor api.functional.communityPlatform.adminUser.posts.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Data for the new post: communityId, title, body, optional display
     * name.
     */
    body: ICommunityPlatformPost.ICreate;
  };
  export type Body = ICommunityPlatformPost.ICreate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/adminUser/posts",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/adminUser/posts";
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update a post's title, body, or display name in community_platform_posts by
 * postId.
 *
 * PUT /posts/{postId} allows an authenticated user to edit their own post or
 * for adminUser to update any post. The operation locates the target record by
 * postId and ensures the requester is authorized to modify the post according
 * to business ownership and moderation rules. Clients may update the title
 * (5–120 chars), body (10–10,000 chars), and display name (0–32 chars,
 * optional—defaults to 'Anonymous' if empty).
 *
 * Validation constraints are enforced: posts must not be deleted, inputs must
 * match content rules, and community or author associations cannot be changed
 * via this operation. If requested by a non-author (non-admin), the operation
 * returns a permission error. The response contains the updated post details.
 * Error handling covers not found, deleted, or unauthorized modification
 * attempts.
 *
 * @param props.connection
 * @param props.postId The unique identifier (UUID) of the post to update.
 * @param props.body Fields allowed for update: title, body, optional display
 *   name (business rule checks enforced).
 * @path /communityPlatform/adminUser/posts/:postId
 * @accessor api.functional.communityPlatform.adminUser.posts.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The unique identifier (UUID) of the post to update. */
    postId: string & tags.Format<"uuid">;

    /**
     * Fields allowed for update: title, body, optional display name
     * (business rule checks enforced).
     */
    body: ICommunityPlatformPost.IUpdate;
  };
  export type Body = ICommunityPlatformPost.IUpdate;
  export type Response = ICommunityPlatformPost;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/adminUser/posts/:postId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/adminUser/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): ICommunityPlatformPost =>
    typia.random<ICommunityPlatformPost>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft-delete an existing post in community_platform_posts by postId; only
 * allowed by author or adminUser.
 *
 * DELETE /posts/{postId} removes a post from user feeds and search by marking
 * the record as deleted (soft delete—sets deleted_at field) in
 * community_platform_posts. Only the author (memberUser/adminUser) or an
 * adminUser can delete. All underlying business checks for ownership,
 * existence, and non-previously-deleted status are enforced.
 *
 * Cascading application logic removes or marks as deleted dependent entities
 * such as comments or votes as per compliance rules. Attempted deletion of
 * non-owned posts by non-admins returns a permission error. Once deleted, the
 * post becomes inaccessible via normal queries, ensuring user privacy and
 * platform integrity. The operation does not return a body on success.
 *
 * @param props.connection
 * @param props.postId The UUID of the post to be deleted.
 * @path /communityPlatform/adminUser/posts/:postId
 * @accessor api.functional.communityPlatform.adminUser.posts.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The UUID of the post to be deleted. */
    postId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/adminUser/posts/:postId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/adminUser/posts/${encodeURIComponent(props.postId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
