import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformExternalIntegration } from "../../../../structures/ICommunityPlatformExternalIntegration";
import { IPageICommunityPlatformExternalIntegration } from "../../../../structures/IPageICommunityPlatformExternalIntegration";

/**
 * Create a new external integration (community_platform_external_integrations).
 *
 * Allows administrative users to register a new external integration (such as a
 * webhook, OAuth provider, or analytics endpoint) with the platform. The
 * request body must contain an integration name (unique), provider URL,
 * operational status, configuration JSON (such as credentials or required
 * scopes), and initial timestamps. On success, the operation returns the full
 * integration entity for further management or audit.
 *
 * Role restrictions are strictly enforced, limiting access to admin users. Core
 * schema constraints—including integration name uniqueness and format
 * validation for URLs/status fields—are enforced server-side with clear error
 * response patterns. This operation is critical for onboarding new third-party
 * capabilities or managing evolving platform extensibility.
 *
 * If integration name is already in use or required fields are missing/invalid,
 * appropriate error messages are returned per business logic.
 *
 * @param props.connection
 * @param props.body Creation data for the new external integration, including
 *   name, provider, configuration, and status.
 * @path /communityPlatform/adminUser/externalIntegrations
 * @accessor api.functional.communityPlatform.adminUser.externalIntegrations.create
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Creation data for the new external integration, including name,
     * provider, configuration, and status.
     */
    body: ICommunityPlatformExternalIntegration.ICreate;
  };
  export type Body = ICommunityPlatformExternalIntegration.ICreate;
  export type Response = ICommunityPlatformExternalIntegration;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/adminUser/externalIntegrations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/adminUser/externalIntegrations";
  export const random = (): ICommunityPlatformExternalIntegration =>
    typia.random<ICommunityPlatformExternalIntegration>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and paginate external integrations
 * (community_platform_external_integrations).
 *
 * Fetches a paginated, filterable list of all external integrations registered
 * on the platform, including fields for integration name, provider URL, status,
 * and configuration metadata. The operation supports search by integration name
 * and provider fields and allows sorting by creation or update timestamps as
 * well as status. Security: Only admin users may perform this operation due to
 * the sensitive nature of external integration details and potential platform
 * security implications.
 *
 * The result set contains the summary view of integration information, making
 * it suitable for list displays and administrative dashboards. Filtering allows
 * for pinpoint monitoring of integration health (using status and last sync
 * timestamp), while pagination ensures efficient retrieval. Only authenticated
 * admin users have permission, enforced by access control and audit logging.
 * When search terms are under 2 characters, a validation message is returned in
 * accordance with business requirements.
 *
 * Business rules from the schema, especially unique integration names and
 * provider URLs, are enforced internally; erroneous or malicious queries result
 * in clear validation errors. Related operations may include retrieving a
 * single integration by ID, creating new integrations, or editing/deleting as
 * appropriate.
 *
 * @param props.connection
 * @param props.body Search, filter, pagination, and sort criteria for external
 *   integrations.
 * @path /communityPlatform/adminUser/externalIntegrations
 * @accessor api.functional.communityPlatform.adminUser.externalIntegrations.index
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search, filter, pagination, and sort criteria for external
     * integrations.
     */
    body: ICommunityPlatformExternalIntegration.IRequest;
  };
  export type Body = ICommunityPlatformExternalIntegration.IRequest;
  export type Response = IPageICommunityPlatformExternalIntegration.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/adminUser/externalIntegrations",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/adminUser/externalIntegrations";
  export const random =
    (): IPageICommunityPlatformExternalIntegration.ISummary =>
      typia.random<IPageICommunityPlatformExternalIntegration.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve external integration detail by ID
 * (community_platform_external_integrations).
 *
 * Returns detailed information about a specific external integration—identified
 * by externalIntegrationId—including fields such as integration name, provider
 * URL, status, configuration JSON, creation and update timestamps, and last
 * successful synchronization time.
 *
 * This operation is restricted to admin users due to the sensitive operational
 * and credential data for platform integrations. It references the Prisma
 * schema entity community_platform_external_integrations, ensuring all
 * field-level business constraints are observed and that lookups are performed
 * only for existing records. A 404 error is returned if the integration is not
 * found.
 *
 * This may be used in conjunction with update, delete, or configuration viewing
 * flows by admins. Strict role-based access control is enforced as integrations
 * could include credential or provider secrets. Parameters: the path parameter
 * externalIntegrationId is a required UUID uniquely identifying the integration
 * to retrieve.
 *
 * @param props.connection
 * @param props.externalIntegrationId UUID of the target external integration to
 *   retrieve
 * @path /communityPlatform/adminUser/externalIntegrations/:externalIntegrationId
 * @accessor api.functional.communityPlatform.adminUser.externalIntegrations.at
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** UUID of the target external integration to retrieve */
    externalIntegrationId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformExternalIntegration;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/adminUser/externalIntegrations/:externalIntegrationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/adminUser/externalIntegrations/${encodeURIComponent(props.externalIntegrationId ?? "null")}`;
  export const random = (): ICommunityPlatformExternalIntegration =>
    typia.random<ICommunityPlatformExternalIntegration>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("externalIntegrationId")(() =>
        typia.assert(props.externalIntegrationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update existing external integration configuration
 * (community_platform_external_integrations).
 *
 * Allows administrative users to update metadata, provider information, status,
 * or other configuration for a registered external integration. This could
 * include updating the provider URL, status (enabled/disabled), or
 * configuration JSON for an OAuth or webhook endpoint.
 *
 * All business logic for mutable fields is enforced, and attempts to update
 * fields prohibited by schema (such as immutable integration names or IDs)
 * result in a clear error. Role-based access is enforced for admins only. All
 * updated fields are auditable and tracked with precise timestamps in the
 * underlying schema. A 404 is returned if the integration does not exist.
 *
 * Parameter: The path parameter, externalIntegrationId, uniquely identifies the
 * integration to update. Validation ensures that only permissible fields are
 * changed and that changes are compliant with business rules.
 *
 * @param props.connection
 * @param props.externalIntegrationId UUID of the external integration to update
 * @param props.body Data to update for the external integration. Only mutable
 *   fields supported.
 * @path /communityPlatform/adminUser/externalIntegrations/:externalIntegrationId
 * @accessor api.functional.communityPlatform.adminUser.externalIntegrations.update
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** UUID of the external integration to update */
    externalIntegrationId: string & tags.Format<"uuid">;

    /**
     * Data to update for the external integration. Only mutable fields
     * supported.
     */
    body: ICommunityPlatformExternalIntegration.IUpdate;
  };
  export type Body = ICommunityPlatformExternalIntegration.IUpdate;
  export type Response = ICommunityPlatformExternalIntegration;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/adminUser/externalIntegrations/:externalIntegrationId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/adminUser/externalIntegrations/${encodeURIComponent(props.externalIntegrationId ?? "null")}`;
  export const random = (): ICommunityPlatformExternalIntegration =>
    typia.random<ICommunityPlatformExternalIntegration>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("externalIntegrationId")(() =>
        typia.assert(props.externalIntegrationId),
      );
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove (hard delete) an external integration
 * (community_platform_external_integrations).
 *
 * Permanently removes an external integration configuration—including all
 * metadata, provider URL, credentials, and status—from the database. This is a
 * destructive operation with no undo; only users with admin privileges may
 * perform this action.
 *
 * Path parameter externalIntegrationId specifies the unique integration to
 * erase. All business rules, including deletion of sensitive configuration data
 * and unique indexes, are enforced server-side. A success response is returned
 * if the resource is deleted; if the integration does not exist, a 404 error is
 * thrown. Audit logging is triggered for compliance tracking.
 *
 * No response body is returned for successful deletions. Related operations
 * include list, get, create, and update for integrations. Administrators should
 * exercise caution as deleted integrations cannot be restored.
 *
 * @param props.connection
 * @param props.externalIntegrationId UUID of the external integration to delete
 * @path /communityPlatform/adminUser/externalIntegrations/:externalIntegrationId
 * @accessor api.functional.communityPlatform.adminUser.externalIntegrations.erase
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** UUID of the external integration to delete */
    externalIntegrationId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/adminUser/externalIntegrations/:externalIntegrationId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/adminUser/externalIntegrations/${encodeURIComponent(props.externalIntegrationId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("externalIntegrationId")(() =>
        typia.assert(props.externalIntegrationId),
      );
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
