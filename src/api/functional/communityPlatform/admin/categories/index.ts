import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCategory } from "../../../../structures/ICommunityPlatformCategory";
import { IPageICommunityPlatformCategory } from "../../../../structures/IPageICommunityPlatformCategory";

/**
 * Create a new community category for sub-community classification.
 *
 * Allows admin users to create a new category for classifying sub-communities
 * on the platform. Requires a unique code and name, a human-friendly display
 * name, and optionally a longer description. If a provided code or name is
 * already in use, the system rejects the request and returns a conflict error.
 * All categories are tracked for audits by creation and update timestamps.
 *
 * Admin privilege is required, as category creation shapes the system taxonomy.
 * All required inputs must pass validation for length, uniqueness, and allowed
 * characters. Related APIs include listing, detail, update, and deletion
 * endpoints for category management.
 *
 * @param props.connection
 * @param props.body Information required to create a new category (code, name,
 *   description)
 * @path /communityPlatform/admin/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /**
     * Information required to create a new category (code, name,
     * description)
     */
    body: ICommunityPlatformCategory.ICreate;
  };
  export type Body = ICommunityPlatformCategory.ICreate;
  export type Response = ICommunityPlatformCategory;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/categories";
  export const random = (): ICommunityPlatformCategory =>
    typia.random<ICommunityPlatformCategory>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Search and retrieve a paginated, filterable list of all community categories.
 *
 * This API operation fetches a filtered and paginated list of all defined
 * community categories. It allows admin users to perform comprehensive search
 * and management tasks on existing categories, which are used to organize
 * sub-communities. The response includes details such as category code, display
 * name, description, status (active/soft-deleted), and timestamps.
 *
 * Access to this operation is available to admin users only, as category
 * management directly impacts platform taxonomy and business reporting. The
 * endpoint is expected to exclude categories marked as soft-deleted unless
 * included by request.
 *
 * Advanced search parameters such as partial name/code matching and order-by
 * fields are available for rich UI experiences and reporting. Related API
 * operations include category creation, update, retrieval, and deletion
 * endpoints, which together make up the category lifecycle management suite.
 * Category records connect with the sub-community model for entity enforcement
 * and consistency.
 *
 * @param props.connection
 * @param props.body Filter/search, pagination, and sort options for category
 *   retrieval
 * @path /communityPlatform/admin/categories
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** Filter/search, pagination, and sort options for category retrieval */
    body: ICommunityPlatformCategory.IRequest;
  };
  export type Body = ICommunityPlatformCategory.IRequest;
  export type Response = IPageICommunityPlatformCategory.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/categories",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/admin/categories";
  export const random = (): IPageICommunityPlatformCategory.ISummary =>
    typia.random<IPageICommunityPlatformCategory.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get details for a specific community category by its UUID identifier.
 *
 * Fetches the details of a single community platform category specified by
 * categoryId. Returns all available information (id, code, name, description,
 * timestamps) for use in edit or display screens. Soft-deleted categories are
 * not returned unless requested by super-admins or recovery workflows.
 *
 * Admin users only may call this endpoint due to taxonomy system impact. Not
 * found is reported when a non-existent or deleted category is requested.
 * Related operations include updating or deleting categories, as well as
 * listing all categories for management views.
 *
 * @param props.connection
 * @param props.categoryId The UUID of the target category to retrieve
 * @path /communityPlatform/admin/categories/:categoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the target category to retrieve */
    categoryId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCategory;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/categories/:categoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): ICommunityPlatformCategory =>
    typia.random<ICommunityPlatformCategory>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update an existing community category's display fields by UUID identifier.
 *
 * Allows updating of an existing category's display name, description, and
 * other mutable fields. The operation enforces that code and name remain unique
 * across the system. Administration rights are required for this change.
 *
 * If attempting to modify an immutable field (such as code), the system rejects
 * the request. All successful updates refresh the updated_at timestamp for
 * audit and tracking. Errors are returned for not-found, duplicate, or
 * forbidden changes. Only used in privileged category management UIs and flows.
 * Related endpoints are get, list, and delete operations for categories.
 *
 * @param props.connection
 * @param props.categoryId The UUID of the category to update
 * @param props.body Updated display name, description, and edit fields for the
 *   category
 * @path /communityPlatform/admin/categories/:categoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** The UUID of the category to update */
    categoryId: string & tags.Format<"uuid">;

    /** Updated display name, description, and edit fields for the category */
    body: ICommunityPlatformCategory.IUpdate;
  };
  export type Body = ICommunityPlatformCategory.IUpdate;
  export type Response = ICommunityPlatformCategory;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/categories/:categoryId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): ICommunityPlatformCategory =>
    typia.random<ICommunityPlatformCategory>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a community category by setting deleted_at; removes from
 * functional lists.
 *
 * Performs a soft delete of the specified community category by marking its
 * deleted_at timestamp in the database. The category will be omitted from
 * normal functional queries, creation flows, or display UIs.
 *
 * Only administrators have the authority to retire categories, and all delete
 * events are logged for audits. This API does not fully erase records but
 * supports future recovery by privileged system operators if necessary. Related
 * endpoints include the category listing, retrieval, creation, and update
 * APIs.
 *
 * @param props.connection
 * @param props.categoryId The UUID of the category to soft-delete
 * @path /communityPlatform/admin/categories/:categoryId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** The UUID of the category to soft-delete */
    categoryId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/categories/:categoryId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/categories/${encodeURIComponent(props.categoryId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("categoryId")(() => typia.assert(props.categoryId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
