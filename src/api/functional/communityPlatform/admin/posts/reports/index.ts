import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformPostReport } from "../../../../../structures/ICommunityPlatformPostReport";
import { IPageICommunityPlatformPostReport } from "../../../../../structures/IPageICommunityPlatformPostReport";

/**
 * Create a new report about a post for moderation review
 * (community_platform_post_reports table).
 *
 * Create a new report regarding a given post, allowing members or admins to
 * flag inappropriate content, spam, abuse, or rule violations for moderation
 * review. The reporting user must be authenticated, and the target post
 * specified by postId. Request details must include a report_type for category
 * (such as spam, abuse, etc), a descriptive reason, and will be tracked under
 * 'open' status until reviewed. The operation enforces strict input validation:
 * report_type must match platform-allowed values, and reason must be non-empty,
 * up to 1000 chars (plain text). Only one report per post per member is
 * allowed; duplicate reports by the same member are rejected. Admins can also
 * create reports for escalated cases. Each report is associated with the
 * referenced post and the authenticated reporting user, allowing follow-up
 * workflow by moderators. Related APIs: PUT and DELETE operations for managing
 * reports, and admin moderation endpoints for escalations and resolution
 * management. Error handling covers permission issues (non-members/guests can't
 * report), invalid input, and business rule failures.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the target post being reported.
 * @param props.body Information for creating a report on a specific post,
 *   including report_type, reason, and status.
 * @path /communityPlatform/admin/posts/:postId/reports
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** Unique identifier of the target post being reported. */
    postId: string & tags.Format<"uuid">;

    /**
     * Information for creating a report on a specific post, including
     * report_type, reason, and status.
     */
    body: ICommunityPlatformPostReport.ICreate;
  };
  export type Body = ICommunityPlatformPostReport.ICreate;
  export type Response = ICommunityPlatformPostReport;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/admin/posts/:postId/reports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/reports`;
  export const random = (): ICommunityPlatformPostReport =>
    typia.random<ICommunityPlatformPostReport>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Paginated, filtered search for reports/flags on a given post.
 *
 * This operation returns a paginated list of post report entities associated
 * with a specific post (by postId). The operation fetches from the
 * community_platform_post_reports table, using advanced filtering, sorting, and
 * pagination as set by the request DTO. Each report includes details such as
 * reported_by_member_id, admin_id, report_type, reason, status, resolution
 * notes, and creation/updated/resolved timestamps. Authorization is enforced:
 * admins may view all reports; members may view their own filed reports; guests
 * are denied. Use cases include moderation panels, abuse workflows, and user
 * transparency features. Error scenarios arise when accessing reports for
 * deleted/non-existent posts or without appropriate role. This endpoint does
 * not allow creation or modification of reportsâ€”only search/list. Use the
 * related endpoints to fetch report detail or to file a new report.
 *
 * @param props.connection
 * @param props.postId The UUID of the post for which reports are queried.
 * @param props.body Query/filter parameters for paginated searching of post
 *   reports.
 * @path /communityPlatform/admin/posts/:postId/reports
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** The UUID of the post for which reports are queried. */
    postId: string & tags.Format<"uuid">;

    /** Query/filter parameters for paginated searching of post reports. */
    body: ICommunityPlatformPostReport.IRequest;
  };
  export type Body = ICommunityPlatformPostReport.IRequest;
  export type Response = IPageICommunityPlatformPostReport;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/admin/posts/:postId/reports",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/reports`;
  export const random = (): IPageICommunityPlatformPostReport =>
    typia.random<IPageICommunityPlatformPostReport>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve detail for a specific report on a post by reportId.
 *
 * This operation retrieves details of an individual report concerning a
 * particular post, as identified by postId and reportId. It reads a full record
 * from community_platform_post_reports, returning reference IDs for reporter
 * and admin, the report type and reason, statuses and resolution context, and
 * all matching timestamps. Security guarantees that only the reporter for the
 * report or an admin can view the content. The endpoint is used for moderation,
 * review, transparency, and dispute workflows, and is strictly read-only.
 * Accessing a non-existent or unauthorized report results in an error. Other
 * API endpoints exist for creating, updating, or resolving reports through
 * administrative actions. Access is denied to guests.
 *
 * @param props.connection
 * @param props.postId The UUID of the post to which the report belongs.
 * @param props.reportId The unique identifier (UUID) of the specific report
 *   entity.
 * @path /communityPlatform/admin/posts/:postId/reports/:reportId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The UUID of the post to which the report belongs. */
    postId: string & tags.Format<"uuid">;

    /** The unique identifier (UUID) of the specific report entity. */
    reportId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformPostReport;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/admin/posts/:postId/reports/:reportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/reports/${encodeURIComponent(props.reportId ?? "null")}`;
  export const random = (): ICommunityPlatformPostReport =>
    typia.random<ICommunityPlatformPostReport>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("reportId")(() => typia.assert(props.reportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Update or resolve a post report as an admin (community_platform_post_reports
 * table).
 *
 * Update or resolve a specific post report, enabling an admin to change status,
 * add resolution notes, or adjust report metadata. Only users with admin
 * privileges can perform update actions on post reports. Status transitions are
 * strictly controlled: reports may move from open to resolved, pending to
 * dismissed, and admins may provide rationale in resolution_notes. All updates
 * are fully audited for moderation transparency and accountability, with member
 * visibility as required (e.g., to track report progress). Related endpoints:
 * report creation (POST), deletion (DELETE), and detailed report history/audit
 * logs. Validation covers existence of the report (404 on missing/deleted),
 * permissible status values, and proper text fields. Edge cases include
 * handling already resolved or deleted reports.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post containing the report.
 * @param props.reportId Unique identifier of the report to update.
 * @param props.body Fields to modify for the post report, such as status or
 *   resolution_notes.
 * @path /communityPlatform/admin/posts/:postId/reports/:reportId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function update(
  connection: IConnection,
  props: update.Props,
): Promise<update.Response> {
  return true === connection.simulate
    ? update.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...update.METADATA,
          path: update.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace update {
  export type Props = {
    /** Unique identifier of the post containing the report. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the report to update. */
    reportId: string & tags.Format<"uuid">;

    /**
     * Fields to modify for the post report, such as status or
     * resolution_notes.
     */
    body: ICommunityPlatformPostReport.IUpdate;
  };
  export type Body = ICommunityPlatformPostReport.IUpdate;
  export type Response = ICommunityPlatformPostReport;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/admin/posts/:postId/reports/:reportId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/reports/${encodeURIComponent(props.reportId ?? "null")}`;
  export const random = (): ICommunityPlatformPostReport =>
    typia.random<ICommunityPlatformPostReport>();
  export const simulate = (
    connection: IConnection,
    props: update.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: update.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("reportId")(() => typia.assert(props.reportId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Soft delete a report for a post as an admin (community_platform_post_reports
 * table).
 *
 * Delete a specific report for a post, removing it from the moderation system.
 * Only admins may perform this action. The deletion is implemented as a soft
 * delete by setting the deleted_at field on the report, which ensures the
 * record is not physically removed but becomes invisible to active workflows
 * and reporting interfaces. Deletion requests for already-deleted or
 * non-existent reports return a not found error. All deletion actions are
 * thoroughly audited for compliance and traceability. Related endpoints: report
 * creation (POST), update (PUT), and audit log retrieval.
 *
 * @param props.connection
 * @param props.postId Unique identifier of the post containing the report.
 * @param props.reportId Unique identifier of the report to delete.
 * @path /communityPlatform/admin/posts/:postId/reports/:reportId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** Unique identifier of the post containing the report. */
    postId: string & tags.Format<"uuid">;

    /** Unique identifier of the report to delete. */
    reportId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/admin/posts/:postId/reports/:reportId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/admin/posts/${encodeURIComponent(props.postId ?? "null")}/reports/${encodeURIComponent(props.reportId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("postId")(() => typia.assert(props.postId));
      assert.param("reportId")(() => typia.assert(props.reportId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
