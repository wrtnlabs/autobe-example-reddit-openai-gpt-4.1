import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformComment } from "../../../structures/ICommunityPlatformComment";
import { IPageICommunityPlatformComment } from "../../../structures/IPageICommunityPlatformComment";

/**
 * List/filter/search public comments with pagination
 * (community_platform_comments).
 *
 * Search and retrieve a list of comments matching specified filters and
 * criteria, supporting advanced text query, author and post lookup, and
 * flexible sort and pagination controls. All fields must match actual
 * properties from the schema. Only non-deleted comments are included unless
 * requested by an admin. Public access: guests, members, and admins all can
 * search comments. The operation supports searching by a substring of content,
 * filtering to a particular post or author, and sorting by newest or score.
 * Pagination is managed via request body parameters (e.g., page, pageSize).
 * Related endpoints: comment detail (GET), creation (POST), modification (PUT),
 * and deletion (DELETE).
 *
 * @param props.connection
 * @param props.body Search and filter request parameters for comment listing.
 *   Supports query by content/post/author and page/sort controls.
 * @path /communityPlatform/comments
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /**
     * Search and filter request parameters for comment listing. Supports
     * query by content/post/author and page/sort controls.
     */
    body: ICommunityPlatformComment.IRequest;
  };
  export type Body = ICommunityPlatformComment.IRequest;
  export type Response = IPageICommunityPlatformComment.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/comments",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/communityPlatform/comments";
  export const random = (): IPageICommunityPlatformComment.ISummary =>
    typia.random<IPageICommunityPlatformComment.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Fetch detailed information for a comment by ID (community_platform_comments).
 *
 * Retrieve all details for a specific comment, as identified by its commentId.
 * Any user can fetch public comments, with admins able to access deleted ones
 * if authorized. Returns null if the comment does not exist or has been
 * permanently deleted (hard delete is not used; deleted_at indicates logical
 * deletion). Related endpoints: PATCH for search/results, POST for creation,
 * PUT for modification, DELETE for removal.
 *
 * @param props.connection
 * @param props.commentId Unique identifier of the comment to retrieve.
 * @path /communityPlatform/comments/:commentId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** Unique identifier of the comment to retrieve. */
    commentId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformComment;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/comments/:commentId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/comments/${encodeURIComponent(props.commentId ?? "null")}`;
  export const random = (): ICommunityPlatformComment =>
    typia.random<ICommunityPlatformComment>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("commentId")(() => typia.assert(props.commentId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
