import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityMembership } from "../../../../../structures/ICommunityPlatformCommunityMembership";
import { IPageICommunityPlatformCommunityMembership } from "../../../../../structures/IPageICommunityPlatformCommunityMembership";

/**
 * Join a sub-community (create new membership) as an authenticated user.
 *
 * Join a specific sub-community by creating a new membership record for the
 * authenticated user. This action updates the user's community list and feed
 * preferences. The system enforces business rules that a member may only have
 * one membership per community. Attempts to join the same community again will
 * result in a duplicate error. The operation notifies UI feeds and recent
 * community lists of successful membership. Requires correct communityId as
 * path, and the relevant membership creation parameters in the body DTO.
 *
 * @param props.connection
 * @param props.communityId ID of the community to join.
 * @param props.body Membership creation details for joining a community.
 * @path /communityPlatform/member/communities/:communityId/memberships
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function create(
  connection: IConnection,
  props: create.Props,
): Promise<create.Response> {
  return true === connection.simulate
    ? create.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...create.METADATA,
          path: create.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace create {
  export type Props = {
    /** ID of the community to join. */
    communityId: string & tags.Format<"uuid">;

    /** Membership creation details for joining a community. */
    body: ICommunityPlatformCommunityMembership.ICreate;
  };
  export type Body = ICommunityPlatformCommunityMembership.ICreate;
  export type Response = ICommunityPlatformCommunityMembership;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/communities/:communityId/memberships",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/memberships`;
  export const random = (): ICommunityPlatformCommunityMembership =>
    typia.random<ICommunityPlatformCommunityMembership>();
  export const simulate = (
    connection: IConnection,
    props: create.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: create.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List and search current members of a specific community, with pagination and
 * filtering support.
 *
 * Retrieve a paginated list of all current members belonging to a specified
 * sub-community. Supports advanced filtering (such as join date range) and
 * searching by member display name. This endpoint is used for both community
 * owner/admin moderation views and ordinary participants viewing a roster or
 * member card list. Returned information typically includes joined date, member
 * basic info, and other summary details as defined in the membership DTO.
 * Requires appropriate authentication, and the results may be
 * permission-filtered for sensitive data fields. The endpoint enables both
 * roster UIs and member management use-cases for large communities.
 *
 * @param props.connection
 * @param props.communityId The community for which to list current members.
 * @param props.body Advanced filter/search/sort and pagination options for
 *   membership listing.
 * @path /communityPlatform/member/communities/:communityId/memberships
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function index(
  connection: IConnection,
  props: index.Props,
): Promise<index.Response> {
  return true === connection.simulate
    ? index.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...index.METADATA,
          path: index.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace index {
  export type Props = {
    /** The community for which to list current members. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Advanced filter/search/sort and pagination options for membership
     * listing.
     */
    body: ICommunityPlatformCommunityMembership.IRequest;
  };
  export type Body = ICommunityPlatformCommunityMembership.IRequest;
  export type Response = IPageICommunityPlatformCommunityMembership.ISummary;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/member/communities/:communityId/memberships",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/memberships`;
  export const random =
    (): IPageICommunityPlatformCommunityMembership.ISummary =>
      typia.random<IPageICommunityPlatformCommunityMembership.ISummary>();
  export const simulate = (
    connection: IConnection,
    props: index.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: index.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Retrieve details on a specific community membership within a given community.
 *
 * Get details about a single community membership for a given member within a
 * specific sub-community. This operation returns join date, member information,
 * and related metadata. Used by moderation tools, admin dashboards, or detail
 * member profile modals in the community context. Access is protected by
 * authentication and may be permission-filtered based on context or member
 * roles. Returns error if the membership does not exist or if unauthorized.
 *
 * @param props.connection
 * @param props.communityId The community containing the membership.
 * @param props.membershipId Unique membership ID to retrieve details for.
 * @path /communityPlatform/member/communities/:communityId/memberships/:membershipId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function at(
  connection: IConnection,
  props: at.Props,
): Promise<at.Response> {
  return true === connection.simulate
    ? at.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...at.METADATA,
          path: at.path(props),
          status: null,
        },
      );
}
export namespace at {
  export type Props = {
    /** The community containing the membership. */
    communityId: string & tags.Format<"uuid">;

    /** Unique membership ID to retrieve details for. */
    membershipId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCommunityMembership;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/member/communities/:communityId/memberships/:membershipId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/memberships/${encodeURIComponent(props.membershipId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityMembership =>
    typia.random<ICommunityPlatformCommunityMembership>();
  export const simulate = (
    connection: IConnection,
    props: at.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: at.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("membershipId")(() => typia.assert(props.membershipId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Remove a single member from a community by deleting the membership record.
 *
 * Remove a member from a specified sub-community by deleting the given
 * membership record. Commonly used when a user chooses to leave a community or
 * when an admin removes a member. Only the member being removed or a community
 * admin/owner may perform this operation. The endpoint guarantees data
 * integrity by ensuring the membership exists and is properly identified. The
 * affected user's memberships and feeds are updated to reflect the removal. All
 * related audit events are logged for compliance and support for community
 * moderation dashboards.
 *
 * @param props.connection
 * @param props.communityId ID of the parent community.
 * @param props.membershipId Unique membership record ID (membership to delete).
 * @path /communityPlatform/member/communities/:communityId/memberships/:membershipId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function erase(
  connection: IConnection,
  props: erase.Props,
): Promise<void> {
  return true === connection.simulate
    ? erase.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...erase.METADATA,
          path: erase.path(props),
          status: null,
        },
      );
}
export namespace erase {
  export type Props = {
    /** ID of the parent community. */
    communityId: string & tags.Format<"uuid">;

    /** Unique membership record ID (membership to delete). */
    membershipId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/communities/:communityId/memberships/:membershipId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/memberships/${encodeURIComponent(props.membershipId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: erase.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: erase.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("membershipId")(() => typia.assert(props.membershipId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
