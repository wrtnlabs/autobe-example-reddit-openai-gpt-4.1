import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia, { tags } from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformCommunityRule } from "../../../../../structures/ICommunityPlatformCommunityRule";
import { IPageICommunityPlatformCommunityRule } from "../../../../../structures/IPageICommunityPlatformCommunityRule";

/**
 * Add a new rule to a specified community.
 *
 * Creates and appends a new rule for the given community. Allows owners/admins
 * to curate their community's behavior policies. The payload must meet length
 * and uniqueness rules (one per index, max 10 rules of up to 50 chars).
 * Ownership/authorization checks are enforced via business logic, and the
 * result includes the new rule's id, index, and text. Soft/hard limits are
 * handled before creation. Only available to authorized actors—ownership or
 * admin status required.
 *
 * @param props.connection
 * @param props.communityId The UUID of the parent community to which the rule
 *   will be added.
 * @param props.body Single rule creation input, including rule index and text
 *   line (max 50 chars).
 * @path /communityPlatform/member/communities/:communityId/rules
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function createCommunityRule(
  connection: IConnection,
  props: createCommunityRule.Props,
): Promise<createCommunityRule.Response> {
  return true === connection.simulate
    ? createCommunityRule.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...createCommunityRule.METADATA,
          path: createCommunityRule.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace createCommunityRule {
  export type Props = {
    /** The UUID of the parent community to which the rule will be added. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Single rule creation input, including rule index and text line (max
     * 50 chars).
     */
    body: ICommunityPlatformCommunityRule.ICreate;
  };
  export type Body = ICommunityPlatformCommunityRule.ICreate;
  export type Response = ICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "POST",
    path: "/communityPlatform/member/communities/:communityId/rules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/rules`;
  export const random = (): ICommunityPlatformCommunityRule =>
    typia.random<ICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: createCommunityRule.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: createCommunityRule.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * List all rules for a given community (paginated, for curation).
 *
 * Retrieves a list of all rules associated with a target community for editing
 * or curation purposes. This read operation enables community owners or
 * privileged users to review, sort, and search rules for their community.
 * Utilizes pagination and filtering payload per the standard request schema,
 * and references the Prisma table for validation. The rules list is capped at
 * 10 entries by business policy.
 *
 * While any user may view public rules, only authenticated members with
 * ownership/admin rights can curate, reorder, or edit them with this endpoint.
 * The operation guarantees that each rule is unique by (community, rule_index),
 * enabling efficient UI updates and owner workflows for rule management.
 * Results include rule index, text, and current ordering. Use for both listing
 * and configuring rules as allowed by policy.
 *
 * @param props.connection
 * @param props.communityId The UUID of the community whose rules are being
 *   listed.
 * @param props.body Filtering and pagination instructions for listing all rules
 *   of the given community.
 * @path /communityPlatform/member/communities/:communityId/rules
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function indexCommunityRules(
  connection: IConnection,
  props: indexCommunityRules.Props,
): Promise<indexCommunityRules.Response> {
  return true === connection.simulate
    ? indexCommunityRules.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...indexCommunityRules.METADATA,
          path: indexCommunityRules.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace indexCommunityRules {
  export type Props = {
    /** The UUID of the community whose rules are being listed. */
    communityId: string & tags.Format<"uuid">;

    /**
     * Filtering and pagination instructions for listing all rules of the
     * given community.
     */
    body: ICommunityPlatformCommunityRule.IRequest;
  };
  export type Body = ICommunityPlatformCommunityRule.IRequest;
  export type Response = IPageICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "PATCH",
    path: "/communityPlatform/member/communities/:communityId/rules",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/rules`;
  export const random = (): IPageICommunityPlatformCommunityRule =>
    typia.random<IPageICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: indexCommunityRules.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: indexCommunityRules.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Get a specific rule from a community.
 *
 * Retrieves a single rule from the specified community for inspection or edit
 * preparation. The rule is identified by ruleId, which is unique per rule row,
 * and is returned with its index and text. This enables direct access for
 * per-rule display, edit UI, and policy review interfaces. Use primarily for
 * rule-editing flows or admin auditing. Any ownership or admin checks are
 * handled at a higher level of business logic as required by the platform.
 *
 * @param props.connection
 * @param props.communityId The UUID of the parent community owning the rule.
 * @param props.ruleId The UUID of the specific rule to retrieve.
 * @path /communityPlatform/member/communities/:communityId/rules/:ruleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function getCommunityRule(
  connection: IConnection,
  props: getCommunityRule.Props,
): Promise<getCommunityRule.Response> {
  return true === connection.simulate
    ? getCommunityRule.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...getCommunityRule.METADATA,
          path: getCommunityRule.path(props),
          status: null,
        },
      );
}
export namespace getCommunityRule {
  export type Props = {
    /** The UUID of the parent community owning the rule. */
    communityId: string & tags.Format<"uuid">;

    /** The UUID of the specific rule to retrieve. */
    ruleId: string & tags.Format<"uuid">;
  };
  export type Response = ICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "GET",
    path: "/communityPlatform/member/communities/:communityId/rules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityRule =>
    typia.random<ICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: getCommunityRule.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: getCommunityRule.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Edit a specific rule for a given community.
 *
 * Updates the content or ordering of a community rule. Requires the rule to be
 * identified by ruleId within communityId, both provided as path parameters.
 * Only community owners and admins can edit or reorder community rules; all
 * changes must comply with maximum length (50 chars) and rule ordering business
 * constraints. This allows owners to maintain, correct, or clarify their rules
 * as community needs change.
 *
 * @param props.connection
 * @param props.communityId UUID of the parent community for which the rule is
 *   being edited.
 * @param props.ruleId UUID of the specific community rule to be updated.
 * @param props.body Input for editing the rule's index or text, respecting
 *   length and uniqueness rules.
 * @path /communityPlatform/member/communities/:communityId/rules/:ruleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function updateCommunityRule(
  connection: IConnection,
  props: updateCommunityRule.Props,
): Promise<updateCommunityRule.Response> {
  return true === connection.simulate
    ? updateCommunityRule.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...updateCommunityRule.METADATA,
          path: updateCommunityRule.path(props),
          status: null,
        },
        props.body,
      );
}
export namespace updateCommunityRule {
  export type Props = {
    /** UUID of the parent community for which the rule is being edited. */
    communityId: string & tags.Format<"uuid">;

    /** UUID of the specific community rule to be updated. */
    ruleId: string & tags.Format<"uuid">;

    /**
     * Input for editing the rule's index or text, respecting length and
     * uniqueness rules.
     */
    body: ICommunityPlatformCommunityRule.IUpdate;
  };
  export type Body = ICommunityPlatformCommunityRule.IUpdate;
  export type Response = ICommunityPlatformCommunityRule;

  export const METADATA = {
    method: "PUT",
    path: "/communityPlatform/member/communities/:communityId/rules/:ruleId",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Omit<Props, "body">) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): ICommunityPlatformCommunityRule =>
    typia.random<ICommunityPlatformCommunityRule>();
  export const simulate = (
    connection: IConnection,
    props: updateCommunityRule.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: updateCommunityRule.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Delete a community rule permanently.
 *
 * Deletes a specific rule from the rule set of a given community. This
 * operation is only available to community owners and admins. The hard delete
 * removes the rule by ruleId from the communityId's rule set—resulting in
 * immediate disappearance from UI and moderation overlays. All business
 * constraints on rule count and ordering are enforced by subsequent operations.
 * No content is recoverable after this action. Application logic must update
 * indexes/order as needed.
 *
 * @param props.connection
 * @param props.communityId UUID of the parent community whose rule will be
 *   deleted.
 * @param props.ruleId UUID of the rule to delete from the community.
 * @path /communityPlatform/member/communities/:communityId/rules/:ruleId
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function eraseCommunityRule(
  connection: IConnection,
  props: eraseCommunityRule.Props,
): Promise<void> {
  return true === connection.simulate
    ? eraseCommunityRule.simulate(connection, props)
    : await PlainFetcher.fetch(
        {
          ...connection,
          headers: {
            ...connection.headers,
            "Content-Type": "application/json",
          },
        },
        {
          ...eraseCommunityRule.METADATA,
          path: eraseCommunityRule.path(props),
          status: null,
        },
      );
}
export namespace eraseCommunityRule {
  export type Props = {
    /** UUID of the parent community whose rule will be deleted. */
    communityId: string & tags.Format<"uuid">;

    /** UUID of the rule to delete from the community. */
    ruleId: string & tags.Format<"uuid">;
  };

  export const METADATA = {
    method: "DELETE",
    path: "/communityPlatform/member/communities/:communityId/rules/:ruleId",
    request: null,
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = (props: Props) =>
    `/communityPlatform/member/communities/${encodeURIComponent(props.communityId ?? "null")}/rules/${encodeURIComponent(props.ruleId ?? "null")}`;
  export const random = (): void => typia.random<void>();
  export const simulate = (
    connection: IConnection,
    props: eraseCommunityRule.Props,
  ): void => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: eraseCommunityRule.path(props),
      contentType: "application/json",
    });
    try {
      assert.param("communityId")(() => typia.assert(props.communityId));
      assert.param("ruleId")(() => typia.assert(props.ruleId));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
