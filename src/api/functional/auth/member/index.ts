import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformMember } from "../../../structures/ICommunityPlatformMember";
export * as password from "./password";

/**
 * Register a new member account (community_platform_members) and issue login
 * tokens.
 *
 * This API operation enables user registration as a 'member' on the community
 * platform, directly writing to the 'community_platform_members' table as per
 * the Prisma schema.
 *
 * Upon successful execution, a new member row is created with 'email' (for
 * authentication and communication), a securely hashed 'password_hash' (never
 * storing plaintext), and an optional 'display_name' alias (defaults to
 * 'Anonymous' if not provided). The 'is_active' flag is set to true for
 * immediate account activation, and timestamps for account creation and update
 * are managed automatically in accordance with the database schema.
 *
 * This operation carefully enforces the unique constraint on 'email', and will
 * reject attempts to register with a duplicate address, returning an
 * appropriate error. The 'password_hash' is generated from a
 * complexity-validated raw password submitted by the client, aligning with
 * business rule requirements for minimum length and content.
 *
 * On successful registration, the endpoint will issue initial JWT tokens
 * (access and refresh) to the newly created account, embedding 'userId',
 * 'role', and relevant permissions into the token payload as described in the
 * requirements. Session creation may be reflected in the
 * 'community_platform_sessions' entity, but is abstracted from this join
 * endpoint.
 *
 * Failures due to duplicate email or insufficient password complexity must
 * provide clear, user-facing error messages. This operation is foundational for
 * member onboarding, preceding all interactive platform actions.
 *
 * This endpoint is often paired with 'login' for future sign-ins, and with
 * 'refresh' for session renewal. It forms the basis for standard authentication
 * flows for registered users of the community platform.
 *
 * @param props.connection
 * @param props.body Information required to create a new member account (email,
 *   password, optional display_name).
 * @setHeader token.access Authorization
 *
 * @path /auth/member/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Information required to create a new member account (email, password,
     * optional display_name).
     */
    body: ICommunityPlatformMember.ICreate;
  };
  export type Body = ICommunityPlatformMember.ICreate;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/join";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate a member and return JWT tokens for the session
 * (community_platform_members).
 *
 * This API operation handles the authentication (login) process for 'member'
 * users of the community platform, and is mapped to the
 * 'community_platform_members' table as defined in the Prisma schema.
 *
 * The operation verifies the provided login 'email' and 'password' against the
 * database, validating the 'password_hash' using a secure, industry-standard
 * hashing algorithm. Only accounts flagged as 'is_active' and not marked
 * 'deleted_at' can successfully authenticate. The API must never reveal whether
 * an email exists for failed login attempts, to prevent account enumeration
 * attacks.
 *
 * Upon successful authentication, the member's 'last_login_at' timestamp is
 * updated to the current time, and JWT access and refresh tokens are issued.
 * The tokens encode the member's identity, assigned role ('member'), and
 * permissions as outlined in the business requirements. Token expiration
 * policies and refresh token issuance must follow platform standards.
 *
 * This operation does not handle registration ('join') or password
 * resetâ€”instead, it is focused solely on login/authentication. Error messages
 * for failed logins must be generic and never expose internal authentication
 * state or existence of specific accounts. Repeated failed attempts may trigger
 * account lockout or rate-limiting (not enforced directly in this endpoint).
 *
 * Commonly used in conjunction with the registration and token refresh
 * endpoints, it is critical for platform session management and user action
 * authorization for members.
 *
 * @param props.connection
 * @param props.body Member login credentials (email, password).
 * @setHeader token.access Authorization
 *
 * @path /auth/member/login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** Member login credentials (email, password). */
    body: ICommunityPlatformMember.ILogin;
  };
  export type Body = ICommunityPlatformMember.ILogin;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/login";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Renew JWT tokens for a member using refresh token
 * (community_platform_sessions, community_platform_members).
 *
 * This API operation provides session renewal for 'member' users through
 * refresh token validation, based on the 'community_platform_sessions' and
 * 'community_platform_members' tables defined in the Prisma schema.
 *
 * On successful verification of the provided refresh token, new JWT tokens
 * (access and refresh) are generated for the member user. This operation
 * maintains the user's active session, enforces expiration policies, and embeds
 * correct identity and permission claims as described in the requirements.
 *
 * The operation checks that the supplied refresh token matches a valid,
 * non-expired, and non-invalidated session for the requesting user. If the
 * token has expired, been invalidated (such as from logout everywhere or
 * password change), or does not exist in the 'community_platform_sessions'
 * table, the request must return an appropriate authentication error.
 *
 * This endpoint is essential for maintaining continuous authentication without
 * repeated username/password entry, and is a core part of the JWT-based
 * authentication flow. The operation is never used for initial login or
 * registration, but as a means to prolong established sessions securely and
 * conveniently. All session updates are reflected in the platform's session
 * management logic for audit and security.
 *
 * @param props.connection
 * @param props.body Refresh token corresponding to an existing, valid session
 *   for the member.
 * @setHeader token.access Authorization
 *
 * @path /auth/member/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token corresponding to an existing, valid session for the
     * member.
     */
    body: ICommunityPlatformMember.IRefreshRequest;
  };
  export type Body = ICommunityPlatformMember.IRefreshRequest;
  export type Response = ICommunityPlatformMember.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/member/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/member/refresh";
  export const random = (): ICommunityPlatformMember.IAuthorized =>
    typia.random<ICommunityPlatformMember.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
