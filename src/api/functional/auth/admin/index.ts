import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAdmin } from "../../../structures/ICommunityPlatformAdmin";

/**
 * Create a new admin account (community_platform_admins) and issue JWT tokens
 * for admin authentication.
 *
 * This operation enables new admin accounts to be registered within the system
 * by providing required fields (email, password, optional display_name), as
 * defined in the community_platform_admins Prisma schema. On submission, the
 * input email is checked against existing entries in community_platform_admins
 * for uniqueness; password is securely hashed per operational security policy.
 *
 * Creation of the admin entity triggers initial is_active status as true and,
 * if specified, is_super_admin can be handled by business logic (but not
 * settable directly at registration). Additional fields (last_login_at,
 * deleted_at) are null on creation, adhering to audit requirements. The admin
 * object persists all identifiers for linkage to session management,
 * moderation, and the audit trail, forming the basis of future administrative
 * access.
 *
 * Upon successful registration, a new admin session JWT is issued with proper
 * privileges, and the response follows ICommunityPlatformAdmin.IAuthorized
 * security conventions as specified in documentation. If registration fails
 * (e.g., duplicate email), the operation returns appropriate authentication
 * failure details.
 *
 * Security-wise, only non-authenticated users should access this operation;
 * subsequent authentication prevents duplicate accounts. Input validation must
 * enforce business rules for admin emails and passwords. This endpoint is
 * essential for bootstrapping initial admin users and is referenced by other
 * admin management APIs (login, refresh, password recovery).
 *
 * Related operations include admin login and refresh endpoints, which use
 * matching tokens issued as a result of this registration flow. For
 * field/content errors, the endpoint always returns detailed validation error
 * information without exposing sensitive admin fields or password hashes.
 *
 * @param props.connection
 * @param props.body Admin registration data: email, password (to be hashed),
 *   and optional display_name.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Admin registration data: email, password (to be hashed), and optional
     * display_name.
     */
    body: ICommunityPlatformAdmin.IJoin;
  };
  export type Body = ICommunityPlatformAdmin.IJoin;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/join";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Authenticate admin (community_platform_admins) and issue JWT tokens for
 * access.
 *
 * This endpoint allows existing admin users to sign in, as defined by the
 * community_platform_admins Prisma schema, via their unique email and password.
 * The password is validated by comparing a securely hashed version against the
 * password_hash field in the database.
 *
 * When credentials are correct and the admin account is active, the system
 * issues JWT tokens containing admin identity, permission claims (including
 * is_super_admin and is_active), and session data. Failed attempts—such as
 * account inactive, incorrect password, or soft-deleted (deleted_at set)—result
 * in appropriate authentication failure error messages.
 *
 * This operation is restricted to emails found in the community_platform_admins
 * table where is_active is true and deleted_at is null. On first successful
 * login, last_login_at is set to now; otherwise it updates accordingly. All
 * login attempts are audit-logged for security, referencing admin_id and
 * result.
 *
 * Login is a prerequisite for other admin functions (refresh, moderation,
 * password reset). Business logic must ensure tokens conform to
 * ICommunityPlatformAdmin.IAuthorized structure and never expose password_hash.
 * All error states should trigger clear, secure error messages, with zero
 * information leakage about admin existence or status beyond what is required.
 *
 * @param props.connection
 * @param props.body Admin credentials (email, raw password) to authenticate
 *   against community_platform_admins.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /**
     * Admin credentials (email, raw password) to authenticate against
     * community_platform_admins.
     */
    body: ICommunityPlatformAdmin.ILogin;
  };
  export type Body = ICommunityPlatformAdmin.ILogin;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/login";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh JWT tokens for admin (community_platform_admins) via active session
 * record (community_platform_sessions).
 *
 * This operation enables admin users to refresh JWT access tokens by providing
 * a valid refresh token, in accordance with the session-management architecture
 * defined on top of community_platform_sessions for admin users. The endpoint
 * cross-verifies the refresh_token in community_platform_sessions, checks
 * expiry and invalidation states, and creates a new access token if the request
 * is valid.
 *
 * Only refresh tokens that have not expired, are not invalidated
 * (invalidated_at is null), and match a living admin account
 * (community_platform_admins, is_active true, deleted_at null) succeed. Audit
 * logging persists every refresh event, tracking the session and admin entity.
 * If the refresh token is invalid, expired, or associated admin is no longer
 * valid, the operation returns an authentication failure with an appropriate
 * error message.
 *
 * On success, the endpoint returns new access/refresh tokens using the
 * ICommunityPlatformAdmin.IAuthorized format, inheriting all admin claims and
 * security state. This operation is referenced by all long-session client flows
 * and acts as the continuity endpoint for admin JWT authentication lifecycle.
 * Input tokens are never persisted in logs, and validation failure details are
 * generic to prevent disclosure of account or session state.
 *
 * @param props.connection
 * @param props.body Refresh token for the admin session associated to
 *   community_platform_admins. May require session/device info.
 * @setHeader token.access Authorization
 *
 * @path /auth/admin/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token for the admin session associated to
     * community_platform_admins. May require session/device info.
     */
    body: ICommunityPlatformAdmin.IRefresh;
  };
  export type Body = ICommunityPlatformAdmin.IRefresh;
  export type Response = ICommunityPlatformAdmin.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/admin/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/admin/refresh";
  export const random = (): ICommunityPlatformAdmin.IAuthorized =>
    typia.random<ICommunityPlatformAdmin.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
