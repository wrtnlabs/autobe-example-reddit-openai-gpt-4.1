import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformAdminUser } from "../../../structures/ICommunityPlatformAdminUser";

/**
 * Registers a new adminUser with credentials; issues JWT tokens.
 * (community_platform_adminusers, community_platform_user_credentials,
 * community_platform_sessions).
 *
 * This endpoint allows creation of a new adminUser account on the community
 * platform. It enforces the creation of a unique set of credentials in the
 * community_platform_user_credentials table, including a secure email address
 * and hashed password. Each new adminUser is linked by user_credential_id to a
 * record in community_platform_adminusers, which stores status and optional
 * display name. Responses issue initial JWT tokens (see
 * community_platform_sessions schema for session tracking).
 *
 * Creation and management of adminUser accounts is restricted—they can only be
 * registered through this endpoint by other administrators or during platform
 * bootstrapping. The operation validates email uniqueness and password strength
 * according to the credential schema, and all sensitive fields are omitted from
 * response. Credentials and platform session records are automatically linked
 * to the new adminUser. Passwords are hashed and not stored in plain text,
 * reflecting security best practices. The endpoint does not allow member->admin
 * conversion or general profile management.
 *
 * Sensitive fields (password_hash, deleted_at) are validated and stored per
 * schema rules. The adminUser is assigned a default active status, and
 * additional management is only permitted through admin-specific logic. The
 * join operation audits all actions using community_platform_audit_logs and
 * writes new session entries in community_platform_sessions for every login.
 * The endpoint does not expose profile editing, preference management, or
 * non-authentication flows.
 *
 * JWT tokens are issued on successful adminUser creation and must be tracked in
 * session tables for future management. All email/password validation is
 * enforced server-side. Related operations: adminUser login, refresh token, and
 * password reset flows.
 *
 * This is a platform-critical function ensuring secure, traceable onboarding of
 * admin-level platform accounts.
 *
 * @param props.connection
 * @param props.body AdminUser registration (join) details: credential info and
 *   optional display_name.
 * @setHeader token.access Authorization
 *
 * @path /auth/adminUser/join
 * @accessor api.functional.auth.adminUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * AdminUser registration (join) details: credential info and optional
     * display_name.
     */
    body: ICommunityPlatformAdminUser.IJoin;
  };
  export type Body = ICommunityPlatformAdminUser.IJoin;
  export type Response = ICommunityPlatformAdminUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/adminUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/adminUser/join";
  export const random = (): ICommunityPlatformAdminUser.IAuthorized =>
    typia.random<ICommunityPlatformAdminUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Logs in an adminUser account and issues JWT tokens.
 * (community_platform_adminusers, community_platform_sessions).
 *
 * Authenticates an adminUser by verifying their credentials against the
 * community_platform_user_credentials table and linking to the admin record in
 * community_platform_adminusers. On success, issues new JWT tokens, records
 * session in community_platform_sessions, and logs event in
 * community_platform_audit_logs. Only users with valid (active, not
 * suspended/deleted) status can login. Only supports adminUser accounts; member
 * or guest credentials are rejected.
 *
 * The endpoint does not permit any profile update, user management, or external
 * authentication. It validates password hashes securely and ensures proper
 * linking between credentials and admin account. Status is checked according to
 * used schema fields. All successful and failed login attempts are logged for
 * security. Result payload includes only token/session and admin user identity
 * data required for authenticated sessions.
 *
 * Related endpoints are: adminUser join/registration, token refresh, password
 * reset. Use this for platform admin login only; not for member/guest
 * accounts.
 *
 * @param props.connection
 * @param props.body AdminUser login credentials: email and (hashed) password.
 * @setHeader token.access Authorization
 *
 * @path /auth/adminUser/login
 * @accessor api.functional.auth.adminUser.login
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function login(
  connection: IConnection,
  props: login.Props,
): Promise<login.Response> {
  const output: login.Response =
    true === connection.simulate
      ? login.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...login.METADATA,
            path: login.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace login {
  export type Props = {
    /** AdminUser login credentials: email and (hashed) password. */
    body: ICommunityPlatformAdminUser.ILogin;
  };
  export type Body = ICommunityPlatformAdminUser.ILogin;
  export type Response = ICommunityPlatformAdminUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/adminUser/login",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/adminUser/login";
  export const random = (): ICommunityPlatformAdminUser.IAuthorized =>
    typia.random<ICommunityPlatformAdminUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: login.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: login.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refreshes JWT tokens for an adminUser account. (community_platform_sessions,
 * community_platform_adminusers).
 *
 * Issues new JWT tokens for an adminUser account, provided a valid refresh
 * token matching a live session in community_platform_sessions and the linked
 * community_platform_adminusers record. Only tokens for active (not
 * suspended/deleted) adminUsers can be renewed. Tracks and logs all token
 * refresh events for compliance (community_platform_audit_logs). The endpoint
 * does not allow registration, login by credentials, or password updates – only
 * authenticated refresh by token is performed.
 *
 * Does not perform any non-authentication or user management logic, reflecting
 * strict business segmentation of authentication/authorization operations.
 * Token renewal uses server-verified schema logic and does not expose any
 * sensitive credentials to the client. Related operations: join, login, and
 * password reset for admin users.
 *
 * @param props.connection
 * @param props.body Refresh token payload as issued by previous login/join;
 *   required for adminUser session continuation.
 * @setHeader token.access Authorization
 *
 * @path /auth/adminUser/refresh
 * @accessor api.functional.auth.adminUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Refresh token payload as issued by previous login/join; required for
     * adminUser session continuation.
     */
    body: ICommunityPlatformAdminUser.IRefresh;
  };
  export type Body = ICommunityPlatformAdminUser.IRefresh;
  export type Response = ICommunityPlatformAdminUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/adminUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/adminUser/refresh";
  export const random = (): ICommunityPlatformAdminUser.IAuthorized =>
    typia.random<ICommunityPlatformAdminUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
