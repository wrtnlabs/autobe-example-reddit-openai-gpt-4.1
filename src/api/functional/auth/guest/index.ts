import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformGuest } from "../../../structures/ICommunityPlatformGuest";

/**
 * Create and issue temporary guest identity (community_platform_guests).
 *
 * This endpoint allows a non-authenticated user (guest) to temporarily register
 * a guest identity for analytical tracking and session management purposes. No
 * credentials are required or issued; the system generates a unique
 * guest_identifier (e.g. cookie/session device ID), records optional IP and
 * user agent information, and logs the timestamp of guest registration.
 *
 * The guest join flow enables the platform to attribute browsing and engagement
 * to unique visitors for analytics and security (e.g., preventing abuse or
 * spam) without associating a concrete email or password. The related Prisma DB
 * entity is 'community_platform_guests', which persistently stores
 * guest_identifier, IP address, and user agent for each unique guest.
 *
 * Guest join does not create any permissions for the guest to post, comment,
 * vote, join or leave communities, or create content. The guest is strictly
 * limited to read-only actions, as established in the business requirement
 * analysis and permissions matrix. Guests can view all public content and
 * browse communities, posts, and comments.
 *
 * Security is enforced via JWT tokens issued for guest sessions, scoped only to
 * permitted actions (read/view, not write or interact). If a guest attempts to
 * upgrade (register as member), a new member identity is created, and their
 * guest session is discontinued.
 *
 * Related ops: Guest token refresh (for prolonged browsing), member upgrade
 * (handled by member join, not guest). Session expiration and actions requiring
 * member privileges must trigger a login prompt.
 *
 * This operation is public and does not require authentication.
 *
 * @param props.connection
 * @param props.body No input needed. Guest identity is auto-generated and
 *   tracked based on device/session/cookie.
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * No input needed. Guest identity is auto-generated and tracked based
     * on device/session/cookie.
     */
    body: ICommunityPlatformGuest.ICreate;
  };
  export type Body = ICommunityPlatformGuest.ICreate;
  export type Response = ICommunityPlatformGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/join";
  export const random = (): ICommunityPlatformGuest.IAuthorized =>
    typia.random<ICommunityPlatformGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Refresh access tokens for guest identity (community_platform_guests) using
 * refresh_token.
 *
 * This endpoint enables a guest user to renew their session by submitting a
 * valid refresh_token. The backend validates the refresh_token's association
 * with a guest identity in 'community_platform_guests', checks its expiry, and
 * then issues new session access credentials. All tokens are JWT, scoped for
 * guest activity, reflecting the guest_identifier.
 *
 * Guest session refresh ensures that non-authenticated browsing is
 * uninterrupted, preserving attribution for analytics and activity tracking.
 * Security verification verifies that the refresh_token is unexpired and mapped
 * to an active guest session record in the session management table.
 *
 * This operation does not grant, modify, or escalate privileges; it is strictly
 * for maintaining guest read/analytics session continuity.
 *
 * Security considerations include proper expiry and invalidation of tokens,
 * with protection against token replay and fixing. Session expiration still
 * requires the guest to re-initiate a join. Guests lack any write/interact
 * permissionsâ€”refresh simply restores their viewing capabilities for a longer
 * period.
 *
 * Related operations: Guest join (creates guest identity/session), session
 * invalidation on logout/expiration, member registration/upgrades handled
 * elsewhere.
 *
 * @param props.connection
 * @param props.body Request body containing the guest's valid refresh_token to
 *   issue a new session.
 * @setHeader token.access Authorization
 *
 * @path /auth/guest/refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Request body containing the guest's valid refresh_token to issue a
     * new session.
     */
    body: ICommunityPlatformGuest.IRefreshRequest;
  };
  export type Body = ICommunityPlatformGuest.IRefreshRequest;
  export type Response = ICommunityPlatformGuest.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guest/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guest/refresh";
  export const random = (): ICommunityPlatformGuest.IAuthorized =>
    typia.random<ICommunityPlatformGuest.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
