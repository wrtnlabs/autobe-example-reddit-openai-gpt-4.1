import { IConnection, HttpError } from "@nestia/fetcher";
import { PlainFetcher } from "@nestia/fetcher/lib/PlainFetcher";
import typia from "typia";
import { NestiaSimulator } from "@nestia/fetcher/lib/NestiaSimulator";

import { ICommunityPlatformGuestUser } from "../../../structures/ICommunityPlatformGuestUser";

/**
 * Guest user registration—create a guest session and issue a temporary token
 * (community_platform_guestusers).
 *
 * Initiates guest user registration, creating a row in
 * 'community_platform_guestusers' and issuing a temporary token, with no PII
 * stored by business logic or Prisma schema. Guest accounts provide only
 * browsing and analytics; they lack login credentials and do not have email,
 * password, or display name fields. The operation is public (unauthenticated);
 * it is designed to be invoked when a new visitor browses the community
 * platform or when browser/session state is lost. This registration action
 * creates a UUID and optional session_signature for the guest, recording
 * timestamps for first/last seen, with null 'deleted_at'.
 *
 * There is no credential authentication: guests may re-register or resume
 * without restrictions. Session tokens issued are short-lived and grant access
 * solely for anonymous browsing/searching (posting, voting, joining, or editing
 * require upgrading to memberUser). No PII is persisted—only opaque session
 * links for metrics. This operation is strictly non-destructive (idempotent).
 * Security risk is minimal since guest actions are highly constrained by
 * business logic and enforced in every feature layer.
 *
 * Interacts with 'community_platform_guestusers' and is referenced by all
 * analytics and log tables related to session tracking. Related operations
 * include 'refresh' (for extending guest sessions), and all upgrade/auth flows
 * for registered users. Member and admin actions are explicitly blocked for
 * guests.
 *
 * Client may call this endpoint multiple times; each executes independently
 * with no conflict. For transitioning to memberUser, use the member
 * registration flow, which requires email, password, and explicit
 * authentication, not supported here.
 *
 * The response DTO is ICommunityPlatformGuestUser.IAuthorized: contains a
 * temporary token, expiry, and assigned guest UUID, exactly as provisioned by
 * platform authentication business logic.
 *
 * @param props.connection
 * @param props.body Guest session registration body. No user PII; only optional
 *   opaque session_signature for session re-linking. Used strictly for session
 *   analytics.
 * @setHeader token.access Authorization
 *
 * @path /auth/guestUser/join
 * @accessor api.functional.auth.guestUser.join
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function join(
  connection: IConnection,
  props: join.Props,
): Promise<join.Response> {
  const output: join.Response =
    true === connection.simulate
      ? join.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...join.METADATA,
            path: join.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace join {
  export type Props = {
    /**
     * Guest session registration body. No user PII; only optional opaque
     * session_signature for session re-linking. Used strictly for session
     * analytics.
     */
    body: ICommunityPlatformGuestUser.IJoin;
  };
  export type Body = ICommunityPlatformGuestUser.IJoin;
  export type Response = ICommunityPlatformGuestUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestUser/join",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestUser/join";
  export const random = (): ICommunityPlatformGuestUser.IAuthorized =>
    typia.random<ICommunityPlatformGuestUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: join.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: join.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}

/**
 * Guest session token refresh—extend guest access with a new temporary token
 * (community_platform_guestusers).
 *
 * This operation refreshes a temporary access token for a guest account, based
 * on the original guest token issued at registration. It ensures that the
 * linked guest account entry in 'community_platform_guestusers' is still active
 * (deleted_at is null) and not expired or revoked. Session renewal returns a
 * new signed JWT with a refreshed expiry. No credentials are used since guest
 * accounts contain no personal information; instead, only the temporary token
 * is validated. Guests cannot refresh their token if their session has been
 * deleted. Each refresh produces a new short-lived token, permitting continued
 * anonymous access.
 *
 * @param props.connection
 * @param props.body Request payload with the current guest user's token (from
 *   prior join/refresh calls).
 * @setHeader token.access Authorization
 *
 * @path /auth/guestUser/refresh
 * @accessor api.functional.auth.guestUser.refresh
 * @autobe Generated by AutoBE - https://github.com/wrtnlabs/autobe
 */
export async function refresh(
  connection: IConnection,
  props: refresh.Props,
): Promise<refresh.Response> {
  const output: refresh.Response =
    true === connection.simulate
      ? refresh.simulate(connection, props)
      : await PlainFetcher.fetch(
          {
            ...connection,
            headers: {
              ...connection.headers,
              "Content-Type": "application/json",
            },
          },
          {
            ...refresh.METADATA,
            path: refresh.path(),
            status: null,
          },
          props.body,
        );
  connection.headers ??= {};
  connection.headers.Authorization = output.token.access;
  return output;
}
export namespace refresh {
  export type Props = {
    /**
     * Request payload with the current guest user's token (from prior
     * join/refresh calls).
     */
    body: ICommunityPlatformGuestUser.IRefresh;
  };
  export type Body = ICommunityPlatformGuestUser.IRefresh;
  export type Response = ICommunityPlatformGuestUser.IAuthorized;

  export const METADATA = {
    method: "POST",
    path: "/auth/guestUser/refresh",
    request: {
      type: "application/json",
      encrypted: false,
    },
    response: {
      type: "application/json",
      encrypted: false,
    },
  } as const;

  export const path = () => "/auth/guestUser/refresh";
  export const random = (): ICommunityPlatformGuestUser.IAuthorized =>
    typia.random<ICommunityPlatformGuestUser.IAuthorized>();
  export const simulate = (
    connection: IConnection,
    props: refresh.Props,
  ): Response => {
    const assert = NestiaSimulator.assert({
      method: METADATA.method,
      host: connection.host,
      path: refresh.path(),
      contentType: "application/json",
    });
    try {
      assert.body(() => typia.assert(props.body));
    } catch (exp) {
      if (!typia.is<HttpError>(exp)) throw exp;
      return {
        success: false,
        status: exp.status,
        headers: exp.headers,
        data: exp.toJSON().message,
      } as any;
    }
    return random();
  };
}
