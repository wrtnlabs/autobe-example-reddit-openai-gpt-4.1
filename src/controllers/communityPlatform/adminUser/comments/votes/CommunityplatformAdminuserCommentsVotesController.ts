import { Controller } from "@nestjs/common";
import { TypedRoute, TypedParam, TypedBody } from "@nestia/core";
import typia, { tags } from "typia";
import { post__communityPlatform_adminUser_comments_$commentId_votes } from "../../../../../providers/post__communityPlatform_adminUser_comments_$commentId_votes";
import { AdminuserAuth } from "../../../../../decorators/AdminuserAuth";
import { AdminuserPayload } from "../../../../../decorators/payload/AdminuserPayload";
import { patch__communityPlatform_adminUser_comments_$commentId_votes } from "../../../../../providers/patch__communityPlatform_adminUser_comments_$commentId_votes";
import { get__communityPlatform_adminUser_comments_$commentId_votes_$voteId } from "../../../../../providers/get__communityPlatform_adminUser_comments_$commentId_votes_$voteId";
import { put__communityPlatform_adminUser_comments_$commentId_votes_$voteId } from "../../../../../providers/put__communityPlatform_adminUser_comments_$commentId_votes_$voteId";
import { delete__communityPlatform_adminUser_comments_$commentId_votes_$voteId } from "../../../../../providers/delete__communityPlatform_adminUser_comments_$commentId_votes_$voteId";

import { ICommunityPlatformCommentVote } from "../../../../../api/structures/ICommunityPlatformCommentVote";
import { IPageICommunityPlatformCommentVote } from "../../../../../api/structures/IPageICommunityPlatformCommentVote";

@Controller("/communityPlatform/adminUser/comments/:commentId/votes")
export class CommunityplatformAdminuserCommentsVotesController {
  /**
   * Create a new vote (upvote/downvote) on a comment
   * (community_platform_comment_votes).
   *
   * This endpoint allows an authenticated user to cast an upvote or downvote on
   * a specific comment. Only valid vote types are accepted ('upvote',
   * 'downvote', or clearing vote with 'none'). The system ensures one record
   * per user per comment, creating or updating the user's vote as appropriate.
   *
   * Business logic enforces that users cannot vote on their own comments;
   * attempts to do so result in a permission error. On casting or updating a
   * vote, the vote_type, voter identity (memberUser or adminUser), timestamps,
   * and target comment are stored in the community_platform_comment_votes
   * table.
   *
   * Security is enforced so only the voting user (memberUser or adminUser) may
   * create their own votes. This operation is essential for the platform's
   * reputation and scoring system for comment engagement. Vote score
   * calculation is handled elsewhere.
   *
   * @param connection
   * @param commentId Unique identifier of the comment to vote on
   * @param body Vote object to be created with commentId, voter, and vote_type
   *   (upvote, downvote, none)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Post()
  public async create(
    @AdminuserAuth()
    adminUser: AdminuserPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommentVote.ICreate,
  ): Promise<ICommunityPlatformCommentVote> {
    try {
      return await post__communityPlatform_adminUser_comments_$commentId_votes({
        adminUser,
        commentId,
        body,
      });
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Paginated list of votes for a comment (community_platform_comment_votes).
   *
   * This endpoint returns a filtered, sorted, and paginated list of votes on a
   * particular comment, identified by its commentId parameter. The votes
   * originate from the community_platform_comment_votes table, with each vote
   * associated with a comment, a user (member or admin), and a vote_type field
   * ('upvote', 'downvote', 'none').
   *
   * Advanced request filtering allows for slicing by vote_type, voter identity,
   * or time range. The results are paginated and sortable by the created_at
   * timestamp or vote_type for audits or engagement metrics.
   *
   * Security policies may limit access to full voter identity to admin users,
   * while general engagement metrics are available to all. Pagination ensures
   * performance and scalability for comments with high engagement. Business
   * logic ensures only existing votes for the specified commentId are returned.
   * Error handling covers invalid IDs, query parameters, and unauthorized
   * requests.
   *
   * @param connection
   * @param commentId Unique identifier of the comment whose votes should be
   *   listed
   * @param body Search and filtering options for comment votes (pagination,
   *   sorting, voter, vote_type)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Patch()
  public async index(
    @AdminuserAuth()
    adminUser: AdminuserPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommentVote.IRequest,
  ): Promise<IPageICommunityPlatformCommentVote> {
    try {
      return await patch__communityPlatform_adminUser_comments_$commentId_votes(
        {
          adminUser,
          commentId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Get a specific vote on a comment (community_platform_comment_votes).
   *
   * This endpoint returns the details of a specific comment vote as identified
   * by voteId and associated with the given commentId. The underlying data
   * source is the community_platform_comment_votes table, which includes one
   * entry per user per comment capturing vote_type (upvote, downvote, none),
   * voter identity, and audit metadata.
   *
   * Primarily intended for administrative views and audit dashboards, this
   * operation exposes detailed vote information, including which user
   * (memberUser or adminUser) cast the vote. Security rules ensure that only
   * users with appropriate admin privileges may view full voter details.
   *
   * Proper validation occurs to ensure the voteId matches a vote on the
   * specified commentId before retrieval. If no match exists, the operation
   * returns an error. Data can be used for analytic and moderation purposes.
   *
   * @param connection
   * @param commentId Unique identifier of the parent comment
   * @param voteId Unique identifier of the comment vote
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Get(":voteId")
  public async at(
    @AdminuserAuth()
    adminUser: AdminuserPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedParam("voteId")
    voteId: string & tags.Format<"uuid">,
  ): Promise<ICommunityPlatformCommentVote> {
    try {
      return await get__communityPlatform_adminUser_comments_$commentId_votes_$voteId(
        {
          adminUser,
          commentId,
          voteId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Update the vote state for a comment vote
   * (community_platform_comment_votes).
   *
   * This endpoint allows the original voter (memberUser or adminUser) or an
   * admin to change the state of a vote on a comment, such as toggling
   * upvote/downvote or clearing to none. The operation validates that the
   * voteId is associated with the specified commentId, and that the user has
   * permission (voter = self or admin privilege).
   *
   * Validation ensures that users cannot vote on their own comments. State
   * transitions follow platform voting business logic: toggling between upvote,
   * downvote, and none. Updated_at is changed to reflect the most recent
   * action, with full support for audit/compliance. Errors are returned for
   * invalid vote states, permission failures, or mismatched IDs.
   *
   * @param connection
   * @param commentId Unique identifier of the target comment
   * @param voteId Unique identifier of the comment vote to update
   * @param body Fields to update in the comment vote (vote_type: upvote,
   *   downvote, none)
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Put(":voteId")
  public async update(
    @AdminuserAuth()
    adminUser: AdminuserPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedParam("voteId")
    voteId: string & tags.Format<"uuid">,
    @TypedBody()
    body: ICommunityPlatformCommentVote.IUpdate,
  ): Promise<ICommunityPlatformCommentVote> {
    try {
      return await put__communityPlatform_adminUser_comments_$commentId_votes_$voteId(
        {
          adminUser,
          commentId,
          voteId,
          body,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }

  /**
   * Delete a comment vote (community_platform_comment_votes).
   *
   * This endpoint allows the original voter (memberUser or adminUser) or a
   * platform admin to remove a vote they have cast on a comment. By deleting
   * the vote record (hard delete), the platform forgets the user's vote state
   * for the targeted comment. The database table is
   * community_platform_comment_votes.
   *
   * The operation validates that the provided voteId is linked to the specified
   * commentId, and ensures that only the original voter or admin has permission
   * to delete. This operation is commonly used to allow users to retract their
   * upvote/downvote, and also serves as a moderation tool for platform
   * administrators. No content is returned in the response upon successful
   * deletion.
   *
   * @param connection
   * @param commentId Unique identifier of the parent comment
   * @param voteId Unique identifier of the comment vote to delete
   * @nestia Generated by Nestia - https://github.com/samchon/nestia
   */
  @TypedRoute.Delete(":voteId")
  public async erase(
    @AdminuserAuth()
    adminUser: AdminuserPayload,
    @TypedParam("commentId")
    commentId: string & tags.Format<"uuid">,
    @TypedParam("voteId")
    voteId: string & tags.Format<"uuid">,
  ): Promise<void> {
    try {
      return await delete__communityPlatform_adminUser_comments_$commentId_votes_$voteId(
        {
          adminUser,
          commentId,
          voteId,
        },
      );
    } catch (error) {
      console.log(error);
      throw error;
    }
  }
}
