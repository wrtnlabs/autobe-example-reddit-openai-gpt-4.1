{"operations":[{"specification":"Implements the core authentication JOIN and REFRESH operations for the guest role in the Reddit-like community platform. As guests are non-authenticated users, they do not have login credentials and cannot perform a login operation. This API provides mechanisms to create a temporary guest identity (join) and to refresh access using a valid refresh token. These operations are tightly bound to the 'community_platform_guests' table, which records pseudonymous analytics identifiers, IP address, user agent, and timestamps for each guest session. There are no credentials or account lifecycle beyond session-based analytics. Guest join issues an ephemeral, pseudonymous account with guest_identifier, while refresh uses the active refresh_token to issue a new access token for ongoing guest browsing and analytics attribution.","authorizationType":"join","description":"This endpoint allows a non-authenticated user (guest) to temporarily register a guest identity for analytical tracking and session management purposes. No credentials are required or issued; the system generates a unique guest_identifier (e.g. cookie/session device ID), records optional IP and user agent information, and logs the timestamp of guest registration.\n\nThe guest join flow enables the platform to attribute browsing and engagement to unique visitors for analytics and security (e.g., preventing abuse or spam) without associating a concrete email or password. The related Prisma DB entity is 'community_platform_guests', which persistently stores guest_identifier, IP address, and user agent for each unique guest.\n\nGuest join does not create any permissions for the guest to post, comment, vote, join or leave communities, or create content. The guest is strictly limited to read-only actions, as established in the business requirement analysis and permissions matrix. Guests can view all public content and browse communities, posts, and comments.\n\nSecurity is enforced via JWT tokens issued for guest sessions, scoped only to permitted actions (read/view, not write or interact). If a guest attempts to upgrade (register as member), a new member identity is created, and their guest session is discontinued.\n\nRelated ops: Guest token refresh (for prolonged browsing), member upgrade (handled by member join, not guest). Session expiration and actions requiring member privileges must trigger a login prompt.\n\nThis operation is public and does not require authentication.","summary":"Create and issue temporary guest identity (community_platform_guests).","parameters":[],"requestBody":{"description":"No input needed. Guest identity is auto-generated and tracked based on device/session/cookie.","typeName":"ICommunityPlatformGuest.ICreate"},"responseBody":{"description":"Session and authorization info for the newly created guest identity, with issued JWT session tokens and guest_identifier.","typeName":"ICommunityPlatformGuest.IAuthorized"},"authorizationRole":null,"name":"join","path":"/auth/guest/join","method":"post"},{"specification":"Implements the refresh of access tokens for guest identities in the Reddit-like community platform. This operation allows a non-authenticated guest to present a valid refresh_token and receive a new access (and optionally refresh) token pair for session continuation. This is essential to maintain seamless browsing and analytics for guests without requiring regular login re-prompts. The operation is connected to the 'community_platform_guests' table and interacts with session tracking via 'community_platform_sessions'. Cannot be used to promote guest to member; only supports continued guest access.","authorizationType":"refresh","description":"This endpoint enables a guest user to renew their session by submitting a valid refresh_token. The backend validates the refresh_token's association with a guest identity in 'community_platform_guests', checks its expiry, and then issues new session access credentials. All tokens are JWT, scoped for guest activity, reflecting the guest_identifier.\n\nGuest session refresh ensures that non-authenticated browsing is uninterrupted, preserving attribution for analytics and activity tracking. Security verification verifies that the refresh_token is unexpired and mapped to an active guest session record in the session management table.\n\nThis operation does not grant, modify, or escalate privileges; it is strictly for maintaining guest read/analytics session continuity.\n\nSecurity considerations include proper expiry and invalidation of tokens, with protection against token replay and fixing. Session expiration still requires the guest to re-initiate a join. Guests lack any write/interact permissions—refresh simply restores their viewing capabilities for a longer period.\n\nRelated operations: Guest join (creates guest identity/session), session invalidation on logout/expiration, member registration/upgrades handled elsewhere.","summary":"Refresh access tokens for guest identity (community_platform_guests) using refresh_token.","parameters":[],"requestBody":{"description":"Request body containing the guest's valid refresh_token to issue a new session.","typeName":"ICommunityPlatformGuest.IRefreshRequest"},"responseBody":{"description":"Refreshed session and authorization info with new JWT tokens for the guest identity.","typeName":"ICommunityPlatformGuest.IAuthorized"},"authorizationRole":null,"name":"refresh","path":"/auth/guest/refresh","method":"post"},{"specification":"Create a new member account for a community platform. This registration operation is associated with the 'community_platform_members' table. The endpoint is used when a user wants to register as a new member, providing their email and password to set up their identity. Upon successful completion, the member is created, their hashed password is recorded, display name is optional, and the account is flagged as active. After registration, the service should issue initial JWT access and refresh tokens for immediate use. Registration is only possible if the email is unique; duplicate attempts with an existing email must be rejected. Security and validation rules dictate that the password is not stored directly but as 'password_hash', and minimum complexity rules must be enforced. This operation is public and does not require prior authorization.","authorizationType":"join","description":"This API operation enables user registration as a 'member' on the community platform, directly writing to the 'community_platform_members' table as per the Prisma schema.\n\nUpon successful execution, a new member row is created with 'email' (for authentication and communication), a securely hashed 'password_hash' (never storing plaintext), and an optional 'display_name' alias (defaults to 'Anonymous' if not provided). The 'is_active' flag is set to true for immediate account activation, and timestamps for account creation and update are managed automatically in accordance with the database schema.\n\nThis operation carefully enforces the unique constraint on 'email', and will reject attempts to register with a duplicate address, returning an appropriate error. The 'password_hash' is generated from a complexity-validated raw password submitted by the client, aligning with business rule requirements for minimum length and content.\n\nOn successful registration, the endpoint will issue initial JWT tokens (access and refresh) to the newly created account, embedding 'userId', 'role', and relevant permissions into the token payload as described in the requirements. Session creation may be reflected in the 'community_platform_sessions' entity, but is abstracted from this join endpoint.\n\nFailures due to duplicate email or insufficient password complexity must provide clear, user-facing error messages. This operation is foundational for member onboarding, preceding all interactive platform actions.\n\nThis endpoint is often paired with 'login' for future sign-ins, and with 'refresh' for session renewal. It forms the basis for standard authentication flows for registered users of the community platform.","summary":"Register a new member account (community_platform_members) and issue login tokens.","parameters":[],"requestBody":{"description":"Information required to create a new member account (email, password, optional display_name).","typeName":"ICommunityPlatformMember.ICreate"},"responseBody":{"description":"JWT tokens and authorized user identity after successful registration.","typeName":"ICommunityPlatformMember.IAuthorized"},"authorizationRole":null,"name":"join","path":"/auth/member/join","method":"post"},{"specification":"Authenticate a registered member and issue JWT tokens. This login endpoint is associated with the 'community_platform_members' table, requiring the user's email and password for authentication. The system verifies the provided credentials by comparing the raw password to the securely stored 'password_hash'. If authentication is successful and the 'is_active' flag is true, a new JWT access token and refresh token are issued along with identity and permission claims relevant to this role. Authentication failures, including invalid credentials or inactive/deleted accounts, return appropriate errors without revealing sensitive information. This operation is essential for all subsequent member interactions in the community platform.","authorizationType":"login","description":"This API operation handles the authentication (login) process for 'member' users of the community platform, and is mapped to the 'community_platform_members' table as defined in the Prisma schema.\n\nThe operation verifies the provided login 'email' and 'password' against the database, validating the 'password_hash' using a secure, industry-standard hashing algorithm. Only accounts flagged as 'is_active' and not marked 'deleted_at' can successfully authenticate. The API must never reveal whether an email exists for failed login attempts, to prevent account enumeration attacks.\n\nUpon successful authentication, the member's 'last_login_at' timestamp is updated to the current time, and JWT access and refresh tokens are issued. The tokens encode the member's identity, assigned role ('member'), and permissions as outlined in the business requirements. Token expiration policies and refresh token issuance must follow platform standards.\n\nThis operation does not handle registration ('join') or password reset—instead, it is focused solely on login/authentication. Error messages for failed logins must be generic and never expose internal authentication state or existence of specific accounts. Repeated failed attempts may trigger account lockout or rate-limiting (not enforced directly in this endpoint).\n\nCommonly used in conjunction with the registration and token refresh endpoints, it is critical for platform session management and user action authorization for members.","summary":"Authenticate a member and return JWT tokens for the session (community_platform_members).","parameters":[],"requestBody":{"description":"Member login credentials (email, password).","typeName":"ICommunityPlatformMember.ILogin"},"responseBody":{"description":"JWT tokens and authorized user identity after successful authentication.","typeName":"ICommunityPlatformMember.IAuthorized"},"authorizationRole":null,"name":"login","path":"/auth/member/login","method":"post"},{"specification":"Issue new JWT tokens for a member using a valid refresh token. This session continuation endpoint references the 'community_platform_sessions' and 'community_platform_members' tables. It requires the client to present a valid, non-expired refresh token previously issued for the user via 'login' or 'join'. On validation, it issues a new JWT access token (and optionally a new refresh token), maintaining the user's session and permissions context. Handles session expiration, invalidation (e.g., after password change or logout), and ensures correct audit trail for security and compliance. If the refresh token is invalid, expired, or revoked, access is denied with an appropriate error message. Ensures role and permissions consistency for all subsequent platform interactions.","authorizationType":"refresh","description":"This API operation provides session renewal for 'member' users through refresh token validation, based on the 'community_platform_sessions' and 'community_platform_members' tables defined in the Prisma schema.\n\nOn successful verification of the provided refresh token, new JWT tokens (access and refresh) are generated for the member user. This operation maintains the user's active session, enforces expiration policies, and embeds correct identity and permission claims as described in the requirements.\n\nThe operation checks that the supplied refresh token matches a valid, non-expired, and non-invalidated session for the requesting user. If the token has expired, been invalidated (such as from logout everywhere or password change), or does not exist in the 'community_platform_sessions' table, the request must return an appropriate authentication error.\n\nThis endpoint is essential for maintaining continuous authentication without repeated username/password entry, and is a core part of the JWT-based authentication flow. The operation is never used for initial login or registration, but as a means to prolong established sessions securely and conveniently. All session updates are reflected in the platform's session management logic for audit and security.","summary":"Renew JWT tokens for a member using refresh token (community_platform_sessions, community_platform_members).","parameters":[],"requestBody":{"description":"Refresh token corresponding to an existing, valid session for the member.","typeName":"ICommunityPlatformMember.IRefreshRequest"},"responseBody":{"description":"New JWT tokens and authorized user identity after successful refresh.","typeName":"ICommunityPlatformMember.IAuthorized"},"authorizationRole":null,"name":"refresh","path":"/auth/member/refresh","method":"post"},{"specification":"Initiate a password reset workflow for a member on the community platform. Associated with the 'community_platform_password_resets' and 'community_platform_members' tables. The operation accepts a member email address, verifies its existence and active status, and generates a cryptographically secure, one-time password reset token with a limited lifetime. This token is registered in the password resets table and emailed to the member. The endpoint must not reveal whether the email exists (to avoid account enumeration). Error responses are generic. This operation does not perform the reset itself, but initiates the reset by sending email instructions.","authorizationType":null,"description":"This API operation initiates a password reset process for 'member' user accounts, referencing the 'community_platform_password_resets' and 'community_platform_members' tables in the Prisma schema.\n\nUpon receiving a member's email address, the system searches for an active and undeleted user; if found, a single-use, cryptographically secure 'reset_token' is generated, stored with an expiration in the password resets table, and associated with the member. The system then sends an email to the provided address with reset instructions, regardless of whether the address is found, to prevent information leakage.\n\nNo password is changed at this stage—the endpoint only starts the reset process. If a request is made for a non-existent, inactive, or deleted email, a generic success response is returned, never revealing account existence. The member uses the reset token and a subsequent endpoint to complete password reset.\n\nAudit trails for this workflow are maintained via the password resets and related session management logic. This operation is typically followed by the 'resetPasswordComplete' operation for updating the password using the token.","summary":"Initiate password reset workflow for member accounts (community_platform_members, community_platform_password_resets).","parameters":[],"requestBody":{"description":"Member password reset request (email address).","typeName":"ICommunityPlatformMember.IPasswordResetInitiate"},"responseBody":{"description":"Status message confirming initiation of password reset process.","typeName":"ICommunityPlatformMember.IPasswordResetInitiateResponse"},"authorizationRole":null,"name":"initiatePasswordReset","path":"/auth/member/password/reset/initiate","method":"post"},{"specification":"Complete the password reset workflow for a member using a valid reset token. Associated with the 'community_platform_password_resets' and 'community_platform_members' tables. Takes the member's reset token and new password, verifies that the reset request is valid, unused, and unexpired, then sets the new password (hashed) for the associated member account. The password resets entry is marked as used, and all previous sessions for the account are invalidated. Success is confirmed by a response message. Invalid, expired, or already used tokens are rejected. This endpoint does not issue new JWT tokens; the member must log in again with the new password. Password must meet complexity requirements and is never stored in plaintext.","authorizationType":null,"description":"This API operation finalizes the password reset process for 'member' users by accepting a valid one-time reset token and a new password, mapping to the 'community_platform_password_resets' and 'community_platform_members' tables.\n\nUpon receiving a reset token and new password (the latter to be securely hashed), the system validates that the reset token exists, has not been used, is not expired, and is associated with an active member. On success, the member's 'password_hash' is updated accordingly, the reset record is marked as used, and all prior access/refresh tokens (sessions) for the user are invalidated for security.\n\nIf the token is invalid, expired, or has already been used, an appropriate error is returned. If successful, the endpoint issues a response confirming that the password was changed. The member must log in again with the new password; no JWT tokens are issued here. Enforces all current password complexity rules as per business specifications.","summary":"Complete password reset for member account using one-time token (community_platform_password_resets).","parameters":[],"requestBody":{"description":"Password reset confirmation (reset token, new password).","typeName":"ICommunityPlatformMember.IPasswordResetComplete"},"responseBody":{"description":"Confirmation message indicating that the member's password was successfully reset.","typeName":"ICommunityPlatformMember.IPasswordResetCompleteResponse"},"authorizationRole":null,"name":"completePasswordReset","path":"/auth/member/password/reset/complete","method":"post"},{"specification":"Create an admin authentication/registration API operation for the community platform. This allows the creation of new admin accounts by submitting the required registration data, resulting in issuance of initial JWT tokens for subsequent policy-based access. The operation is dedicated to the community_platform_admins Prisma schema table. The API expects a valid email, a secure password (to be hashed and stored in password_hash), an optional display_name for administrative references, and sets is_active true by default. On success, a new row is created in community_platform_admins and the response contains credentials and all relevant permission claims. This is the formal admin registration endpoint, not to be used for regular member creation. All returned tokens and permissions must map to the admin role with super-admin status respected as per is_super_admin field. Audit compliance and onboarding flows should reference this registration as their root entry for admin authentication.","authorizationType":"join","description":"This operation enables new admin accounts to be registered within the system by providing required fields (email, password, optional display_name), as defined in the community_platform_admins Prisma schema. On submission, the input email is checked against existing entries in community_platform_admins for uniqueness; password is securely hashed per operational security policy.\n\nCreation of the admin entity triggers initial is_active status as true and, if specified, is_super_admin can be handled by business logic (but not settable directly at registration). Additional fields (last_login_at, deleted_at) are null on creation, adhering to audit requirements. The admin object persists all identifiers for linkage to session management, moderation, and the audit trail, forming the basis of future administrative access.\n\nUpon successful registration, a new admin session JWT is issued with proper privileges, and the response follows ICommunityPlatformAdmin.IAuthorized security conventions as specified in documentation. If registration fails (e.g., duplicate email), the operation returns appropriate authentication failure details.\n\nSecurity-wise, only non-authenticated users should access this operation; subsequent authentication prevents duplicate accounts. Input validation must enforce business rules for admin emails and passwords. This endpoint is essential for bootstrapping initial admin users and is referenced by other admin management APIs (login, refresh, password recovery).\n\nRelated operations include admin login and refresh endpoints, which use matching tokens issued as a result of this registration flow. For field/content errors, the endpoint always returns detailed validation error information without exposing sensitive admin fields or password hashes.","summary":"Create a new admin account (community_platform_admins) and issue JWT tokens for admin authentication.","parameters":[],"requestBody":{"description":"Admin registration data: email, password (to be hashed), and optional display_name.","typeName":"ICommunityPlatformAdmin.IJoin"},"responseBody":{"description":"Authorization tokens and admin details for authenticated API access, in ICommunityPlatformAdmin.IAuthorized format.","typeName":"ICommunityPlatformAdmin.IAuthorized"},"authorizationRole":null,"name":"join","path":"/auth/admin/join","method":"post"},{"specification":"Create an admin login/authentication endpoint. This allows registered admin users to authenticate using their email and password, resulting in JWT token issuance for privileged access. The endpoint is defined against the community_platform_admins table, using password_hash for credential comparison. On success, tokens must contain claims indicating admin status and permissions for system-wide access. Session creation is logged, and audit compliance extends to login attempts. This is exclusively for admin authentication.","authorizationType":"login","description":"This endpoint allows existing admin users to sign in, as defined by the community_platform_admins Prisma schema, via their unique email and password. The password is validated by comparing a securely hashed version against the password_hash field in the database.\n\nWhen credentials are correct and the admin account is active, the system issues JWT tokens containing admin identity, permission claims (including is_super_admin and is_active), and session data. Failed attempts—such as account inactive, incorrect password, or soft-deleted (deleted_at set)—result in appropriate authentication failure error messages.\n\nThis operation is restricted to emails found in the community_platform_admins table where is_active is true and deleted_at is null. On first successful login, last_login_at is set to now; otherwise it updates accordingly. All login attempts are audit-logged for security, referencing admin_id and result.\n\nLogin is a prerequisite for other admin functions (refresh, moderation, password reset). Business logic must ensure tokens conform to ICommunityPlatformAdmin.IAuthorized structure and never expose password_hash. All error states should trigger clear, secure error messages, with zero information leakage about admin existence or status beyond what is required.","summary":"Authenticate admin (community_platform_admins) and issue JWT tokens for access.","parameters":[],"requestBody":{"description":"Admin credentials (email, raw password) to authenticate against community_platform_admins.","typeName":"ICommunityPlatformAdmin.ILogin"},"responseBody":{"description":"JWT tokens and admin profile details in ICommunityPlatformAdmin.IAuthorized format, with permission claims and session data.","typeName":"ICommunityPlatformAdmin.IAuthorized"},"authorizationRole":null,"name":"login","path":"/auth/admin/login","method":"post"},{"specification":"Create an admin session refresh endpoint for JWT tokens. This endpoint allows re-issuance of access tokens when a valid refresh token is presented, supporting session continuation for admin accounts (community_platform_admins). Refresh tokens are tracked per session in the community_platform_sessions table, and their validity is checked before re-issuing new access tokens. This operation is required for long-lived admin sessions.","authorizationType":"refresh","description":"This operation enables admin users to refresh JWT access tokens by providing a valid refresh token, in accordance with the session-management architecture defined on top of community_platform_sessions for admin users. The endpoint cross-verifies the refresh_token in community_platform_sessions, checks expiry and invalidation states, and creates a new access token if the request is valid.\n\nOnly refresh tokens that have not expired, are not invalidated (invalidated_at is null), and match a living admin account (community_platform_admins, is_active true, deleted_at null) succeed. Audit logging persists every refresh event, tracking the session and admin entity. If the refresh token is invalid, expired, or associated admin is no longer valid, the operation returns an authentication failure with an appropriate error message.\n\nOn success, the endpoint returns new access/refresh tokens using the ICommunityPlatformAdmin.IAuthorized format, inheriting all admin claims and security state. This operation is referenced by all long-session client flows and acts as the continuity endpoint for admin JWT authentication lifecycle. Input tokens are never persisted in logs, and validation failure details are generic to prevent disclosure of account or session state.","summary":"Refresh JWT tokens for admin (community_platform_admins) via active session record (community_platform_sessions).","parameters":[],"requestBody":{"description":"Refresh token for the admin session associated to community_platform_admins. May require session/device info.","typeName":"ICommunityPlatformAdmin.IRefresh"},"responseBody":{"description":"New JWT tokens and permission/identity details for admin, formatted as ICommunityPlatformAdmin.IAuthorized.","typeName":"ICommunityPlatformAdmin.IAuthorized"},"authorizationRole":null,"name":"refresh","path":"/auth/admin/refresh","method":"post"},{"specification":"Retrieves a paginated, filterable list of all community platform categories in the system. The operation supports advanced filtering by code, display name, or description, and includes searching, sorting, and pagination. This enables administrators and moderators to manage category options, audit their use, and prepare category dropdowns for UI. Category information is based on the 'community_platform_categories' schema, which ensures each category has a unique code and name, descriptive metadata, and audit timestamps. This operation is critical for category curation, normalization, and category-entity linking across sub-communities. Only categories not soft-deleted (where deleted_at is null) are returned in normal queries.","prisma_schemas":"model community_platform_categories {\n  id String @id @db.Uuid\n  code String\n  name String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  community_platform_communities community_platform_communities[]\n  @@unique([code])\n  @@unique([name])\n  @@index([created_at])\n}","authorizationRoles":["admin"],"description":"This API operation fetches a filtered and paginated list of all defined community categories. It allows admin users to perform comprehensive search and management tasks on existing categories, which are used to organize sub-communities. The response includes details such as category code, display name, description, status (active/soft-deleted), and timestamps.\n\nAccess to this operation is available to admin users only, as category management directly impacts platform taxonomy and business reporting. The endpoint is expected to exclude categories marked as soft-deleted unless included by request.\n\nAdvanced search parameters such as partial name/code matching and order-by fields are available for rich UI experiences and reporting. Related API operations include category creation, update, retrieval, and deletion endpoints, which together make up the category lifecycle management suite. Category records connect with the sub-community model for entity enforcement and consistency.","summary":"Search and retrieve a paginated, filterable list of all community categories","parameters":[],"requestBody":{"description":"Filter/search, pagination, and sort options for category retrieval","typeName":"ICommunityPlatformCategory.IRequest"},"responseBody":{"description":"Paginated, filterable list of category summary entities, including code, name, description, and audit info","typeName":"IPageICommunityPlatformCategory.ISummary"},"name":"index","path":"/communityPlatform/admin/categories","method":"patch","model_name":"community_platform_categories","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieves full details for a specific community platform category by categoryId (UUID). Returns the complete information for display/edit in admin interface. The operation checks for soft deletion and returns not found for deleted categories. This is based on the 'community_platform_categories' table.","prisma_schemas":"model community_platform_categories {\n  id String @id @db.Uuid\n  code String\n  name String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  community_platform_communities community_platform_communities[]\n  @@unique([code])\n  @@unique([name])\n  @@index([created_at])\n}","authorizationRoles":["admin"],"description":"Fetches the details of a single community platform category specified by categoryId. Returns all available information (id, code, name, description, timestamps) for use in edit or display screens. Soft-deleted categories are not returned unless requested by super-admins or recovery workflows.\n\nAdmin users only may call this endpoint due to taxonomy system impact. Not found is reported when a non-existent or deleted category is requested. Related operations include updating or deleting categories, as well as listing all categories for management views.","summary":"Get details for a specific community category by its UUID identifier","parameters":[{"name":"categoryId","description":"The UUID of the target category to retrieve","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full information for a single community category entity","typeName":"ICommunityPlatformCategory"},"name":"at","path":"/communityPlatform/admin/categories/{categoryId}","method":"get","model_name":"community_platform_categories","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Creates a new community category entity for organizing sub-communities. The category must have a unique code, unique name, and a human-readable display name. Optionally, an admin can define a long-form description. The system enforces uniqueness for code and name within 'community_platform_categories'. The operation supports taxonomy management, new community growth, and dynamic category expansion. This must be called by administrators. All entries are tracked by audit trail and timestamps.","prisma_schemas":"model community_platform_categories {\n  id String @id @db.Uuid\n  code String\n  name String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  community_platform_communities community_platform_communities[]\n  @@unique([code])\n  @@unique([name])\n  @@index([created_at])\n}","authorizationRoles":["admin"],"description":"Allows admin users to create a new category for classifying sub-communities on the platform. Requires a unique code and name, a human-friendly display name, and optionally a longer description. If a provided code or name is already in use, the system rejects the request and returns a conflict error. All categories are tracked for audits by creation and update timestamps.\n\nAdmin privilege is required, as category creation shapes the system taxonomy. All required inputs must pass validation for length, uniqueness, and allowed characters. Related APIs include listing, detail, update, and deletion endpoints for category management.","summary":"Create a new community category for sub-community classification","parameters":[],"requestBody":{"description":"Information required to create a new category (code, name, description)","typeName":"ICommunityPlatformCategory.ICreate"},"responseBody":{"description":"Category entity as created, with all identifying and descriptive fields populated","typeName":"ICommunityPlatformCategory"},"name":"create","path":"/communityPlatform/admin/categories","method":"post","model_name":"community_platform_categories","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Updates an existing community platform category entity specified by categoryId (UUID). Admin users can modify the name, description, and display fields as appropriate, except for immutable code/invariants. The system ensures uniqueness for all modified fields and tracks every update with audit timestamps. Changes affect search, display, and business logic throughout the platform. Based on 'community_platform_categories' schema.","prisma_schemas":"model community_platform_categories {\n  id String @id @db.Uuid\n  code String\n  name String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  community_platform_communities community_platform_communities[]\n  @@unique([code])\n  @@unique([name])\n  @@index([created_at])\n}","authorizationRoles":["admin"],"description":"Allows updating of an existing category's display name, description, and other mutable fields. The operation enforces that code and name remain unique across the system. Administration rights are required for this change.\n\nIf attempting to modify an immutable field (such as code), the system rejects the request. All successful updates refresh the updated_at timestamp for audit and tracking. Errors are returned for not-found, duplicate, or forbidden changes. Only used in privileged category management UIs and flows. Related endpoints are get, list, and delete operations for categories.","summary":"Update an existing community category's display fields by UUID identifier","parameters":[{"name":"categoryId","description":"The UUID of the category to update","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updated display name, description, and edit fields for the category","typeName":"ICommunityPlatformCategory.IUpdate"},"responseBody":{"description":"Category entity after updates, showing all current values","typeName":"ICommunityPlatformCategory"},"name":"update","path":"/communityPlatform/admin/categories/{categoryId}","method":"put","model_name":"community_platform_categories","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Deletes (soft-deletes) a community platform category identified by categoryId (UUID). This marks the category as deleted_at (timestamp), excluding it from future lists and assignments but retaining audit history. Only admin users may perform this operation. The business logic using this table must exclude soft-deleted rows unless recovery is implemented. This action is non-recoverable from the API, but system-privileged admins may recover via direct DB if required. Tracks 'deleted_at' to support compliance and business reporting.","prisma_schemas":"model community_platform_categories {\n  id String @id @db.Uuid\n  code String\n  name String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  community_platform_communities community_platform_communities[]\n  @@unique([code])\n  @@unique([name])\n  @@index([created_at])\n}","authorizationRoles":["admin"],"description":"Performs a soft delete of the specified community category by marking its deleted_at timestamp in the database. The category will be omitted from normal functional queries, creation flows, or display UIs.\n\nOnly administrators have the authority to retire categories, and all delete events are logged for audits. This API does not fully erase records but supports future recovery by privileged system operators if necessary. Related endpoints include the category listing, retrieval, creation, and update APIs.","summary":"Soft delete a community category by setting deleted_at; removes from functional lists","parameters":[{"name":"categoryId","description":"The UUID of the category to soft-delete","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","path":"/communityPlatform/admin/categories/{categoryId}","method":"delete","model_name":"community_platform_categories","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieves a paginated, filterable list of all banned words managed by the platform. This supports searching by phrase, category, enabled/disabled state, with full pagination and sort support for efficient administration. Banned words are used for moderation across posts, comments, community names, etc., and are critical for automated and manual content vetting. Based on the 'community_platform_banned_words' schema.","prisma_schemas":"model community_platform_banned_words {\n  id String @id @db.Uuid\n  phrase String\n  category String?\n  enabled Boolean\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([phrase])\n  @@index([enabled])\n  @@index([category])\n}","authorizationRoles":["admin"],"description":"Enables admin users to browse and audit the complete set of banned words or phrases in the content moderation system. Filtering options include search by phrase text, filtering by category (profanity, spam, etc.), and filtering by whether the phrase is currently enabled or disabled for enforcement.\n\nPaged results are returned with metadata, phrase text, category, status (enabled), and audit timestamps. Administrative access is mandatory, as changing the banned words list directly impacts user-generated content moderation. Soft-deleted entries are omitted by default. Related APIs exist for creating, updating, and deleting banned word entries.","summary":"Search and retrieve a paginated, filterable list of all banned words","parameters":[],"requestBody":{"description":"Filter/search, pagination, and sort options for banned words","typeName":"ICommunityPlatformBannedWord.IRequest"},"responseBody":{"description":"Paginated, filterable list of banned word summary entities, including phrase, category, and audit info","typeName":"IPageICommunityPlatformBannedWord.ISummary"},"name":"index","path":"/communityPlatform/admin/bannedWords","method":"patch","model_name":"community_platform_banned_words","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieves detailed information about a single banned word entry by bannedWordId (UUID). This includes the phrase, category, status, and audit fields. Soft-deleted or disabled words are not shown in normal moderation flows. Used for moderation UI and detailed audit/inspection. Based on 'community_platform_banned_words' schema.","prisma_schemas":"model community_platform_banned_words {\n  id String @id @db.Uuid\n  phrase String\n  category String?\n  enabled Boolean\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([phrase])\n  @@index([enabled])\n  @@index([category])\n}","authorizationRoles":["admin"],"description":"Returns full details for an individual banned word, including phrase, moderation category, enabled/disabled flag, and all audit timestamps. Soft deleted records are found only using privileged or audit/recovery-specific requests, and enabled==false entries may be omitted from normal enforcement.\n\nUsually used in admin-facing review or update UIs. Related endpoints include update, create, list, and delete for banned word management.","summary":"Get details for a specific banned word moderation entry by UUID","parameters":[{"name":"bannedWordId","description":"The UUID of the banned word entry to retrieve","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full information for a single banned word entity","typeName":"ICommunityPlatformBannedWord"},"name":"at","path":"/communityPlatform/admin/bannedWords/{bannedWordId}","method":"get","model_name":"community_platform_banned_words","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Adds a new banned word or phrase to the moderation system. Enforces uniqueness of the phrase across the list, supports assignment to a moderation category (spam, profanity, etc.), and controls enabled/disabled state. Changes immediately impact content validation and filtering throughout user-generated content. For use by admins only. All rows are time-stamped and auditable. Based on 'community_platform_banned_words' schema.","prisma_schemas":"model community_platform_banned_words {\n  id String @id @db.Uuid\n  phrase String\n  category String?\n  enabled Boolean\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([phrase])\n  @@index([enabled])\n  @@index([category])\n}","authorizationRoles":["admin"],"description":"Allows privileged admin users to insert a new banned word or phrase for enforcement throughout the platform. Each banned word must have a unique phrase and may be assigned a moderation category for reporting. Words can be enabled or disabled for moderation, providing temporary control over enforcement without database deletion.\n\nApplications include content moderation automation, report management, and rapid ban/unban workflow. All entries are tracked for audit and enforcement. Operation fails with a conflict if the phrase already exists in the system. Closely related endpoints include listing, detail, update (enable/disable), and delete for banned words.","summary":"Create a new banned word or phrase for platform content moderation","parameters":[],"requestBody":{"description":"Data required to create a new banned word (phrase, category, enabled state)","typeName":"ICommunityPlatformBannedWord.ICreate"},"responseBody":{"description":"Banned word entry as created, with phrase, category, status, and timestamps","typeName":"ICommunityPlatformBannedWord"},"name":"create","path":"/communityPlatform/admin/bannedWords","method":"post","model_name":"community_platform_banned_words","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation updates an existing banned word or phrase used for content moderation. It targets the community_platform_banned_words Prisma table, which stores prohibited words and phrases. The endpoint allows an admin to modify attributes such as the phrase, its category, and its enabled status. This is essential for refining the moderation engine, allowing adjustments for changing content policies, severity labeling, or temporary activation/inactivation without physical deletion. The operation ensures that only authorized admins can perform this update and guarantees that phrase uniqueness and application-wide enforcement are maintained per business moderation requirements. Modification actions are audit logged as required by business compliance and moderation workflows.","path":"/communityPlatform/admin/bannedWords/{bannedWordId}","method":"put","prisma_schemas":"model community_platform_banned_words {\n  id String @id @db.Uuid\n  phrase String\n  category String?\n  enabled Boolean\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([phrase])\n  @@index([enabled])\n  @@index([category])\n}","description":"Update the details of an existing banned word or phrase as part of the system's content moderation dictionary. This operation supports modifying the phrase, toggling its enabled state, or updating its category. Strict validation ensures phrase uniqueness and correct category association. Only admin users can execute this operation, and all changes are audit logged for moderation traceability. Modifications may take immediate effect, impacting real-time content submissions and moderation sweeps. If the phrase is updated, the new phrase is checked for duplicates before applying changes. Related moderation features reference this data live. All activities are recorded in the audit logs for review.","summary":"Update a banned word or phrase for moderation purposes (community_platform_banned_words table)","parameters":[{"name":"bannedWordId","description":"Unique identifier of the banned word or phrase to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Payload for updating the banned word or phrase, including new phrase value, category, and enabled state.","typeName":"ICommunityPlatformBannedWord.IUpdate"},"responseBody":{"description":"The updated banned word or phrase, with all current details.","typeName":"ICommunityPlatformBannedWord"},"authorizationRoles":["admin"],"name":"update","model_name":"community_platform_banned_words","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation permanently removes a banned word or phrase from the system's content moderation dictionary. It acts on the community_platform_banned_words table, supporting soft deletion by setting the 'deleted_at' timestamp. This ensures that the word or phrase is no longer considered during automatic moderation, but retains an audit trail for compliance, reversibility, and historical reporting. Only admin users can perform this operation. The action is fully audited, and deleted phrases are excluded from future enforcement until restored or recreated. This operation does NOT physically erase the row, satisfying the requirement for reversibility and moderation history.","path":"/communityPlatform/admin/bannedWords/{bannedWordId}","method":"delete","prisma_schemas":"model community_platform_banned_words {\n  id String @id @db.Uuid\n  phrase String\n  category String?\n  enabled Boolean\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([phrase])\n  @@index([enabled])\n  @@index([category])\n}","description":"Remove a banned word or phrase from the active moderation dictionary by performing a soft delete (setting 'deleted_at'). This disables enforcement, but preserves the item for auditing. Only admins may execute the removal. The system ensures safe exclusion from moderation workflows and search validation. Deleted records are retained for history and potential restoration. The action is recorded in audit logs for compliance and investigative transparency.","summary":"Soft delete a banned word or phrase from moderation list (community_platform_banned_words table)","parameters":[{"name":"bannedWordId","description":"Unique identifier of the banned word or phrase to remove.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin"],"name":"erase","model_name":"community_platform_banned_words","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation provides advanced search and filter functionality across all system-level configuration parameters. It accesses the community_platform_configurations table to return a paginated list of configuration objects, supporting query, sorting, and paging for administrative and auditing purposes. The endpoint is available only to admin users, enabling centralized review and management of active and historical configuration settings. Common use cases include reviewing configuration states, monitoring system settings, and supporting compliance audits. Supports pagination and filtering by key, creation or deletion status, and allows discovery of both active and soft-deleted configurations for audit trail integrity.","path":"/communityPlatform/admin/configurations","method":"patch","prisma_schemas":"model community_platform_configurations {\n  id String @id @db.Uuid\n  key String\n  value String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([key])\n  @@index([created_at])\n}","description":"Retrieve a filtered, paginated list of system configuration parameters from the platform. This operation supports complex querying and sorting over all configuration settings, enabling administrative review, audit trail inspection, and system-wide settings management. Returned results include both active and soft-deleted settings, depending on query filters. Only admin users are permitted to access this sensitive endpoint to ensure proper configuration governance. Supports search by key, date range, and status. Business logic ensures confidential information is excluded unless authorized.","summary":"Admin search and list of all configuration settings (community_platform_configurations table)","parameters":[],"requestBody":{"description":"Filtering, search, and pagination parameters for configuration settings query.","typeName":"ICommunityPlatformConfiguration.IRequest"},"responseBody":{"description":"Paginated list of configuration settings matching the search criteria.","typeName":"IPageICommunityPlatformConfiguration"},"authorizationRoles":["admin"],"name":"index","model_name":"community_platform_configurations","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation returns the details of a specific configuration parameter from the community_platform_configurations table, based on its unique identifier. Intended for administrative insight into system-wide settings, the endpoint supports review of current active or historical (soft-deleted) values, enabling audits and configuration history tracking. Only admin users have access to this data, as configurations may include sensitive parameters for business operations, moderation, or platform behavior. Ensures robust access control and consistent audit trail of configuration lookups.","path":"/communityPlatform/admin/configurations/{configurationId}","method":"get","prisma_schemas":"model community_platform_configurations {\n  id String @id @db.Uuid\n  key String\n  value String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([key])\n  @@index([created_at])\n}","description":"Retrieve the full details of a single system configuration setting, including its key, value, description, and historical status. This endpoint is restricted to admin users and returns information even if the configuration has been soft-deleted. Intended for audit, compliance, or troubleshooting scenarios. Sensitive or confidential values are only displayed if authorized. Lookup is performed by the unique configuration ID. Access events are audit logged.","summary":"Get a specific system configuration parameter (community_platform_configurations table)","parameters":[{"name":"configurationId","description":"Unique identifier of the system configuration parameter to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"The detailed system configuration parameter that was requested.","typeName":"ICommunityPlatformConfiguration"},"authorizationRoles":["admin"],"name":"at","model_name":"community_platform_configurations","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows an admin user to create a new system configuration parameter. The community_platform_configurations table supports flexible and safe introduction of new keys for business logic switches, UI settings, or moderation threshold adjustments. Creation enforces key uniqueness, and all configuration modifications are fully audit logged as required for compliance. The endpoint enables dynamic system adjustments without code deploys. The created configuration returns its full details as confirmation. Only admin users are authorized for this operation, consistent with platform governance standards.","path":"/communityPlatform/admin/configurations","method":"post","prisma_schemas":"model community_platform_configurations {\n  id String @id @db.Uuid\n  key String\n  value String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([key])\n  @@index([created_at])\n}","description":"Create a new system-wide configuration parameter. The operation requires a unique key, value, optional description, and will record creation and audit information. Business logic enforces uniqueness and proper encoding of configuration state. The result is the detailed configuration object, which is immediately available for management and effective throughout platform logic. Only admins may create configuration parameters. The creation event is recorded for audit/compliance and can be used for system-level behavior toggles, policy adjustments, or operational settings.","summary":"Create a new configuration parameter (community_platform_configurations table)","parameters":[],"requestBody":{"description":"Information required to create a new configuration setting, including key, value, and optional description.","typeName":"ICommunityPlatformConfiguration.ICreate"},"responseBody":{"description":"The complete, newly created configuration object including all assigned fields.","typeName":"ICommunityPlatformConfiguration"},"authorizationRoles":["admin"],"name":"create","model_name":"community_platform_configurations","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation updates an existing system configuration parameter identified by its unique ID in the community_platform_configurations table. It is used for modifying key business logic switches, UI settings, or moderation policies at runtime. The endpoint enforces unique keys and audit trails for all changes, supporting robust operational oversight and compliance. Only admins may update configurations. This operation allows dynamic and safe adjustment of system settings with immediate effect across the platform, serving both scheduled and emergency changes.","path":"/communityPlatform/admin/configurations/{configurationId}","method":"put","prisma_schemas":"model community_platform_configurations {\n  id String @id @db.Uuid\n  key String\n  value String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([key])\n  @@index([created_at])\n}","description":"Update an existing configuration parameter's key, value, or description. Only admin users are allowed to perform updates, and all changes are fully audit logged. The operation ensures configuration key uniqueness and retains historical versions for auditing. Immediately reflects changes throughout the system and enables safe rollout of business, moderation, or UI policy adjustments. Lookup is by configuration ID. Result includes the full, updated configuration object.","summary":"Update a system configuration parameter (community_platform_configurations table)","parameters":[{"name":"configurationId","description":"Unique identifier of the configuration parameter to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Payload of updated configuration properties, including key, value, and optional description.","typeName":"ICommunityPlatformConfiguration.IUpdate"},"responseBody":{"description":"The complete, updated configuration object reflecting new settings.","typeName":"ICommunityPlatformConfiguration"},"authorizationRoles":["admin"],"name":"update","model_name":"community_platform_configurations","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation removes a configuration parameter from active use in the system by performing a soft delete, setting the 'deleted_at' field in the community_platform_configurations table. This action disables the configuration for all business logic while preserving full audit history and reversibility. Only authorized admin users may invoke this operation. The change is audit logged, and soft-deleted configurations are excluded from standard behavior but can be retrieved for historical or compliance purposes. No data is physically deleted, aligning with organization policy.","path":"/communityPlatform/admin/configurations/{configurationId}","method":"delete","prisma_schemas":"model community_platform_configurations {\n  id String @id @db.Uuid\n  key String\n  value String\n  description String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([key])\n  @@index([created_at])\n}","description":"Remove a configuration parameter from the system by issuing a soft delete (update 'deleted_at') operation. The configuration is excluded from future effective system settings, but the record is retained for audit and possible rollback. Only admins may delete configurations. All actions are tracked for compliance and auditability. Soft-deleted configurations are visible for administrative queries but do not affect platform logic.","summary":"Soft delete a system configuration parameter (community_platform_configurations table)","parameters":[{"name":"configurationId","description":"Unique identifier of the configuration parameter to soft delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin"],"name":"erase","model_name":"community_platform_configurations","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows administrators to search and list guest visitor entities for analytics and audit purposes. It targets the community_platform_guests table, which stores activity and session data of unauthenticated users browsing the platform. This is a read-only, audit-driven feature for tracking visitor trends, abuse prevention, and general engagement reporting. End-users do not manage these entities manually – operations are strictly administrative and compliant with privacy policy controls. Pagination and search by guest_identifier or time frame are supported, but personal identification is not exposed in compliance with privacy regulations. Only authorized admins can access this resource, and all accesses are audit logged for compliance.","path":"/communityPlatform/admin/guests","method":"patch","prisma_schemas":"model community_platform_guests {\n  id String @id @db.Uuid\n  guest_identifier String\n  ip_address String?\n  user_agent String?\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([guest_identifier])\n  @@index([created_at])\n}","description":"Retrieve a paginated, filtered list of guest visitor entities from the platform's analytics data store for auditing and business analysis. Returns guest identifiers, session info, activity periods, and is strictly for admin or analytics review. Business rules enforce anonymization and scope reduction to comply with privacy policies. This is a read-only reporting operation, restricted to administrators, and all activity is audited. Accessible filters may include date ranges, identifiers, or user agent for statistical reporting or abuse investigation use cases.","summary":"Admin search and list of all unauthenticated guest user records (community_platform_guests table)","parameters":[],"requestBody":{"description":"Search and pagination parameters for guest visitor entity listing.","typeName":"ICommunityPlatformGuest.IRequest"},"responseBody":{"description":"Paginated list of guest visitor records for analytics and audit.","typeName":"IPageICommunityPlatformGuest"},"authorizationRoles":["admin"],"name":"index","model_name":"community_platform_guests","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieves a filtered and paginated list of the current user's active authenticated sessions. This operation enables users or admins to review their own login sessions across devices for session management and security purposes. It is based on the community_platform_sessions table, which stores each active or expired login session (such as JWT/refresh tokens) for both members and admins. The PATCH method allows for sophisticated searching, filtering (such as by expiry, device, or user), and sorting across sessions. The operation does not permit session manipulation, only secure, paginated retrieval in descending order of most recent activity. This endpoint is essential for the 'log out everywhere' feature and comprehensive session audits.","path":"/communityPlatform/member/sessions","method":"patch","description":"Retrieve a paginated list of the authenticated user's login sessions. This endpoint allows users (members or admins) to view all of their active and historical login sessions, each representing a device/browser where their account is or was logged in. Sessions include primary metadata such as expiration, creation time, device fingerprint, and invalidation status.\n\nSecurity is enforced such that users can only review their own sessions; admins can review their own admin sessions as well (but not those of others unless a dedicated moderation tool is used). To protect user privacy, cross-account and cross-role access is not permitted.\n\nThe response is paginated to efficiently support accounts with many active or historical sessions and supports advanced search and filtering parameters, such as device type, expiration date ranges, or session state. This operation is directly tied to the community_platform_sessions schema, which includes relationships to both members and admin accounts as described in the DB schema comments.\n\nThis API is required for session management UIs (such as log out everywhere), device security reviews, and is referenced in authentication-related documentation and user settings.","summary":"Search and paginate login sessions (current user only) as per the community_platform_sessions table.","parameters":[],"requestBody":{"description":"Criteria for searching and paginating sessions (e.g., date ranges, active/inactive state).","typeName":"ICommunityPlatformSession.IRequest"},"responseBody":{"description":"Paginated results of session objects, showing session status and device details as defined in schema.","typeName":"IPageICommunityPlatformSession"},"authorizationRoles":["member"],"name":"index","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n\n  @@unique([jwt_token])\n  @@unique([refresh_token])\n  @@index([community_platform_member_id])\n  @@index([community_platform_admin_id])\n  @@index([device_fingerprint])\n  @@index([expires_at])\n}\n","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Provides advanced, paginated search for communities. Supports filtering by category, owner, name/display_title, or general text search (trigram). Operates on the community_platform_communities table, which represents top-level discussion groups on the platform. Returns summary data for each community, including name, display title, description, logo/banner URIs, member and activity status, and category info. Useful for discovery, search UI, and explore screens. Integrates with joined/recent communities and supports sorting. Hidden communities (soft-deleted) are excluded unless explicitly requested. Public endpoint for listings; admins have additional metadata visibility.","path":"/communityPlatform/communities","method":"patch","prisma_schemas":"model community_platform_communities {\n  id String @id @db.Uuid\n  category_id String @db.Uuid\n  owner_id String @db.Uuid\n  name String\n  display_title String?\n  description String?\n  logo_uri String? @db.VarChar(80000)\n  banner_uri String? @db.VarChar(80000)\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  category community_platform_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  owner community_platform_members @relation(fields: [owner_id], references: [id], onDelete: Cascade)\n  community_platform_community_memberships community_platform_community_memberships[]\n  community_platform_recent_communities community_platform_recent_communities[]\n  community_platform_community_rules community_platform_community_rules[]\n  community_platform_posts community_platform_posts[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([name])\n  @@index([category_id])\n  @@index([owner_id])\n  @@index([display_title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([description(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Search and return a paginated list of communities with advanced filtering and sorting. Includes options to filter by category, owner, partial name match, or display title. Results provide summary information for each community along with basic category data and status. Pagination and sort by activity or creation time are supported. Does not return communities flagged as deleted (unless admin override for auditing). Available to all users for discovery, but response includes additional admin details when accessed by administrators. This endpoint is optimized for search/explore and top-level listings.","summary":"Paginated search and discovery for communities with filtering and sort options","parameters":[],"requestBody":{"description":"Search and filter options for community listings. Includes pagination, sorting, search string, and category/owner filters.","typeName":"ICommunityPlatformCommunity.IRequest"},"responseBody":{"description":"Paginated list of community summaries matching search parameters for use in listings/search/explore screens.","typeName":"IPageICommunityPlatformCommunity.ISummary"},"authorizationRoles":[],"name":"index","model_name":"community_platform_communities","soft_delete_column":"deleted_at","authorizationRole":null,"authorizationType":null},{"specification":"Retrieve full details about a specific community by its ID. Exposes all top-level community fields from the community_platform_communities table, including name, display title, description, logo/banner URIs, rule list, category references, and owner/created_by. Used by community view screens, editing interfaces, and membership-related flows. This endpoint allows all public users to read community info. Is sensitive to soft-deleted state: deleted communities are not returned by default except in admin auditing scenarios. Integrates major relationships for rules and category metadata in response body.","path":"/communityPlatform/communities/{communityId}","method":"get","prisma_schemas":"model community_platform_communities {\n  id String @id @db.Uuid\n  category_id String @db.Uuid\n  owner_id String @db.Uuid\n  name String\n  display_title String?\n  description String?\n  logo_uri String? @db.VarChar(80000)\n  banner_uri String? @db.VarChar(80000)\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  category community_platform_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  owner community_platform_members @relation(fields: [owner_id], references: [id], onDelete: Cascade)\n  community_platform_community_memberships community_platform_community_memberships[]\n  community_platform_recent_communities community_platform_recent_communities[]\n  community_platform_community_rules community_platform_community_rules[]\n  community_platform_posts community_platform_posts[]\n  community_platform_search_views community_platform_search_views[]\n}","description":"Get details about a specific community, including all fields, rule lines, category and owner metadata, and related status. All fields defined in the community_platform_communities schema are included, with linked rules/categorization and display information. Public API for community browsing and view pages. Does not return data for soft-deleted communities to prevent invalid or misleading content being shown; admins may have an override to read deleted state for audits. No private or sensitive data returned to member or public roles.","summary":"Retrieve complete community information and relationships by community ID","parameters":[{"name":"communityId","description":"The community record ID to look up.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Comprehensive community entity, including related category and rules data.","typeName":"ICommunityPlatformCommunity"},"authorizationRoles":[],"name":"at","model_name":"community_platform_communities","soft_delete_column":"deleted_at","authorizationRole":null,"authorizationType":null},{"specification":"Create a new community as an authenticated member. Adds an entry to the community_platform_communities table, requiring a unique, non-editable name, category assignment, and references to the creator/owner (currently-authenticated member). Optionally sets title, description, logo/banner URIs, and community rules (up to 10). Input validation strictly enforces the name format (unique, alphanumeric, hyphen/underscore, 3–32 chars), category membership, and non-empty values for required fields. The result returns the full new community entity including all provided fields and defaults. Permissions: only authenticated members can create new communities; admins may create on behalf of another member for special workflows.","path":"/communityPlatform/member/communities","method":"post","prisma_schemas":"model community_platform_communities {\n  id String @id @db.Uuid\n  category_id String @db.Uuid\n  owner_id String @db.Uuid\n  name String\n  display_title String?\n  description String?\n  logo_uri String? @db.VarChar(80000)\n  banner_uri String? @db.VarChar(80000)\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  category community_platform_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  owner community_platform_members @relation(fields: [owner_id], references: [id], onDelete: Cascade)\n  community_platform_community_memberships community_platform_community_memberships[]\n  community_platform_recent_communities community_platform_recent_communities[]\n  community_platform_community_rules community_platform_community_rules[]\n  community_platform_posts community_platform_posts[]\n  community_platform_search_views community_platform_search_views[]\n}","description":"Create a new community with all required and optional metadata: unique name, category, owner (current member), description, and optional logo/banner/rules. Validates strong input constraints for name and required relationships. Only authenticated members or admins may perform this operation, based on business rules. Responds with complete community entity, including related defaults and any generated system fields. Does not allow unauthenticated guests or nonmember operations. Rejects creation if name, category, or other fields do not meet strict validation or business rules. Triggers creation of related rule and membership entries where required.","summary":"Create a new community as an authenticated member or admin","parameters":[],"requestBody":{"description":"Information to create a new community, including required and optional fields for metadata, categorization, and visual configuration.","typeName":"ICommunityPlatformCommunity.ICreate"},"responseBody":{"description":"Full new community record with defaults and linked relationships as created.","typeName":"ICommunityPlatformCommunity"},"authorizationRoles":["member","admin"],"name":"create","model_name":"community_platform_communities","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"This endpoint retrieves details for a specific guest by unique ID. It operates on the community_platform_guests table in the Identity Prisma schema, which stores pseudonymous analytics and audit data for anonymous users. The main use case is for analytics or monitoring guest activity (not for business user flows). It requires a guest ID and returns infrequent analytics data for a guest entity, including guest_identifier, user_agent, IP, and timestamps.","path":"/communityPlatform/admin/guests/{guestId}","method":"get","prisma_schemas":"model community_platform_guests {\n  id String @id @db.Uuid\n  guest_identifier String\n  ip_address String?\n  user_agent String?\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  @@unique([guest_identifier])\n  @@index([created_at])\n}","description":"Retrieve detailed information for a specific guest record identified by guestId. This entity is used internally for analytics, tracking user interactions, and auditing non-authenticated activity. It is not meant for direct business user-facing queries. Returns analytics data including IP, user agent, identifier, and timestamps, if available. Only system or admin-level users should access this data; business API flows do not expose this entity to members or guests.","summary":"Retrieve an analytics guest record by ID (system use only)","parameters":[{"name":"guestId","description":"Unique identifier for the guest record to look up.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed guest analytics information, including audit and tracking fields.","typeName":"ICommunityPlatformGuest"},"authorizationRoles":["admin"],"name":"at","model_name":"community_platform_guests","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This endpoint provides advanced search, filtering, and pagination for active session tokens in the system. It exposes the community_platform_sessions table, capturing JWT access/refresh tokens for both members and admins, associated device fingerprints, expiration times, invalidation information, and relevant member/admin references. Sessions are generally managed via application logic, but this endpoint allows admins to audit, review, and manage session lifecycles across the system. It enables security monitoring, force logout, and session investigation.","path":"/communityPlatform/admin/sessions","method":"patch","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n  @@unique([jwt_token])\n  @@unique([refresh_token])\n  @@index([community_platform_member_id])\n  @@index([community_platform_admin_id])\n  @@index([device_fingerprint])\n  @@index([expires_at])\n}","description":"Search and retrieve session token records with support for advanced filtering (by member/admin/user, IP, validity, creation, and expiration times). Allows admins to monitor session lifecycles, security issues, check for active/expired/inactive sessions, and gather insight about user or system-level session access. Requires admin privileges for sensitive data visibility. Returns a paginated list of session records matching search/filtering criteria, including references to owner/member/admin and device information. This operation does not expose session token values in any standard business user or member flow, and responses are executed solely for admin and system oversight.","summary":"Admin search and listing for session tokens (audit and management use)","parameters":[],"requestBody":{"description":"Advanced search and pagination parameters for session tokens. Supports filters like member/admin reference, expiration, invalidation, device, and time.","typeName":"ICommunityPlatformSession.IRequest"},"responseBody":{"description":"A paginated collection of session token records matching the search parameters.","typeName":"IPageICommunityPlatformSession"},"authorizationRoles":["admin"],"name":"index","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieves details about a specific user or admin session by ID. This operation allows an admin (or the user who owns the session) to look up the device/session information, expiration time, associated member/admin reference, and embedded metadata for a JWT session from the community_platform_sessions table. Useful for reviewing active sessions for security, auditing session state, and providing support for session revocation features. This endpoint enforces appropriate authorization controls: admins can review any session; members can view their own sessions only.","path":"/communityPlatform/admin/sessions/{sessionId}","method":"get","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n}","description":"Retrieve detailed session information for a given sessionId. Includes metadata about the session, associated member or admin, device and browser information, and timestamps. Enables security audits by administrators and allows members to see their own active sessions as part of 'manage account' or 'log out everywhere' features. Ensures that only authorized parties can access session details—members can only see their own, admins see all. Does not expose sensitive token values in response. Records that have been soft-deleted (deleted_at set) are excluded by default unless explicitly requested during auditing.","summary":"Get session metadata and info for a specific session by ID","parameters":[{"name":"sessionId","description":"The unique identifier of the session record to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full details about the requested session. Sensitive fields are redacted.","typeName":"ICommunityPlatformSession"},"authorizationRoles":["admin","member"],"name":"at","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieves details about a specific user or admin session by ID. This operation allows an admin (or the user who owns the session) to look up the device/session information, expiration time, associated member/admin reference, and embedded metadata for a JWT session from the community_platform_sessions table. Useful for reviewing active sessions for security, auditing session state, and providing support for session revocation features. This endpoint enforces appropriate authorization controls: admins can review any session; members can view their own sessions only.","path":"/communityPlatform/member/sessions/{sessionId}","method":"get","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n}","description":"Retrieve detailed session information for a given sessionId. Includes metadata about the session, associated member or admin, device and browser information, and timestamps. Enables security audits by administrators and allows members to see their own active sessions as part of 'manage account' or 'log out everywhere' features. Ensures that only authorized parties can access session details—members can only see their own, admins see all. Does not expose sensitive token values in response. Records that have been soft-deleted (deleted_at set) are excluded by default unless explicitly requested during auditing.","summary":"Get session metadata and info for a specific session by ID","parameters":[{"name":"sessionId","description":"The unique identifier of the session record to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full details about the requested session. Sensitive fields are redacted.","typeName":"ICommunityPlatformSession"},"authorizationRoles":["admin","member"],"name":"at","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Update or refresh an existing session record by ID. Permits admins or session owners to update device fingerprint, expiration, or perform session extension operations (permitted fields only). Used to support device session annotation, adjust expiration for valid security upgrade/extension tokens, or mark a session as recently used/updated by a user. Responses confirm the new state of the session, enforcing full validation of session integrity. Authorization required: only session owner (member/admin) or admin can update. Session tokens themselves cannot be mutated here (no credential/security upgrade via this endpoint).","path":"/communityPlatform/admin/sessions/{sessionId}","method":"put","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n}","description":"Update allowed fields on a session by its ID—such as device fingerprint, last-used time, or planned expiration time. Only accessible to the session's owner (member/admin) or an administrator. Used in account management or device session management screens. Mutations are strictly limited to session metadata (device, times); tokens are never returned or modifiable via this method. The endpoint validates session existence, integrity, and ownership prior to updating. The response returns the updated session entity. Supports hard or soft expiration extension, but not token regeneration. If session has been soft-deleted, update is rejected.","summary":"Update device/session metadata and timestamps for a specific session ID","parameters":[{"name":"sessionId","description":"The session record ID to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Fields to update on the session (device info, expiration, timestamps, not token values).","typeName":"ICommunityPlatformSession.IUpdate"},"responseBody":{"description":"The updated session entity, redacting any sensitive token fields.","typeName":"ICommunityPlatformSession"},"authorizationRoles":["admin","member"],"name":"update","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Update or refresh an existing session record by ID. Permits admins or session owners to update device fingerprint, expiration, or perform session extension operations (permitted fields only). Used to support device session annotation, adjust expiration for valid security upgrade/extension tokens, or mark a session as recently used/updated by a user. Responses confirm the new state of the session, enforcing full validation of session integrity. Authorization required: only session owner (member/admin) or admin can update. Session tokens themselves cannot be mutated here (no credential/security upgrade via this endpoint).","path":"/communityPlatform/member/sessions/{sessionId}","method":"put","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n}","description":"Update allowed fields on a session by its ID—such as device fingerprint, last-used time, or planned expiration time. Only accessible to the session's owner (member/admin) or an administrator. Used in account management or device session management screens. Mutations are strictly limited to session metadata (device, times); tokens are never returned or modifiable via this method. The endpoint validates session existence, integrity, and ownership prior to updating. The response returns the updated session entity. Supports hard or soft expiration extension, but not token regeneration. If session has been soft-deleted, update is rejected.","summary":"Update device/session metadata and timestamps for a specific session ID","parameters":[{"name":"sessionId","description":"The session record ID to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Fields to update on the session (device info, expiration, timestamps, not token values).","typeName":"ICommunityPlatformSession.IUpdate"},"responseBody":{"description":"The updated session entity, redacting any sensitive token fields.","typeName":"ICommunityPlatformSession"},"authorizationRoles":["admin","member"],"name":"update","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Delete (invalidate) a specific session record by ID. This operation is a soft delete and is used for either administrative session revocation (security/privacy escalation, forced logout everywhere) or for members/admins wishing to remove their own active session (e.g., logging out of a device/browser). The community_platform_sessions table supports soft deletion with deleted_at timestamp. Session tokens are rendered invalid immediately for further activity. Only the session owner or an admin can perform this operation. Cascades clean-up without removing record for audit trail purposes.","path":"/communityPlatform/admin/sessions/{sessionId}","method":"delete","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n}","description":"Soft delete (invalidate) a session, marking its deleted_at timestamp. Invalidates the JWT and refresh token for immediate effect. Serves as system/admin-initiated forced logout for user or admin, or user self-logout for a session. Only session owner or admin can perform this deletion. The record remains for audit/logging but cannot be reactivated. Fails if already deleted. This endpoint fulfills logout everywhere/log out current device scenarios in account management flows.","summary":"Soft delete (invalidate) a session by ID; immediate logout effect","parameters":[{"name":"sessionId","description":"Unique ID for the session to invalidate/delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin","member"],"name":"erase","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Delete (invalidate) a specific session record by ID. This operation is a soft delete and is used for either administrative session revocation (security/privacy escalation, forced logout everywhere) or for members/admins wishing to remove their own active session (e.g., logging out of a device/browser). The community_platform_sessions table supports soft deletion with deleted_at timestamp. Session tokens are rendered invalid immediately for further activity. Only the session owner or an admin can perform this operation. Cascades clean-up without removing record for audit trail purposes.","path":"/communityPlatform/member/sessions/{sessionId}","method":"delete","prisma_schemas":"model community_platform_sessions {\n  id String @id @db.Uuid\n  community_platform_member_id String? @db.Uuid\n  community_platform_admin_id String? @db.Uuid\n  jwt_token String\n  refresh_token String\n  device_fingerprint String?\n  expires_at DateTime @db.Timestamptz\n  invalidated_at DateTime? @db.Timestamptz\n  created_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [community_platform_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [community_platform_admin_id], references: [id], onDelete: Cascade)\n}","description":"Soft delete (invalidate) a session, marking its deleted_at timestamp. Invalidates the JWT and refresh token for immediate effect. Serves as system/admin-initiated forced logout for user or admin, or user self-logout for a session. Only session owner or admin can perform this deletion. The record remains for audit/logging but cannot be reactivated. Fails if already deleted. This endpoint fulfills logout everywhere/log out current device scenarios in account management flows.","summary":"Soft delete (invalidate) a session by ID; immediate logout effect","parameters":[{"name":"sessionId","description":"Unique ID for the session to invalidate/delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin","member"],"name":"erase","model_name":"community_platform_sessions","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Create a new community as an authenticated member. Adds an entry to the community_platform_communities table, requiring a unique, non-editable name, category assignment, and references to the creator/owner (currently-authenticated member). Optionally sets title, description, logo/banner URIs, and community rules (up to 10). Input validation strictly enforces the name format (unique, alphanumeric, hyphen/underscore, 3–32 chars), category membership, and non-empty values for required fields. The result returns the full new community entity including all provided fields and defaults. Permissions: only authenticated members can create new communities; admins may create on behalf of another member for special workflows.","path":"/communityPlatform/admin/communities","method":"post","prisma_schemas":"model community_platform_communities {\n  id String @id @db.Uuid\n  category_id String @db.Uuid\n  owner_id String @db.Uuid\n  name String\n  display_title String?\n  description String?\n  logo_uri String? @db.VarChar(80000)\n  banner_uri String? @db.VarChar(80000)\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  category community_platform_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  owner community_platform_members @relation(fields: [owner_id], references: [id], onDelete: Cascade)\n  community_platform_community_memberships community_platform_community_memberships[]\n  community_platform_recent_communities community_platform_recent_communities[]\n  community_platform_community_rules community_platform_community_rules[]\n  community_platform_posts community_platform_posts[]\n  community_platform_search_views community_platform_search_views[]\n}","description":"Create a new community with all required and optional metadata: unique name, category, owner (current member), description, and optional logo/banner/rules. Validates strong input constraints for name and required relationships. Only authenticated members or admins may perform this operation, based on business rules. Responds with complete community entity, including related defaults and any generated system fields. Does not allow unauthenticated guests or nonmember operations. Rejects creation if name, category, or other fields do not meet strict validation or business rules. Triggers creation of related rule and membership entries where required.","summary":"Create a new community as an authenticated member or admin","parameters":[],"requestBody":{"description":"Information to create a new community, including required and optional fields for metadata, categorization, and visual configuration.","typeName":"ICommunityPlatformCommunity.ICreate"},"responseBody":{"description":"Full new community record with defaults and linked relationships as created.","typeName":"ICommunityPlatformCommunity"},"authorizationRoles":["member","admin"],"name":"create","model_name":"community_platform_communities","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows authorized users (community owners or admins) to update the editable fields of an existing sub-community. It operates on the community_platform_communities table, representing named discussion groups. Editable fields include display_title, description, logo_uri, banner_uri, and category_id. The community name is immutable and not changeable via this endpoint. The operation enforces business rules for editability, reference integrity (valid category and owner), and proper authorization, as only the community creator or an admin may update community metadata. Related entities such as community rules must be edited separately. The endpoint requires the communityId as a path parameter and expects a request body conforming to update DTO standards.","path":"/communityPlatform/member/communities/{communityId}","method":"put","prisma_schemas":"model community_platform_communities {\n  id String @id @db.Uuid\n  category_id String @db.Uuid\n  owner_id String @db.Uuid\n  name String\n  display_title String?\n  description String?\n  logo_uri String? @db.VarChar(80000)\n  banner_uri String? @db.VarChar(80000)\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  category community_platform_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  owner community_platform_members @relation(fields: [owner_id], references: [id], onDelete: Cascade)\n  community_platform_community_memberships community_platform_community_memberships[]\n  community_platform_recent_communities community_platform_recent_communities[]\n  community_platform_community_rules community_platform_community_rules[]\n  community_platform_posts community_platform_posts[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([name])\n  @@index([category_id])\n  @@index([owner_id])\n  @@index([display_title(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n  @@index([description(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member"],"description":"Update the metadata of a sub-community (such as description, logo/banner, display title, or category) using this endpoint. Only the community creator or administrators are permitted to modify this information. The operation validates the provided category ID against the allowed categories table and ensures the new metadata follows business rules, such as not exceeding character limits for titles and descriptions, and only referencing valid image URIs. If a user attempts to change an immutable property such as the community name or violates ownership/authorization, an appropriate error is returned. This operation is critical for enabling users to manage their sub-communities as the platform grows while maintaining strict enforcement of naming and category constraints.\n\nCommunity rules (multi-line guidelines) are managed via a separate endpoint and cannot be updated through this operation. The endpoint ensures all changes are properly audited and that UI feeds reflect updated data upon success. Cascade effects (e.g., changing category may update how the community is listed) are handled as per business logic. Errors are surfaced for all violations, and audit logging is triggered for successful updates.","summary":"Update the metadata and settings of an existing sub-community by communityId.","parameters":[{"name":"communityId","description":"Unique ID of the target community to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Editable fields for a sub-community update (title, description, logo/banner URIs, category).","typeName":"ICommunityPlatformCommunity.IUpdate"},"responseBody":{"description":"The updated community with all current metadata.","typeName":"ICommunityPlatformCommunity"},"name":"update","model_name":"community_platform_communities","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"This operation soft deletes a specific sub-community by setting its deleted_at timestamp in the community_platform_communities table. This soft deletion process preserves the record for audit purposes, preventing permanent loss and allowing potential restoration if required by business policy. All associated posts, comments, memberships, and related entities are handled according to cascade soft-delete logic. Only the community owner (creator) or administrators may perform this operation. The endpoint enforces referential integrity and ensures all cross-entity relationships are marked as deleted appropriately. The operation is fully audited for both data integrity and administrative monitoring, in accordance with the soft-delete pattern supported by the Prisma schema.","path":"/communityPlatform/member/communities/{communityId}","method":"delete","prisma_schemas":"model community_platform_communities {\n  id String @id @db.Uuid\n  category_id String @db.Uuid\n  owner_id String @db.Uuid\n  name String\n  display_title String?\n  description String?\n  logo_uri String? @db.VarChar(80000)\n  banner_uri String? @db.VarChar(80000)\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  category community_platform_categories @relation(fields: [category_id], references: [id], onDelete: Cascade)\n  owner community_platform_members @relation(fields: [owner_id], references: [id], onDelete: Cascade)\n  community_platform_community_memberships community_platform_community_memberships[]\n  community_platform_recent_communities community_platform_recent_communities[]\n  community_platform_community_rules community_platform_community_rules[]\n  community_platform_posts community_platform_posts[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([name])\n  @@index([category_id])\n  @@index([owner_id])\n}","authorizationRoles":["member"],"description":"Soft delete a sub-community by updating its deleted_at timestamp in the database rather than permanently removing the record. This operation preserves historical data for compliance, moderation, and potential restoration. Only the creator of the community or administrators are permitted to perform the soft delete. Related posts, comments, memberships, and rules are likewise marked as deleted according to cascade policies, ensuring no orphaned entities remain. This action is logged for full audit, and the affected community is excluded from standard queries and listings after soft deletion. Attempts to delete a non-existent community or without proper authorization result in an error message. Restoration operations (if supported) may be implemented separately based on business requirements.","summary":"Soft delete (logical delete) a sub-community by setting deleted_at timestamp.","parameters":[{"name":"communityId","description":"Unique ID of the community to soft delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","model_name":"community_platform_communities","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves a paginated and searchable list of all current active members of a particular community from the community_platform_community_memberships table, joined with member details. It supports filtering by join date, searching member display names, and other potential query fields for advanced UI and moderation panels. Only authenticated users can access this operation. Requires the community ID as a path parameter and expects advanced filter/search/sort/pagination in the request body DTO. The response includes summary membership card details suitable for community membership management and display.","path":"/communityPlatform/member/communities/{communityId}/memberships","method":"patch","prisma_schemas":"model community_platform_community_memberships {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  joined_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  @@unique([member_id, community_id])\n  @@index([community_id])\n  @@index([member_id])\n}","authorizationRoles":["member"],"description":"Retrieve a paginated list of all current members belonging to a specified sub-community. Supports advanced filtering (such as join date range) and searching by member display name. This endpoint is used for both community owner/admin moderation views and ordinary participants viewing a roster or member card list. Returned information typically includes joined date, member basic info, and other summary details as defined in the membership DTO. Requires appropriate authentication, and the results may be permission-filtered for sensitive data fields. The endpoint enables both roster UIs and member management use-cases for large communities.","summary":"List and search current members of a specific community, with pagination and filtering support.","parameters":[{"name":"communityId","description":"The community for which to list current members.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Advanced filter/search/sort and pagination options for membership listing.","typeName":"ICommunityPlatformCommunityMembership.IRequest"},"responseBody":{"description":"Paginated list of membership summaries for display or moderation.","typeName":"IPageICommunityPlatformCommunityMembership.ISummary"},"name":"index","model_name":"community_platform_community_memberships","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves the details of a specific community membership record by its unique ID, belonging to a given community. It is mapped to the community_platform_community_memberships table and joins with member information. Used by moderators for inspecting membership state or by UIs showing deep-dive views for a member's join data. Only authenticated users may access this endpoint. Requires communityId and membershipId as path parameters. Business rules enforce that only members of the community or its owner/admins can access sensitive membership information, and appropriate errors are returned on violation.","path":"/communityPlatform/member/communities/{communityId}/memberships/{membershipId}","method":"get","prisma_schemas":"model community_platform_community_memberships {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  joined_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  @@unique([member_id, community_id])\n  @@index([community_id])\n  @@index([member_id])\n}","authorizationRoles":["member"],"description":"Get details about a single community membership for a given member within a specific sub-community. This operation returns join date, member information, and related metadata. Used by moderation tools, admin dashboards, or detail member profile modals in the community context. Access is protected by authentication and may be permission-filtered based on context or member roles. Returns error if the membership does not exist or if unauthorized.","summary":"Retrieve details on a specific community membership within a given community.","parameters":[{"name":"communityId","description":"The community containing the membership.","schema":{"type":"string","format":"uuid"}},{"name":"membershipId","description":"Unique membership ID to retrieve details for.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Membership record with member detail and join info.","typeName":"ICommunityPlatformCommunityMembership"},"name":"at","model_name":"community_platform_community_memberships","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation allows an authenticated user to join a specific community by creating a new active membership entry in the community_platform_community_memberships table. The endpoint ensures that a user cannot join the same community more than once (unique constraint). On successful join, the user's joined communities and personalized feed are updated across the platform. If a user tries to join an already joined community, an error is returned. The communityId parameter specifies the community to join, and membership metadata is submitted in the request body.","path":"/communityPlatform/member/communities/{communityId}/memberships","method":"post","prisma_schemas":"model community_platform_community_memberships {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  joined_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  @@unique([member_id, community_id])\n  @@index([community_id])\n  @@index([member_id])\n}","authorizationRoles":["member"],"description":"Join a specific sub-community by creating a new membership record for the authenticated user. This action updates the user's community list and feed preferences. The system enforces business rules that a member may only have one membership per community. Attempts to join the same community again will result in a duplicate error. The operation notifies UI feeds and recent community lists of successful membership. Requires correct communityId as path, and the relevant membership creation parameters in the body DTO.","summary":"Join a sub-community (create new membership) as an authenticated user.","parameters":[{"name":"communityId","description":"ID of the community to join.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Membership creation details for joining a community.","typeName":"ICommunityPlatformCommunityMembership.ICreate"},"responseBody":{"description":"The new membership record, including join date and member info.","typeName":"ICommunityPlatformCommunityMembership"},"name":"create","model_name":"community_platform_community_memberships","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation allows the authenticated user or a community administrator to remove a member from a specific community, by deleting the relevant membership record from the community_platform_community_memberships table. It requires the unique membership ID and parent community ID as path parameters. On success, the user's feed and community lists are updated to reflect the removal. Cascade delete removes only the membership record; all other member data remains intact. The API checks for membership existence and proper authorization before deletion, and will respond with an error for invalid membershipId, communityId, or forbidden requests.","path":"/communityPlatform/member/communities/{communityId}/memberships/{membershipId}","method":"delete","prisma_schemas":"model community_platform_community_memberships {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  joined_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  @@unique([member_id, community_id])\n  @@index([community_id])\n  @@index([member_id])\n}","authorizationRoles":["member"],"description":"Remove a member from a specified sub-community by deleting the given membership record. Commonly used when a user chooses to leave a community or when an admin removes a member. Only the member being removed or a community admin/owner may perform this operation. The endpoint guarantees data integrity by ensuring the membership exists and is properly identified. The affected user's memberships and feeds are updated to reflect the removal. All related audit events are logged for compliance and support for community moderation dashboards.","summary":"Remove a single member from a community by deleting the membership record.","parameters":[{"name":"communityId","description":"ID of the parent community.","schema":{"type":"string","format":"uuid"}},{"name":"membershipId","description":"Unique membership record ID (membership to delete).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","model_name":"community_platform_community_memberships","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation returns a paginated, filterable list of the recent communities that a specific member has interacted with in the context of a given community. It leverages the community_platform_recent_communities table, which records each member's latest visits or touches of a community. This operation is used to power UIs such as sidebars displaying a user's recent communities. It requires the communityId as a path parameter and advanced request body for filtering and paging. Only authenticated users may access this endpoint, and the response contains summary information for UI display.","path":"/communityPlatform/member/communities/{communityId}/recentCommunities","method":"patch","prisma_schemas":"model community_platform_recent_communities {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  touched_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  @@unique([member_id, community_id])\n  @@index([touched_at])\n  @@index([member_id])\n  @@index([community_id])\n}","authorizationRoles":["member"],"description":"Retrieve a filterable, paginated list of recent communities interacted with by a member, from within the context of a specific community. Used for powering recent sidebar widgets, quick community switches, or personal navigation features. The endpoint supports filtering and sorting by recency, optionally filtering by member or activity window. Only authentication is required; returns a pagination result containing summary information of the member's recent communities list. Returns only communities that the member has recently visited or engaged with, not a full membership or global search.","summary":"List recent communities touched by a member for sidebar/recent view display.","parameters":[{"name":"communityId","description":"Contextual/community ID for which to list recent communities.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Filter terms, paging, and sorting for recent communities search.","typeName":"ICommunityPlatformRecentCommunity.IRequest"},"responseBody":{"description":"Paginated summary of recent communities for user display.","typeName":"IPageICommunityPlatformRecentCommunity.ISummary"},"name":"index","model_name":"community_platform_recent_communities","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves a single recent community entry for a member within a given context community, as stored in the community_platform_recent_communities table. Used in UIs presenting detail for a recent community interaction (for example, in tooltips or on profile/activity pages). Only authenticated users may use this endpoint. Requires communityId and recentCommunityId as path parameters. Business logic enforces that only the relevant user can access their own recent community entries, or administrators may have access for moderation/audit purposes.","path":"/communityPlatform/member/communities/{communityId}/recentCommunities/{recentCommunityId}","method":"get","prisma_schemas":"model community_platform_recent_communities {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  touched_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  @@unique([member_id, community_id])\n  @@index([touched_at])\n  @@index([member_id])\n  @@index([community_id])\n}","authorizationRoles":["member"],"description":"Get detail on a specific recent community row for a member, for a given community context. The endpoint returns current state and recency information for that recent community entity. Used by user-profile activity displays, audit views, and membership navigation UIs. Only authenticated users may access, and results may be permission-filtered for privacy or moderation needs. If the entry does not exist or permissions are violated, an appropriate error is returned. This endpoint does not allow editing or deletion; used only for state inspection or activity logging.","summary":"Retrieve detailed information on a recent community for context/community/member auditing or display.","parameters":[{"name":"communityId","description":"Current or context community for this recent entry.","schema":{"type":"string","format":"uuid"}},{"name":"recentCommunityId","description":"Unique recent community entity ID to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Recent community card/details with recency and member/community context.","typeName":"ICommunityPlatformRecentCommunity"},"name":"at","model_name":"community_platform_recent_communities","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation adds a community to a member's list of recently visited communities. The endpoint is associated with the community_platform_recent_communities table. When a member interacts with a community (views/posts/comments), the system updates their recent communities list to improve sidebar navigation and personalized home experience. The operation requires the communityId path parameter to identify the target community. On success, a recent community membership is created or updated for the current user, updating the timestamp. Only authenticated members can perform this action. Implements business logic for engagement and personalized navigation, strictly referencing the schema, and does not affect moderation or broader membership.","path":"/communityPlatform/member/communities/{communityId}/recentCommunities","method":"post","prisma_schemas":"model community_platform_recent_communities {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  touched_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  @@unique([member_id, community_id], map: \"community_platform_recent_communities_member_id_commun_bb0c614e\")\n  @@index([touched_at])\n  @@index([member_id])\n  @@index([community_id])\n}\nmodel community_platform_communities {\n  id String @id @db.Uuid\n  name String\n  ...\n}\nmodel community_platform_members {\n  id String @id @db.Uuid\n  email String\n  ...\n}\n","authorizationRoles":["member"],"description":"Adds or updates a community in the member's recent communities list to enhance sidebar navigation and personalized recommendations. This operation references the community_platform_recent_communities schema and operates via the communityId path parameter, identifying the community the user is interacting with. Only authenticated members can add to their own recent communities list, which is automatically refreshed each time the user visits, joins, or interacts meaningfully.\n\nThe operation ensures that only one recent record per (member, community) pair exists at any time, updating the timestamp if present or creating a new entry if absent. This list is used to display up to five of the user's most recently engaged communities. Membership here does not represent full join status, but enables UI features for quick access.\n\nBecause the table is used for quick navigation, only members can perform this action, and results are scoped to the current session/authenticated account. This operation does not affect broader memberships or moderation, and is only for usability improvements.","summary":"Add a community to the authenticated member's recent communities list","parameters":[{"name":"communityId","description":"The UUID of the target community to add to recent communities.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Payload for recording a recent visit to the community. Contains only necessary context for the backend to identify the user and timestamp, which are set server-side.","typeName":"ICommunityPlatformRecentCommunity.ICreate"},"responseBody":{"description":"The newly created or updated recent community record for the member.","typeName":"ICommunityPlatformRecentCommunity"},"name":"addToRecentCommunities","model_name":"community_platform_recent_communities","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation removes a specific community from a member's recent communities list, allowing users to manage which communities appear in their quick-navigate sidebar or UI. It operates on the community_platform_recent_communities table and requires both the communityId and recentCommunityId as path parameters. Authenticated members can use this endpoint to clean up or curate their recent communities. The operation performs a hard delete of the mapping record per the schema.","path":"/communityPlatform/member/communities/{communityId}/recentCommunities/{recentCommunityId}","method":"delete","prisma_schemas":"model community_platform_recent_communities {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  community_id String @db.Uuid\n  touched_at DateTime @db.Timestamptz\n  ...\n}","authorizationRoles":["member"],"description":"Permanently removes the mapping between the member and the community from the recent communities list. This is a hard delete operation as supported by the schema. The operation only affects which communities appear in the user's recent communities sidebar or similar UI components. It does not affect actual community membership or content, and is accessible only to authenticated members. This action cannot be undone.","summary":"Remove a community from a member's list of recent communities","parameters":[{"name":"communityId","description":"The UUID of the community being referenced for the recent record.","schema":{"type":"string","format":"uuid"}},{"name":"recentCommunityId","description":"The UUID of the recent_community mapping record to remove from the member's list.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"eraseRecentCommunity","model_name":"community_platform_recent_communities","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves a paginated list of rules for a specific community, supporting advanced filtering and pagination as needed. It is based on the community_platform_community_rules table, which contains up to 10 rule lines per community for both UI and policy enforcement. Only community owners (members with rights) and admins can access the full list for editing; regular members and guests may view published rules through other endpoints. Pagination and search are supported via request body payload, following standard index/search operation rules.","path":"/communityPlatform/member/communities/{communityId}/rules","method":"patch","prisma_schemas":"model community_platform_community_rules {\n  id String @id @db.Uuid\n  community_id String @db.Uuid\n  rule_index Int @db.Integer\n  rule_line String\n  community community_platform_communities @relation(fields: [community_id], references: [id], onDelete: Cascade)\n  ...\n}\nmodel community_platform_communities {\n  id String @id @db.Uuid\n  ...\n}","authorizationRoles":["member"],"description":"Retrieves a list of all rules associated with a target community for editing or curation purposes. This read operation enables community owners or privileged users to review, sort, and search rules for their community. Utilizes pagination and filtering payload per the standard request schema, and references the Prisma table for validation. The rules list is capped at 10 entries by business policy.\n\nWhile any user may view public rules, only authenticated members with ownership/admin rights can curate, reorder, or edit them with this endpoint. The operation guarantees that each rule is unique by (community, rule_index), enabling efficient UI updates and owner workflows for rule management. Results include rule index, text, and current ordering. Use for both listing and configuring rules as allowed by policy.","summary":"List all rules for a given community (paginated, for curation)","parameters":[{"name":"communityId","description":"The UUID of the community whose rules are being listed.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Filtering and pagination instructions for listing all rules of the given community.","typeName":"ICommunityPlatformCommunityRule.IRequest"},"responseBody":{"description":"Paginated list of rules defined for the specified community, including ordering information.","typeName":"IPageICommunityPlatformCommunityRule"},"name":"indexCommunityRules","model_name":"community_platform_community_rules","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves a specific rule by its unique identifier for a given community. It is based on the community_platform_community_rules table. Community owners, admins, or members may use it to fetch details on a particular rule for viewing or editing purposes. Public access may be provided for reading public rules, but updates are restricted to owners/admins. Returns the rule index and text, which may be displayed or edited in the UI.","path":"/communityPlatform/member/communities/{communityId}/rules/{ruleId}","method":"get","prisma_schemas":"model community_platform_community_rules {\n  id String @id @db.Uuid\n  community_id String @db.Uuid\n  rule_index Int @db.Integer\n  rule_line String\n  ...\n}","authorizationRoles":["member"],"description":"Retrieves a single rule from the specified community for inspection or edit preparation. The rule is identified by ruleId, which is unique per rule row, and is returned with its index and text. This enables direct access for per-rule display, edit UI, and policy review interfaces. Use primarily for rule-editing flows or admin auditing. Any ownership or admin checks are handled at a higher level of business logic as required by the platform.","summary":"Get a specific rule from a community","parameters":[{"name":"communityId","description":"The UUID of the parent community owning the rule.","schema":{"type":"string","format":"uuid"}},{"name":"ruleId","description":"The UUID of the specific rule to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Rule record data for the specified community and ruleId.","typeName":"ICommunityPlatformCommunityRule"},"name":"getCommunityRule","model_name":"community_platform_community_rules","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation creates a new rule for the specified community, allowing the owner or admin to define the rules governing the community's conduct or policy. It is based on the community_platform_community_rules table. Each rule consists of a single line of up to 50 characters, and there may be a maximum of 10 rules per community. Creation is authorized only for community owners or admins. Enforces uniqueness per (community, rule_index).","path":"/communityPlatform/member/communities/{communityId}/rules","method":"post","prisma_schemas":"model community_platform_community_rules {\n  id String @id @db.Uuid\n  community_id String @db.Uuid\n  rule_index Int @db.Integer\n  rule_line String\n  ...\n}","authorizationRoles":["member"],"description":"Creates and appends a new rule for the given community. Allows owners/admins to curate their community's behavior policies. The payload must meet length and uniqueness rules (one per index, max 10 rules of up to 50 chars). Ownership/authorization checks are enforced via business logic, and the result includes the new rule's id, index, and text. Soft/hard limits are handled before creation. Only available to authorized actors—ownership or admin status required.","summary":"Add a new rule to a specified community","parameters":[{"name":"communityId","description":"The UUID of the parent community to which the rule will be added.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Single rule creation input, including rule index and text line (max 50 chars).","typeName":"ICommunityPlatformCommunityRule.ICreate"},"responseBody":{"description":"The created community rule including id, index, and content.","typeName":"ICommunityPlatformCommunityRule"},"name":"createCommunityRule","model_name":"community_platform_community_rules","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation updates an existing rule for a community. It enables the community owner or admin to modify the rule's content or its ordering index. Based on the community_platform_community_rules schema, the endpoint takes both the communityId and the ruleId as path parameters, ensuring accurate identification of the target rule. Only authorized members (community owners) or admins can perform this operation. Rule length and content validation are enforced. Uniqueness of rule_index per community is strictly maintained in business logic.","path":"/communityPlatform/member/communities/{communityId}/rules/{ruleId}","method":"put","prisma_schemas":"model community_platform_community_rules {\n  id String @id @db.Uuid\n  community_id String @db.Uuid\n  rule_index Int @db.Integer\n  rule_line String\n  ...\n}","authorizationRoles":["member"],"description":"Updates the content or ordering of a community rule. Requires the rule to be identified by ruleId within communityId, both provided as path parameters. Only community owners and admins can edit or reorder community rules; all changes must comply with maximum length (50 chars) and rule ordering business constraints. This allows owners to maintain, correct, or clarify their rules as community needs change.","summary":"Edit a specific rule for a given community","parameters":[{"name":"communityId","description":"UUID of the parent community for which the rule is being edited.","schema":{"type":"string","format":"uuid"}},{"name":"ruleId","description":"UUID of the specific community rule to be updated.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Input for editing the rule's index or text, respecting length and uniqueness rules.","typeName":"ICommunityPlatformCommunityRule.IUpdate"},"responseBody":{"description":"The edited rule in its updated state.","typeName":"ICommunityPlatformCommunityRule"},"name":"updateCommunityRule","model_name":"community_platform_community_rules","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation permanently deletes a rule from a community, removing it from the set of visible and enforced rules. It operates on the community_platform_community_rules table and requires both communityId and ruleId path parameters. Only community owners or admins can delete rules. Hard delete logic is imposed as there is no soft-delete mechanism for rules in the schema. Rules are deleted immediately, and uniqueness/indexing updates are handled by higher-level business logic.","path":"/communityPlatform/member/communities/{communityId}/rules/{ruleId}","method":"delete","prisma_schemas":"model community_platform_community_rules {\n  id String @id @db.Uuid\n  community_id String @db.Uuid\n  rule_index Int @db.Integer\n  rule_line String\n  ...\n}","authorizationRoles":["member"],"description":"Deletes a specific rule from the rule set of a given community. This operation is only available to community owners and admins. The hard delete removes the rule by ruleId from the communityId's rule set—resulting in immediate disappearance from UI and moderation overlays. All business constraints on rule count and ordering are enforced by subsequent operations. No content is recoverable after this action. Application logic must update indexes/order as needed.","summary":"Delete a community rule permanently","parameters":[{"name":"communityId","description":"UUID of the parent community whose rule will be deleted.","schema":{"type":"string","format":"uuid"}},{"name":"ruleId","description":"UUID of the rule to delete from the community.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"eraseCommunityRule","model_name":"community_platform_community_rules","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves a filtered and paginated list of all posts across the platform, following the business rules for home feed, community feed, and search scenarios. Using the community_platform_posts table, the patch method allows clients to provide filtering (by community, search text, sort order, pagination) and ensures only public (non-deleted) posts are returned. The business logic enforces authentication for non-guest interaction, but reading is open to public/guests. Complex queries are handled by the request body following established search and feed query schemas. Does not return posts marked deleted in deleted_at field.","path":"/communityPlatform/posts","method":"patch","prisma_schemas":"model community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  ...\n}","authorizationRoles":[],"description":"Retrieves a searchable, filterable, and paginated list of all posts (threads) available on the platform. This operation supports filtering by community, search keyword, sort order (newest/top), and full pagination using standard query interfaces. Posts marked deleted (deleted_at != null) are excluded from query results, ensuring that only active posts are shown to users.\n\nPatch method supports advanced and dynamic query construction for clients and UI components, addressing home, community, or search/recent feeds. This operation is public and does not require authentication to read, but individual post creation/edit/delete APIs do. The result format returns paginated, ordered data suitable for infinite scroll, load more, or feed rendering features.","summary":"List/query/filter posts with pagination (for feed, search, home)","parameters":[],"requestBody":{"description":"Query filters, search keywords, pagination and sorting options for post listing.","typeName":"ICommunityPlatformPost.IRequest"},"responseBody":{"description":"Paginated collection of post result records matching query parameters.","typeName":"IPageICommunityPlatformPost.ISummary"},"name":"index","model_name":"community_platform_posts","soft_delete_column":"deleted_at","authorizationRole":null,"authorizationType":null},{"prisma_schemas":"model community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","model_name":"community_platform_posts","soft_delete_column":"deleted_at","description":"This operation retrieves the full details of a specific post on the community platform, as identified by the provided postId URL parameter. The community_platform_posts table is queried for an entry matching the given postId, and returns all its major fields including the associated community ID, author/member ID, post title, content body, author display name (if any), creation timestamp, last update timestamp, and deleted_at for soft-delete state. If the post exists, it is returned in full; if not, a not-found error is expected. Ownership and author details can be inferred through relations to the member and community entities. Business logic ensures that all posts are accessible for reading (public), but internal fields such as deleted_at or author_display_name are only exposed according to their definition in the schema. This endpoint is meant for consumption by all user roles without authentication (public access). Edge cases are handled gracefully; if the post does not exist or was deleted, a suitable error message is provided. APIs related to editing, deletion or voting on posts require additional endpoints. This endpoint is optimized for read performance and may leverage indexes on postId. Soft-deleted posts (with deleted_at set) should typically not be returned unless specifically intended.","specification":"Retrieve the full detail for a single post resource, given its unique ID. This API operates on the community_platform_posts table, which holds all posts created by authenticated members within communities. The get operation fetches the post fields such as the post's id, community ID, author/member ID, title, body, optional author_display_name, created_at, updated_at, and deleted_at (null if not deleted). Relationships to the community and author are present in the schema and may be used for display purposes in higher-level business logic (joining to community_platform_communities and community_platform_members). The implementation is expected to respect access rules: anyone may view public post information, but the actual returned fields are dictated by the schema. Foreign key relationships allow additional details about author and community if required. This endpoint is a read-only operation with no authorization restriction beyond basic veracity of postId.\n\nFull Prisma schema for the relevant model is included for compliance and validation:\n\nmodel community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  // ...relation fields elided\n}\n","summary":"Retrieve details for a specific post by postId from community_platform_posts.","parameters":[{"name":"postId","description":"The unique identifier (UUID) of the post to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full post entity with all primary fields from community_platform_posts.","typeName":"ICommunityPlatformPost"},"authorizationRoles":[],"name":"at","path":"/communityPlatform/posts/{postId}","method":"get","authorizationRole":null,"authorizationType":null},{"specification":"Create a new post resource in the community_platform_posts table. This POST endpoint allows authenticated members to submit posts to a specific community, requiring input fields such as the community ID, author (member) ID, post title (5-120 chars), body (10-10,000 chars), and an optional author_display_name (max 32 chars). The API validates all input against business rules and schema constraints described in the Prisma model. Upon successful creation, the post is associated with its community and author. Soft-deleted fields are not set on creation. Created_at/updated_at timestamps are managed according to the schema requirements. Related entities include community_platform_communities and community_platform_members; their linkage is enforced by FKs in the schema. The new post is immediately available for reading, voting, commenting, and moderation. Fails if membership/authentication is invalid, or if inputs do not conform to format/uniqueness constraints.\n\nFull Prisma schema for the relevant model is included for compliance and validation:\n\nmodel community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/member/posts","method":"post","description":"This operation allows any authenticated member to create a new post within a specific community. Based on the community_platform_posts table, all required information—including the community id, author/member id, post title (5-120 characters, plain text only), body (10-10,000 characters, plain text only), and optional author_display_name—must be provided in the request. Upon validation, a new post is created and persisted with created_at and updated_at timestamps. The operation enforces all input validation rules (lengths, content policies, and foreign key integrity for community and member). The resulting entity is linked to its community and author; downstream operations such as commenting, voting, and editing are allowed. This operation is secured by requiring member authentication and does not allow public or guest access. Error scenarios include missing or invalid fields, lack of authentication, or violations of business rules regarding post structure or membership. Upon success, the full created post entity is returned, matching the schema definition.","summary":"Create a new post in a community by an authenticated member.","parameters":[],"requestBody":{"description":"Information required to create a new community post, according to schema and business rules.","typeName":"ICommunityPlatformPost.ICreate"},"responseBody":{"description":"Complete post entity as stored after creation.","typeName":"ICommunityPlatformPost"},"authorizationRoles":["member"],"name":"create","model_name":"community_platform_posts","soft_delete_column":null,"prisma_schemas":"model community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"member","authorizationType":null},{"specification":"Update an existing community post identified by its postId. This operation writes changes to major updatable fields defined in the community_platform_posts table: title, body, and author_display_name (optional). Only the post author and admin have rights to update posts—guests and other members are denied. Input data is strictly validated for formats and business rules as defined in the schema (title 5-120 chars, body 10-10,000 chars, author_display_name up to 32, plain text enforced). On update, updated_at is replaced with the current timestamp; created_at and other immutable fields (such as id and community assignment) remain unchanged. Edits create new post_snapshots for audit/history. Endpoints for edit are fully consistent with post entity logic and business workflow around moderation and publishing. The operation fails if post does not exist, is deleted, or the user lacks write permission to the resource.\n\nFull Prisma schema for the relevant model:\n\nmodel community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/member/posts/{postId}","method":"put","description":"This endpoint updates a post’s editable fields (title, body, author_display_name) as defined in the community_platform_posts schema. It requires authentication as the post author or admin, and strictly enforces input validation. The updated content is persisted, timestamps are updated, and a corresponding post_snapshot is generated for version history. The operation does not allow updates to the post's community, author, or unique id. If the target post does not exist, was deleted, or the user is not authorized, a suitable error is returned. This endpoint is fundamental for member-driven content management and editorial workflows in the platform business domain. Other modification actions, such as moderation or post restoration, are handled in separate administrative endpoints. API consumers should ensure that edit/update shapes match the server's required DTO and all business and schema rules.","summary":"Update an existing community post by postId, with strict validation and role checks.","parameters":[{"name":"postId","description":"The unique identifier (UUID) of the post to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Fields to update in the specified post, following business input rules.","typeName":"ICommunityPlatformPost.IUpdate"},"responseBody":{"description":"Updated post entity with latest fields after changes.","typeName":"ICommunityPlatformPost"},"authorizationRoles":["member","admin"],"name":"update","model_name":"community_platform_posts","soft_delete_column":"deleted_at","prisma_schemas":"model community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"member","authorizationType":null},{"specification":"Update an existing community post identified by its postId. This operation writes changes to major updatable fields defined in the community_platform_posts table: title, body, and author_display_name (optional). Only the post author and admin have rights to update posts—guests and other members are denied. Input data is strictly validated for formats and business rules as defined in the schema (title 5-120 chars, body 10-10,000 chars, author_display_name up to 32, plain text enforced). On update, updated_at is replaced with the current timestamp; created_at and other immutable fields (such as id and community assignment) remain unchanged. Edits create new post_snapshots for audit/history. Endpoints for edit are fully consistent with post entity logic and business workflow around moderation and publishing. The operation fails if post does not exist, is deleted, or the user lacks write permission to the resource.\n\nFull Prisma schema for the relevant model:\n\nmodel community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/admin/posts/{postId}","method":"put","description":"This endpoint updates a post’s editable fields (title, body, author_display_name) as defined in the community_platform_posts schema. It requires authentication as the post author or admin, and strictly enforces input validation. The updated content is persisted, timestamps are updated, and a corresponding post_snapshot is generated for version history. The operation does not allow updates to the post's community, author, or unique id. If the target post does not exist, was deleted, or the user is not authorized, a suitable error is returned. This endpoint is fundamental for member-driven content management and editorial workflows in the platform business domain. Other modification actions, such as moderation or post restoration, are handled in separate administrative endpoints. API consumers should ensure that edit/update shapes match the server's required DTO and all business and schema rules.","summary":"Update an existing community post by postId, with strict validation and role checks.","parameters":[{"name":"postId","description":"The unique identifier (UUID) of the post to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Fields to update in the specified post, following business input rules.","typeName":"ICommunityPlatformPost.IUpdate"},"responseBody":{"description":"Updated post entity with latest fields after changes.","typeName":"ICommunityPlatformPost"},"authorizationRoles":["member","admin"],"name":"update","model_name":"community_platform_posts","soft_delete_column":"deleted_at","prisma_schemas":"model community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"admin","authorizationType":null},{"specification":"Delete a post resource from the community_platform_posts table, identified by the provided postId. The delete action marks the deleted_at column with the current timestamp (soft delete), thus removing the post from active feeds but preserving it for audit trails, moderation, and time-based cleanup. Deleting a post also requires cascade handling according to business rules, ensuring any linked comments, votes, or moderation reports are addressed by downstream application logic. Only the post author or an admin may invoke this operation. On success, the post is marked as soft deleted and is excluded from subsequent queries for active posts. Attempts to delete already-deleted posts or by unauthorized users trigger an error response. Administrative undelete/recovery is handled separately. This endpoint does not return the deleted entity.\n\nmodel community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/member/posts/{postId}","method":"delete","description":"This operation soft deletes a specific post on the community platform, setting the 'deleted_at' column of community_platform_posts. Only the post's author or an admin is permitted to perform this action. Soft deletion ensures the post is hidden from the main feed but remains in the database for compliance, audit, and possible future restoration. Comments, votes, and related moderation data must be handled as per cascade rules in business logic (e.g., marking associated comments as deleted). Deleting a non-existent, already-deleted, or unauthorized post results in an error. This endpoint does not support hard deletion or data purging, and is consistent with audit, moderation, and compliance workflows. Soft-deleted posts are not returned by most read/search operations. Restoration (undelete) is performed via different admin endpoints if allowed by business policy.","summary":"Soft delete the specified community post by postId (set deleted_at).","parameters":[{"name":"postId","description":"The unique identifier (UUID) of the post to delete (soft delete).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["member","admin"],"name":"erase","model_name":"community_platform_posts","soft_delete_column":"deleted_at","prisma_schemas":"model community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"member","authorizationType":null},{"specification":"Delete a post resource from the community_platform_posts table, identified by the provided postId. The delete action marks the deleted_at column with the current timestamp (soft delete), thus removing the post from active feeds but preserving it for audit trails, moderation, and time-based cleanup. Deleting a post also requires cascade handling according to business rules, ensuring any linked comments, votes, or moderation reports are addressed by downstream application logic. Only the post author or an admin may invoke this operation. On success, the post is marked as soft deleted and is excluded from subsequent queries for active posts. Attempts to delete already-deleted posts or by unauthorized users trigger an error response. Administrative undelete/recovery is handled separately. This endpoint does not return the deleted entity.\n\nmodel community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/admin/posts/{postId}","method":"delete","description":"This operation soft deletes a specific post on the community platform, setting the 'deleted_at' column of community_platform_posts. Only the post's author or an admin is permitted to perform this action. Soft deletion ensures the post is hidden from the main feed but remains in the database for compliance, audit, and possible future restoration. Comments, votes, and related moderation data must be handled as per cascade rules in business logic (e.g., marking associated comments as deleted). Deleting a non-existent, already-deleted, or unauthorized post results in an error. This endpoint does not support hard deletion or data purging, and is consistent with audit, moderation, and compliance workflows. Soft-deleted posts are not returned by most read/search operations. Restoration (undelete) is performed via different admin endpoints if allowed by business policy.","summary":"Soft delete the specified community post by postId (set deleted_at).","parameters":[{"name":"postId","description":"The unique identifier (UUID) of the post to delete (soft delete).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["member","admin"],"name":"erase","model_name":"community_platform_posts","soft_delete_column":"deleted_at","prisma_schemas":"model community_platform_posts {\n  id String @id @db.Uuid\n  community_platform_community_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"admin","authorizationType":null},{"specification":"Search and retrieve a paginated list of all historical revision snapshots for a given post. The endpoint operates on community_platform_post_snapshots, which stores immutable revision records for each update made to a post. Patch is used for advanced querying to support pagination, sorting (usually by created_at descending), and optional search filters. The API expects input parameters for results per page, current page number, and optional filters (see request DTO). It returns a paginated set of post snapshots, including title/body content, author info, and created_at timestamps. Intended for use in moderator review, user post history, and editorial auditing. Only the post author or an admin may access the full snapshot revision history. The results include only snapshots associated with the post specified by postId, ordered with most recent edits first. Business logic enforces security: users cannot view revision history for others' posts without admin privilege.\n\nPrisma model:\nmodel community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","path":"/communityPlatform/member/posts/{postId}/snapshots","method":"patch","description":"This endpoint retrieves paginated historical post revision snapshots for a single post, identified by postId. It leverages the community_platform_post_snapshots table for immutable audit/history storage. The API supports advanced querying—pagination (page/limit), optional sorting, and filters as described in the request DTO. Snapshots include details such as title, body, author_display_name (if set), and created_at timestamp for each post revision. Operation is restricted: only the original author or an admin may view revision history. Use cases include author content review, editorial control, and moderator audit checks. Security is enforced to ensure privacy of post edit history—read-only unless admin. Errors are returned for unauthorized view or if post/snapshots are not found. This endpoint does not allow edits, only retrieval. Related operations include creating/updating posts and fetching post details.","summary":"Paginated, filtered query of snapshots (version history) for a specific post.","parameters":[{"name":"postId","description":"The unique identifier (UUID) of the post whose snapshots are listed.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Pagination and filter parameters to search for post snapshots.","typeName":"ICommunityPlatformPostSnapshot.IRequest"},"responseBody":{"description":"Paginated set of post snapshot entities matching query.","typeName":"IPageICommunityPlatformPostSnapshot"},"authorizationRoles":["member","admin"],"name":"index","model_name":"community_platform_post_snapshots","soft_delete_column":null,"prisma_schemas":"model community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","authorizationRole":"member","authorizationType":null},{"specification":"Search and retrieve a paginated list of all historical revision snapshots for a given post. The endpoint operates on community_platform_post_snapshots, which stores immutable revision records for each update made to a post. Patch is used for advanced querying to support pagination, sorting (usually by created_at descending), and optional search filters. The API expects input parameters for results per page, current page number, and optional filters (see request DTO). It returns a paginated set of post snapshots, including title/body content, author info, and created_at timestamps. Intended for use in moderator review, user post history, and editorial auditing. Only the post author or an admin may access the full snapshot revision history. The results include only snapshots associated with the post specified by postId, ordered with most recent edits first. Business logic enforces security: users cannot view revision history for others' posts without admin privilege.\n\nPrisma model:\nmodel community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","path":"/communityPlatform/admin/posts/{postId}/snapshots","method":"patch","description":"This endpoint retrieves paginated historical post revision snapshots for a single post, identified by postId. It leverages the community_platform_post_snapshots table for immutable audit/history storage. The API supports advanced querying—pagination (page/limit), optional sorting, and filters as described in the request DTO. Snapshots include details such as title, body, author_display_name (if set), and created_at timestamp for each post revision. Operation is restricted: only the original author or an admin may view revision history. Use cases include author content review, editorial control, and moderator audit checks. Security is enforced to ensure privacy of post edit history—read-only unless admin. Errors are returned for unauthorized view or if post/snapshots are not found. This endpoint does not allow edits, only retrieval. Related operations include creating/updating posts and fetching post details.","summary":"Paginated, filtered query of snapshots (version history) for a specific post.","parameters":[{"name":"postId","description":"The unique identifier (UUID) of the post whose snapshots are listed.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Pagination and filter parameters to search for post snapshots.","typeName":"ICommunityPlatformPostSnapshot.IRequest"},"responseBody":{"description":"Paginated set of post snapshot entities matching query.","typeName":"IPageICommunityPlatformPostSnapshot"},"authorizationRoles":["member","admin"],"name":"index","model_name":"community_platform_post_snapshots","soft_delete_column":null,"prisma_schemas":"model community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieve the full details of a specific post snapshot, identified by the parent postId and the snapshotId. This GET endpoint queries the community_platform_post_snapshots table to return one immutable revision record with all fields, including title, body, author_display_name, created_at, and references to post and author. Only the post author or an admin is allowed to view this snapshot. This operation is useful for moderation, rollback, change tracking, or audit reviews. It returns the exact details of the selected revision as captured at the time. Errors are returned if not found, or if unauthorized. Editing of snapshots is not supported; any new edit to the post creates a new snapshot instead. Use this endpoint with the main GET post endpoint for displaying both current and historical post content as needed in the user interface.\n\nmodel community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","path":"/communityPlatform/member/posts/{postId}/snapshots/{snapshotId}","method":"get","description":"This endpoint returns the details of a single revision snapshot for a specified post, as identified by both postId and snapshotId. The target is a row from community_platform_post_snapshots containing the historical content of that post revision (title, body, author_display_name, created_at timestamp, and references to author and post at the time of edit). Security rules dictate that only the post's original author or admins may read post history. If not found, an error is returned. This endpoint complements the standard post GET and snapshot list endpoints, supporting granular moderation, rollback, and transparency. It is a read-only operation. Attempts to edit or delete the snapshot directly are not permitted under business logic.","summary":"Retrieve a specific snapshot (version) for a post by snapshotId.","parameters":[{"name":"postId","description":"The identifier (UUID) of the post the snapshot belongs to.","schema":{"type":"string","format":"uuid"}},{"name":"snapshotId","description":"The unique identifier (UUID) of the snapshot to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full details of the specified post snapshot version, including content and meta.","typeName":"ICommunityPlatformPostSnapshot"},"authorizationRoles":["member","admin"],"name":"at","model_name":"community_platform_post_snapshots","soft_delete_column":null,"prisma_schemas":"model community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","authorizationRole":"member","authorizationType":null},{"specification":"Retrieve the full details of a specific post snapshot, identified by the parent postId and the snapshotId. This GET endpoint queries the community_platform_post_snapshots table to return one immutable revision record with all fields, including title, body, author_display_name, created_at, and references to post and author. Only the post author or an admin is allowed to view this snapshot. This operation is useful for moderation, rollback, change tracking, or audit reviews. It returns the exact details of the selected revision as captured at the time. Errors are returned if not found, or if unauthorized. Editing of snapshots is not supported; any new edit to the post creates a new snapshot instead. Use this endpoint with the main GET post endpoint for displaying both current and historical post content as needed in the user interface.\n\nmodel community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","path":"/communityPlatform/admin/posts/{postId}/snapshots/{snapshotId}","method":"get","description":"This endpoint returns the details of a single revision snapshot for a specified post, as identified by both postId and snapshotId. The target is a row from community_platform_post_snapshots containing the historical content of that post revision (title, body, author_display_name, created_at timestamp, and references to author and post at the time of edit). Security rules dictate that only the post's original author or admins may read post history. If not found, an error is returned. This endpoint complements the standard post GET and snapshot list endpoints, supporting granular moderation, rollback, and transparency. It is a read-only operation. Attempts to edit or delete the snapshot directly are not permitted under business logic.","summary":"Retrieve a specific snapshot (version) for a post by snapshotId.","parameters":[{"name":"postId","description":"The identifier (UUID) of the post the snapshot belongs to.","schema":{"type":"string","format":"uuid"}},{"name":"snapshotId","description":"The unique identifier (UUID) of the snapshot to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full details of the specified post snapshot version, including content and meta.","typeName":"ICommunityPlatformPostSnapshot"},"authorizationRoles":["member","admin"],"name":"at","model_name":"community_platform_post_snapshots","soft_delete_column":null,"prisma_schemas":"model community_platform_post_snapshots {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  community_platform_member_id String @db.Uuid\n  title String\n  body String\n  author_display_name String?\n  created_at DateTime @db.Timestamptz\n}","authorizationRole":"admin","authorizationType":null},{"specification":"Query a paginated, filterable list of post reports for a given post, using the community_platform_post_reports table. This PATCH endpoint is designed for advanced retrieval with filters, pagination (page/limit), sorting, and optional status or type filtering as described in the request DTO. Each report is associated with a parent post via community_platform_post_id, and includes references to the reporter and admin handling the case, report type, status, resolution notes, and key timestamps. Admins have full access to all reports, while members may only see those they have filed. No guest access. Results include relevant join info to enable UI screens listing open/closed/spam/abuse cases by post and status. Designed to assist moderation workflows, abuse triage, and transparency. Cascade rules ensure correct ties to the post, member, and admin entities. Returns a paginated response DTO. Attempts to search for reports on deleted or inaccessible posts throw errors.\n\nmodel community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/member/posts/{postId}/reports","method":"patch","description":"This operation returns a paginated list of post report entities associated with a specific post (by postId). The operation fetches from the community_platform_post_reports table, using advanced filtering, sorting, and pagination as set by the request DTO. Each report includes details such as reported_by_member_id, admin_id, report_type, reason, status, resolution notes, and creation/updated/resolved timestamps. Authorization is enforced: admins may view all reports; members may view their own filed reports; guests are denied. Use cases include moderation panels, abuse workflows, and user transparency features. Error scenarios arise when accessing reports for deleted/non-existent posts or without appropriate role. This endpoint does not allow creation or modification of reports—only search/list. Use the related endpoints to fetch report detail or to file a new report.","summary":"Paginated, filtered search for reports/flags on a given post.","parameters":[{"name":"postId","description":"The UUID of the post for which reports are queried.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Query/filter parameters for paginated searching of post reports.","typeName":"ICommunityPlatformPostReport.IRequest"},"responseBody":{"description":"Paginated result set of post report entities.","typeName":"IPageICommunityPlatformPostReport"},"authorizationRoles":["member","admin"],"name":"index","model_name":"community_platform_post_reports","soft_delete_column":null,"prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"member","authorizationType":null},{"specification":"Query a paginated, filterable list of post reports for a given post, using the community_platform_post_reports table. This PATCH endpoint is designed for advanced retrieval with filters, pagination (page/limit), sorting, and optional status or type filtering as described in the request DTO. Each report is associated with a parent post via community_platform_post_id, and includes references to the reporter and admin handling the case, report type, status, resolution notes, and key timestamps. Admins have full access to all reports, while members may only see those they have filed. No guest access. Results include relevant join info to enable UI screens listing open/closed/spam/abuse cases by post and status. Designed to assist moderation workflows, abuse triage, and transparency. Cascade rules ensure correct ties to the post, member, and admin entities. Returns a paginated response DTO. Attempts to search for reports on deleted or inaccessible posts throw errors.\n\nmodel community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/admin/posts/{postId}/reports","method":"patch","description":"This operation returns a paginated list of post report entities associated with a specific post (by postId). The operation fetches from the community_platform_post_reports table, using advanced filtering, sorting, and pagination as set by the request DTO. Each report includes details such as reported_by_member_id, admin_id, report_type, reason, status, resolution notes, and creation/updated/resolved timestamps. Authorization is enforced: admins may view all reports; members may view their own filed reports; guests are denied. Use cases include moderation panels, abuse workflows, and user transparency features. Error scenarios arise when accessing reports for deleted/non-existent posts or without appropriate role. This endpoint does not allow creation or modification of reports—only search/list. Use the related endpoints to fetch report detail or to file a new report.","summary":"Paginated, filtered search for reports/flags on a given post.","parameters":[{"name":"postId","description":"The UUID of the post for which reports are queried.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Query/filter parameters for paginated searching of post reports.","typeName":"ICommunityPlatformPostReport.IRequest"},"responseBody":{"description":"Paginated result set of post report entities.","typeName":"IPageICommunityPlatformPostReport"},"authorizationRoles":["member","admin"],"name":"index","model_name":"community_platform_post_reports","soft_delete_column":null,"prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"admin","authorizationType":null},{"specification":"Retrieve full details of a single post report entity, identified by both the target postId and the reportId (report primary key). This GET endpoint reads from community_platform_post_reports, returning all major entity fields: reported_by_member_id, admin_id (if any), report_type, reason, status, resolution notes, created_at, updated_at, resolved_at, and deleted_at. Related entities (post, reporter, admin) are linked via FKs for full context but not expanded in this endpoint. Members can only access reports they have filed on the specified post, while admins may retrieve any report. This operation is used for transparency, moderation, or review workflows, and is always a read-only operation. If the post/report do not exist or the requester is unauthorized, an error is returned. This endpoint is not for creation or update of reports—only retrieval. It complements the reports search/list endpoint above and should be cross-referenced for audit or appeal workflows.\n\nmodel community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/member/posts/{postId}/reports/{reportId}","method":"get","description":"This operation retrieves details of an individual report concerning a particular post, as identified by postId and reportId. It reads a full record from community_platform_post_reports, returning reference IDs for reporter and admin, the report type and reason, statuses and resolution context, and all matching timestamps. Security guarantees that only the reporter for the report or an admin can view the content. The endpoint is used for moderation, review, transparency, and dispute workflows, and is strictly read-only. Accessing a non-existent or unauthorized report results in an error. Other API endpoints exist for creating, updating, or resolving reports through administrative actions. Access is denied to guests.","summary":"Retrieve detail for a specific report on a post by reportId.","parameters":[{"name":"postId","description":"The UUID of the post to which the report belongs.","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"The unique identifier (UUID) of the specific report entity.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"All fields for the specified post report entity.","typeName":"ICommunityPlatformPostReport"},"authorizationRoles":["member","admin"],"name":"at","model_name":"community_platform_post_reports","soft_delete_column":null,"prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"member","authorizationType":null},{"specification":"Retrieve full details of a single post report entity, identified by both the target postId and the reportId (report primary key). This GET endpoint reads from community_platform_post_reports, returning all major entity fields: reported_by_member_id, admin_id (if any), report_type, reason, status, resolution notes, created_at, updated_at, resolved_at, and deleted_at. Related entities (post, reporter, admin) are linked via FKs for full context but not expanded in this endpoint. Members can only access reports they have filed on the specified post, while admins may retrieve any report. This operation is used for transparency, moderation, or review workflows, and is always a read-only operation. If the post/report do not exist or the requester is unauthorized, an error is returned. This endpoint is not for creation or update of reports—only retrieval. It complements the reports search/list endpoint above and should be cross-referenced for audit or appeal workflows.\n\nmodel community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","path":"/communityPlatform/admin/posts/{postId}/reports/{reportId}","method":"get","description":"This operation retrieves details of an individual report concerning a particular post, as identified by postId and reportId. It reads a full record from community_platform_post_reports, returning reference IDs for reporter and admin, the report type and reason, statuses and resolution context, and all matching timestamps. Security guarantees that only the reporter for the report or an admin can view the content. The endpoint is used for moderation, review, transparency, and dispute workflows, and is strictly read-only. Accessing a non-existent or unauthorized report results in an error. Other API endpoints exist for creating, updating, or resolving reports through administrative actions. Access is denied to guests.","summary":"Retrieve detail for a specific report on a post by reportId.","parameters":[{"name":"postId","description":"The UUID of the post to which the report belongs.","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"The unique identifier (UUID) of the specific report entity.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"All fields for the specified post report entity.","typeName":"ICommunityPlatformPostReport"},"authorizationRoles":["member","admin"],"name":"at","model_name":"community_platform_post_reports","soft_delete_column":null,"prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows an authenticated member or admin to create a new report about a specific post, typically to flag inappropriate or rule-violating content for moderation review. It targets the community_platform_post_reports table. Each report must specify the post being reported (via postId path parameter), the reporting member (inferred from token), and details such as report_type (category of violation), reason (required text), and initial status (e.g., open). Reports are reviewed and actioned by admins as part of the moderation workflow. The business logic enforces that any member can report a post only once (unique index), and all fields must meet length and format constraints. A newly created report is linked to the target post and reporter and may later be assigned to an admin for escalation. The request body references ICommunityPlatformPostReport.ICreate, and the response returns full details of the created report (ICommunityPlatformPostReport). Admins may also create reports as part of moderation/escalation flows. Backend validation enforces that only authenticated members or admins can create a report. Cascade deletion is handled on post/user deletion.","path":"/communityPlatform/member/posts/{postId}/reports","method":"post","prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [community_platform_post_id], references: [id], onDelete: Cascade)\n  reporter community_platform_members @relation(fields: [reported_by_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@index([reported_by_member_id])\n  @@index([admin_id])\n  @@index([report_type, status, created_at], map: \"community_platform_post_reports_report_type_status_cre_8b7036f0\")\n  @@index([community_platform_post_id, status], map: \"community_platform_post_reports_community_platform_pos_def59a0e\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member","admin"],"description":"Create a new report regarding a given post, allowing members or admins to flag inappropriate content, spam, abuse, or rule violations for moderation review. The reporting user must be authenticated, and the target post specified by postId. Request details must include a report_type for category (such as spam, abuse, etc), a descriptive reason, and will be tracked under 'open' status until reviewed. The operation enforces strict input validation: report_type must match platform-allowed values, and reason must be non-empty, up to 1000 chars (plain text). Only one report per post per member is allowed; duplicate reports by the same member are rejected. Admins can also create reports for escalated cases. Each report is associated with the referenced post and the authenticated reporting user, allowing follow-up workflow by moderators. Related APIs: PUT and DELETE operations for managing reports, and admin moderation endpoints for escalations and resolution management. Error handling covers permission issues (non-members/guests can't report), invalid input, and business rule failures.","summary":"Create a new report about a post for moderation review (community_platform_post_reports table).","parameters":[{"name":"postId","description":"Unique identifier of the target post being reported.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Information for creating a report on a specific post, including report_type, reason, and status.","typeName":"ICommunityPlatformPostReport.ICreate"},"responseBody":{"description":"Details of the created report tied to the post, including status, type, reason, and IDs.","typeName":"ICommunityPlatformPostReport"},"name":"create","model_name":"community_platform_post_reports","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"This operation allows an authenticated member or admin to create a new report about a specific post, typically to flag inappropriate or rule-violating content for moderation review. It targets the community_platform_post_reports table. Each report must specify the post being reported (via postId path parameter), the reporting member (inferred from token), and details such as report_type (category of violation), reason (required text), and initial status (e.g., open). Reports are reviewed and actioned by admins as part of the moderation workflow. The business logic enforces that any member can report a post only once (unique index), and all fields must meet length and format constraints. A newly created report is linked to the target post and reporter and may later be assigned to an admin for escalation. The request body references ICommunityPlatformPostReport.ICreate, and the response returns full details of the created report (ICommunityPlatformPostReport). Admins may also create reports as part of moderation/escalation flows. Backend validation enforces that only authenticated members or admins can create a report. Cascade deletion is handled on post/user deletion.","path":"/communityPlatform/admin/posts/{postId}/reports","method":"post","prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [community_platform_post_id], references: [id], onDelete: Cascade)\n  reporter community_platform_members @relation(fields: [reported_by_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@index([reported_by_member_id])\n  @@index([admin_id])\n  @@index([report_type, status, created_at], map: \"community_platform_post_reports_report_type_status_cre_8b7036f0\")\n  @@index([community_platform_post_id, status], map: \"community_platform_post_reports_community_platform_pos_def59a0e\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member","admin"],"description":"Create a new report regarding a given post, allowing members or admins to flag inappropriate content, spam, abuse, or rule violations for moderation review. The reporting user must be authenticated, and the target post specified by postId. Request details must include a report_type for category (such as spam, abuse, etc), a descriptive reason, and will be tracked under 'open' status until reviewed. The operation enforces strict input validation: report_type must match platform-allowed values, and reason must be non-empty, up to 1000 chars (plain text). Only one report per post per member is allowed; duplicate reports by the same member are rejected. Admins can also create reports for escalated cases. Each report is associated with the referenced post and the authenticated reporting user, allowing follow-up workflow by moderators. Related APIs: PUT and DELETE operations for managing reports, and admin moderation endpoints for escalations and resolution management. Error handling covers permission issues (non-members/guests can't report), invalid input, and business rule failures.","summary":"Create a new report about a post for moderation review (community_platform_post_reports table).","parameters":[{"name":"postId","description":"Unique identifier of the target post being reported.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Information for creating a report on a specific post, including report_type, reason, and status.","typeName":"ICommunityPlatformPostReport.ICreate"},"responseBody":{"description":"Details of the created report tied to the post, including status, type, reason, and IDs.","typeName":"ICommunityPlatformPostReport"},"name":"create","model_name":"community_platform_post_reports","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows an authenticated admin (or the member who created the report, where permitted by business rules) to modify an existing report about a post, such as updating the status (e.g., from open to resolved), resolution notes, or changing the report type after review. It targets the community_platform_post_reports table and operates on a specific report identified by reportId (path parameter) under a given post (postId). Only admins (and potentially the original reporting member subject to business rules) are authorized to modify reports. The operation enforces all relevant validation rules: only allowed status transitions (e.g., open→resolved, pending→dismissed), and all required fields according to moderation flow. Request body references ICommunityPlatformPostReport.IUpdate, and response returns full updated report details. All actions are fully audited for compliance.","path":"/communityPlatform/admin/posts/{postId}/reports/{reportId}","method":"put","prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [community_platform_post_id], references: [id], onDelete: Cascade)\n  reporter community_platform_members @relation(fields: [reported_by_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@index([reported_by_member_id])\n  @@index([admin_id])\n  @@index([report_type, status, created_at], map: \"community_platform_post_reports_report_type_status_cre_8b7036f0\")\n  @@index([community_platform_post_id, status], map: \"community_platform_post_reports_community_platform_pos_def59a0e\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Update or resolve a specific post report, enabling an admin to change status, add resolution notes, or adjust report metadata. Only users with admin privileges can perform update actions on post reports. Status transitions are strictly controlled: reports may move from open to resolved, pending to dismissed, and admins may provide rationale in resolution_notes. All updates are fully audited for moderation transparency and accountability, with member visibility as required (e.g., to track report progress). Related endpoints: report creation (POST), deletion (DELETE), and detailed report history/audit logs. Validation covers existence of the report (404 on missing/deleted), permissible status values, and proper text fields. Edge cases include handling already resolved or deleted reports.","summary":"Update or resolve a post report as an admin (community_platform_post_reports table).","parameters":[{"name":"postId","description":"Unique identifier of the post containing the report.","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"Unique identifier of the report to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Fields to modify for the post report, such as status or resolution_notes.","typeName":"ICommunityPlatformPostReport.IUpdate"},"responseBody":{"description":"Full, updated report details after status or metadata change.","typeName":"ICommunityPlatformPostReport"},"name":"update","model_name":"community_platform_post_reports","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows an admin to delete an existing report on a post, permanently removing it from the moderation queue, audit trail, and future workflow. It targets the community_platform_post_reports table and the DELETE is performed using both postId and reportId as path parameters to ensure unique identification. Only admins are permitted to delete reports, and soft-deletion is enforced through the deleted_at field. Deletion can only be performed if the report exists; attempts to delete a non-existent or already deleted report result in a 404 error. All deletions are comprehensively logged for audit and compliance.","path":"/communityPlatform/admin/posts/{postId}/reports/{reportId}","method":"delete","prisma_schemas":"model community_platform_post_reports {\n  id String @id @db.Uuid\n  community_platform_post_id String @db.Uuid\n  reported_by_member_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_type String\n  reason String\n  status String\n  resolution_notes String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [community_platform_post_id], references: [id], onDelete: Cascade)\n  reporter community_platform_members @relation(fields: [reported_by_member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@index([reported_by_member_id])\n  @@index([admin_id])\n  @@index([report_type, status, created_at], map: \"community_platform_post_reports_report_type_status_cre_8b7036f0\")\n  @@index([community_platform_post_id, status], map: \"community_platform_post_reports_community_platform_pos_def59a0e\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Delete a specific report for a post, removing it from the moderation system. Only admins may perform this action. The deletion is implemented as a soft delete by setting the deleted_at field on the report, which ensures the record is not physically removed but becomes invisible to active workflows and reporting interfaces. Deletion requests for already-deleted or non-existent reports return a not found error. All deletion actions are thoroughly audited for compliance and traceability. Related endpoints: report creation (POST), update (PUT), and audit log retrieval.","summary":"Soft delete a report for a post as an admin (community_platform_post_reports table).","parameters":[{"name":"postId","description":"Unique identifier of the post containing the report.","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"Unique identifier of the report to delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","model_name":"community_platform_post_reports","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation searches for comments across the platform with advanced filtering, sorting, and pagination capabilities. It targets the community_platform_comments table and returns a paginated list of simplified comment representations suitable for list display (summary type). The request body supports search by content, postId, authorId, created time, and allows sorting by created_at or score in ascending/descending order. Business rules enforce minimum content length, author existence, and access rules: anyone (guests, members, admins) can search and view comments data, but private/restricted comments (such as on deleted posts or hidden by moderation) are filtered for non-admin users. The underlying schema ensures only accessible comments are included; deleted_at indicates logically deleted comments which are hidden from non-admins. The response bundle (IPageICommunityPlatformComment.ISummary) includes pagination metadata and a list of summary comments. Related operations include GET for a specific comment, creation, update, and deletion for members.","path":"/communityPlatform/comments","method":"patch","prisma_schemas":"model community_platform_comments {\n  id String @id @db.Uuid\n  post_id String @db.Uuid\n  author_id String @db.Uuid\n  parent_id String? @db.Uuid\n  content String\n  edited Boolean\n  score Int? @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author community_platform_members @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent community_platform_comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  recursive community_platform_comments[] @relation(\"recursive\")\n  community_platform_comment_snapshots community_platform_comment_snapshots[]\n  community_platform_comment_reports community_platform_comment_reports[]\n  community_platform_votes community_platform_votes[]\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([post_id, id])\n  @@unique([parent_id, id])\n  @@index([post_id, parent_id])\n  @@index([author_id, created_at])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":[],"description":"Search and retrieve a list of comments matching specified filters and criteria, supporting advanced text query, author and post lookup, and flexible sort and pagination controls. All fields must match actual properties from the schema. Only non-deleted comments are included unless requested by an admin. Public access: guests, members, and admins all can search comments. The operation supports searching by a substring of content, filtering to a particular post or author, and sorting by newest or score. Pagination is managed via request body parameters (e.g., page, pageSize). Related endpoints: comment detail (GET), creation (POST), modification (PUT), and deletion (DELETE).","summary":"List/filter/search public comments with pagination (community_platform_comments).","parameters":[],"requestBody":{"description":"Search and filter request parameters for comment listing. Supports query by content/post/author and page/sort controls.","typeName":"ICommunityPlatformComment.IRequest"},"responseBody":{"description":"Paginated list of simplified (summary) comment objects with metadata.","typeName":"IPageICommunityPlatformComment.ISummary"},"name":"index","model_name":"community_platform_comments","soft_delete_column":"deleted_at","authorizationRole":null,"authorizationType":null},{"specification":"Get a single comment by its unique identifier (commentId). This operation targets the community_platform_comments table and retrieves the full comment object if it exists and has not been deleted (deleted_at is null for standard users; admin access may see deleted if permitted by business logic). Detailed information includes the comment's content, author, parent (for threads), associated post, creation and update timestamps, edited flag, and logical deletion state. Returns 404 if the comment does not exist or is deleted (for non-admins). The response schema uses the main comment DTO type (ICommunityPlatformComment).","path":"/communityPlatform/comments/{commentId}","method":"get","prisma_schemas":"model community_platform_comments {\n  id String @id @db.Uuid\n  post_id String @db.Uuid\n  author_id String @db.Uuid\n  parent_id String? @db.Uuid\n  content String\n  edited Boolean\n  score Int? @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author community_platform_members @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent community_platform_comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  recursive community_platform_comments[] @relation(\"recursive\")\n  community_platform_comment_snapshots community_platform_comment_snapshots[]\n  community_platform_comment_reports community_platform_comment_reports[]\n  community_platform_votes community_platform_votes[]\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([post_id, id])\n  @@unique([parent_id, id])\n  @@index([post_id, parent_id])\n  @@index([author_id, created_at])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":[],"description":"Retrieve all details for a specific comment, as identified by its commentId. Any user can fetch public comments, with admins able to access deleted ones if authorized. Returns null if the comment does not exist or has been permanently deleted (hard delete is not used; deleted_at indicates logical deletion). Related endpoints: PATCH for search/results, POST for creation, PUT for modification, DELETE for removal.","summary":"Fetch detailed information for a comment by ID (community_platform_comments).","parameters":[{"name":"commentId","description":"Unique identifier of the comment to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full detailed comment object, including all relationships and fields from schema.","typeName":"ICommunityPlatformComment"},"name":"at","model_name":"community_platform_comments","soft_delete_column":"deleted_at","authorizationRole":null,"authorizationType":null},{"specification":"Create a new comment authored by a member on a specific post (supports top-level or reply comments). This operation targets the community_platform_comments table and requires a valid postId, authorId (from credential), and plain text content (2-2000 chars, no code/scripts). Parent_id may be provided for threaded replies (or null for top-level). Only authenticated members can create comments. On success, returns the complete comment record as stored. The operation enforces business rules for content length, input validation, membership in the post's community (if enforced), and plain text/no script requirement. Creates are not allowed for guests; proper error returned if tried without authentication.","path":"/communityPlatform/member/comments","method":"post","prisma_schemas":"model community_platform_comments {\n  id String @id @db.Uuid\n  post_id String @db.Uuid\n  author_id String @db.Uuid\n  parent_id String? @db.Uuid\n  content String\n  edited Boolean\n  score Int? @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author community_platform_members @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent community_platform_comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  recursive community_platform_comments[] @relation(\"recursive\")\n  community_platform_comment_snapshots community_platform_comment_snapshots[]\n  community_platform_comment_reports community_platform_comment_reports[]\n  community_platform_votes community_platform_votes[]\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([post_id, id])\n  @@unique([parent_id, id])\n  @@index([post_id, parent_id])\n  @@index([author_id, created_at])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member"],"description":"Submit a new comment to a post, or as a reply to another comment (if parent_id provided), as an authenticated member. All comment data must conform to schema: post_id, author_id (from user session), content (2-2000 chars, plain text), edited (false on create), parent_id if a reply, and timestamps set by server. Guests cannot comment; error returned on unauthenticated requests. Membership in post's community may be verified as part of business logic. If parent_id is given, must match an existing comment on the same post. Related APIs: PATCH for searching, GET for detail, PUT for updating, DELETE for removal.","summary":"Create a new comment on a post or as a reply (community_platform_comments).","parameters":[],"requestBody":{"description":"Fields required to create a new comment. Must include at least post_id and content. parent_id for replies optional.","typeName":"ICommunityPlatformComment.ICreate"},"responseBody":{"description":"Complete comment object as written to DB, with all schema fields.","typeName":"ICommunityPlatformComment"},"name":"create","model_name":"community_platform_comments","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Update an existing comment by ID, allowing the original author (or admin, if authorized) to modify the comment's content. This operation targets the community_platform_comments table and enforces that only the comment's author (or an admin, depending on business rules) may update the content. Updates are limited to plain text content (2-2000 chars, no scripts). On modification, the edited field is set to true and updated_at is refreshed. Only authenticated users may perform this action. Returns the updated comment object. All updates are snapshotted into the comment_snapshots table for audit trails.","path":"/communityPlatform/member/comments/{commentId}","method":"put","prisma_schemas":"model community_platform_comments {\n  id String @id @db.Uuid\n  post_id String @db.Uuid\n  author_id String @db.Uuid\n  parent_id String? @db.Uuid\n  content String\n  edited Boolean\n  score Int? @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author community_platform_members @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent community_platform_comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  recursive community_platform_comments[] @relation(\"recursive\")\n  community_platform_comment_snapshots community_platform_comment_snapshots[]\n  community_platform_comment_reports community_platform_comment_reports[]\n  community_platform_votes community_platform_votes[]\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([post_id, id])\n  @@unique([parent_id, id])\n  @@index([post_id, parent_id])\n  @@index([author_id, created_at])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member","admin"],"description":"Edit a comment by its ID, restricted to the comment's author or an admin. Payload must contain only the fields allowed by business rules (typically, new content text). Content must remain plain text, 2-2000 chars, no code/scripts. On successful update, the edited flag is set to true, updated_at refreshed, and an audit snapshot is stored. If the comment does not exist or is deleted, returns 404. Edge cases include update attempts by unauthorized users or invalid content input. Related endpoints: PATCH for list, GET for detail, POST for creation, DELETE for removal.","summary":"Update an existing comment by ID (community_platform_comments).","parameters":[{"name":"commentId","description":"Unique identifier of the comment to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Content to update for the comment. Must comply with plain text rules and length requirements.","typeName":"ICommunityPlatformComment.IUpdate"},"responseBody":{"description":"Comment object post-update, reflecting all new/changed fields.","typeName":"ICommunityPlatformComment"},"name":"update","model_name":"community_platform_comments","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Update an existing comment by ID, allowing the original author (or admin, if authorized) to modify the comment's content. This operation targets the community_platform_comments table and enforces that only the comment's author (or an admin, depending on business rules) may update the content. Updates are limited to plain text content (2-2000 chars, no scripts). On modification, the edited field is set to true and updated_at is refreshed. Only authenticated users may perform this action. Returns the updated comment object. All updates are snapshotted into the comment_snapshots table for audit trails.","path":"/communityPlatform/admin/comments/{commentId}","method":"put","prisma_schemas":"model community_platform_comments {\n  id String @id @db.Uuid\n  post_id String @db.Uuid\n  author_id String @db.Uuid\n  parent_id String? @db.Uuid\n  content String\n  edited Boolean\n  score Int? @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author community_platform_members @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent community_platform_comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  recursive community_platform_comments[] @relation(\"recursive\")\n  community_platform_comment_snapshots community_platform_comment_snapshots[]\n  community_platform_comment_reports community_platform_comment_reports[]\n  community_platform_votes community_platform_votes[]\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([post_id, id])\n  @@unique([parent_id, id])\n  @@index([post_id, parent_id])\n  @@index([author_id, created_at])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member","admin"],"description":"Edit a comment by its ID, restricted to the comment's author or an admin. Payload must contain only the fields allowed by business rules (typically, new content text). Content must remain plain text, 2-2000 chars, no code/scripts. On successful update, the edited flag is set to true, updated_at refreshed, and an audit snapshot is stored. If the comment does not exist or is deleted, returns 404. Edge cases include update attempts by unauthorized users or invalid content input. Related endpoints: PATCH for list, GET for detail, POST for creation, DELETE for removal.","summary":"Update an existing comment by ID (community_platform_comments).","parameters":[{"name":"commentId","description":"Unique identifier of the comment to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Content to update for the comment. Must comply with plain text rules and length requirements.","typeName":"ICommunityPlatformComment.IUpdate"},"responseBody":{"description":"Comment object post-update, reflecting all new/changed fields.","typeName":"ICommunityPlatformComment"},"name":"update","model_name":"community_platform_comments","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Delete a comment by its unique ID, marking it as deleted via soft delete (deleted_at field set). This operation targets the community_platform_comments table and is available to the comment's author or an admin. Deletion cascades to all child comments and votes. Only authenticated users may delete comments; guests are not permitted. Attempting to delete a comment that does not exist or is already deleted returns a 404. Soft delete ensures the record remains in the DB for audit but becomes invisible to standard API queries.","path":"/communityPlatform/member/comments/{commentId}","method":"delete","prisma_schemas":"model community_platform_comments {\n  id String @id @db.Uuid\n  post_id String @db.Uuid\n  author_id String @db.Uuid\n  parent_id String? @db.Uuid\n  content String\n  edited Boolean\n  score Int? @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author community_platform_members @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent community_platform_comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  recursive community_platform_comments[] @relation(\"recursive\")\n  community_platform_comment_snapshots community_platform_comment_snapshots[]\n  community_platform_comment_reports community_platform_comment_reports[]\n  community_platform_votes community_platform_votes[]\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([post_id, id])\n  @@unique([parent_id, id])\n  @@index([post_id, parent_id])\n  @@index([author_id, created_at])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member","admin"],"description":"Delete a comment. Only the author or an admin can delete. Guests cannot delete comments. This is a soft delete, setting deleted_at; data remains for audit/policy but is excluded from standard queries. The operation also cascades to delete all descendant (child) comments and associated votes in the thread. A 404 is returned if the comment does not exist or is already deleted. Related endpoints: PATCH (list), GET (detail), POST (create), PUT (update).","summary":"Delete a comment (soft delete, community_platform_comments table).","parameters":[{"name":"commentId","description":"Unique identifier of the comment to delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","model_name":"community_platform_comments","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Delete a comment by its unique ID, marking it as deleted via soft delete (deleted_at field set). This operation targets the community_platform_comments table and is available to the comment's author or an admin. Deletion cascades to all child comments and votes. Only authenticated users may delete comments; guests are not permitted. Attempting to delete a comment that does not exist or is already deleted returns a 404. Soft delete ensures the record remains in the DB for audit but becomes invisible to standard API queries.","path":"/communityPlatform/admin/comments/{commentId}","method":"delete","prisma_schemas":"model community_platform_comments {\n  id String @id @db.Uuid\n  post_id String @db.Uuid\n  author_id String @db.Uuid\n  parent_id String? @db.Uuid\n  content String\n  edited Boolean\n  score Int? @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  post community_platform_posts @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  author community_platform_members @relation(fields: [author_id], references: [id], onDelete: Cascade)\n  parent community_platform_comments? @relation(\"recursive\", fields: [parent_id], references: [id], onDelete: Cascade)\n  recursive community_platform_comments[] @relation(\"recursive\")\n  community_platform_comment_snapshots community_platform_comment_snapshots[]\n  community_platform_comment_reports community_platform_comment_reports[]\n  community_platform_votes community_platform_votes[]\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  community_platform_search_views community_platform_search_views[]\n  @@unique([post_id, id])\n  @@unique([parent_id, id])\n  @@index([post_id, parent_id])\n  @@index([author_id, created_at])\n  @@index([created_at])\n  @@index([content(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["member","admin"],"description":"Delete a comment. Only the author or an admin can delete. Guests cannot delete comments. This is a soft delete, setting deleted_at; data remains for audit/policy but is excluded from standard queries. The operation also cascades to delete all descendant (child) comments and associated votes in the thread. A 404 is returned if the comment does not exist or is already deleted. Related endpoints: PATCH (list), GET (detail), POST (create), PUT (update).","summary":"Delete a comment (soft delete, community_platform_comments table).","parameters":[{"name":"commentId","description":"Unique identifier of the comment to delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","model_name":"community_platform_comments","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves a paginated list of all reports that have been filed for a specific comment. The operation targets the community_platform_comment_reports table, which stores reports made by members against comment content for moderation, abuse, or policy violations. Advanced filtering, searching, and sorting across fields like report status, type, reporter, and created date are supported. The list can be filtered or paginated using the IRequest DTO, allowing for efficient review by admins or for users to view their own filed reports. Results are restricted to authorized roles (members for their own, admin for all).","path":"/communityPlatform/admin/comments/{commentId}/reports","method":"patch","prisma_schemas":"/// Primary business entity for user-initiated reports of inappropriate\n/// comments. Contains references to the reported comment, the reporting user\n/// (member), and includes reason, status, resolution, and timestamps for\n/// moderation workflows. Used for actionable moderation flows, supporting\n/// search across reports by status, reporter, and referenced comment. All\n/// reports are reviewed by admins.\n/// @namespace Comments\nmodel community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  comment community_platform_comments @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n  reporter community_platform_members @relation(fields: [reporter_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@unique([comment_id, reporter_id])\n  @@index([status])\n  @@index([reporter_id, created_at])\n  @@index([admin_id])\n}\n","description":"Retrieve all reports associated with a target comment. This operation supports advanced filtering, searching, and pagination, which is essential for moderation workflows where multiple reports may exist for a single comment. Callers can filter by status, report reason, or other metadata depending on the IRequest parameters.\n\nAccess to this API is role-restricted: admins can view all reports, while members can view only their own reports. Pagination allows efficient moderation, surfacing the most relevant or critical cases first. The response data includes summary or detailed report information, ideal for moderation UIs or report histories.\n\nError handling ensures that requests for invalid comment IDs, insufficient permissions, or access to non-owned data are rejected with appropriate error messages.","summary":"Retrieve a paginated, filterable list of reports for a specific comment","parameters":[{"name":"commentId","description":"Unique identifier for the comment whose reports should be listed","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Filter, search, and pagination parameters for comment report listing","typeName":"ICommunityPlatformCommentReport.IRequest"},"responseBody":{"description":"Page of comment report summaries matching the request parameters","typeName":"IPageICommunityPlatformCommentReport.ISummary"},"authorizationRoles":["admin","member"],"name":"index","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves a paginated list of all reports that have been filed for a specific comment. The operation targets the community_platform_comment_reports table, which stores reports made by members against comment content for moderation, abuse, or policy violations. Advanced filtering, searching, and sorting across fields like report status, type, reporter, and created date are supported. The list can be filtered or paginated using the IRequest DTO, allowing for efficient review by admins or for users to view their own filed reports. Results are restricted to authorized roles (members for their own, admin for all).","path":"/communityPlatform/member/comments/{commentId}/reports","method":"patch","prisma_schemas":"/// Primary business entity for user-initiated reports of inappropriate\n/// comments. Contains references to the reported comment, the reporting user\n/// (member), and includes reason, status, resolution, and timestamps for\n/// moderation workflows. Used for actionable moderation flows, supporting\n/// search across reports by status, reporter, and referenced comment. All\n/// reports are reviewed by admins.\n/// @namespace Comments\nmodel community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n  comment community_platform_comments @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n  reporter community_platform_members @relation(fields: [reporter_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@unique([comment_id, reporter_id])\n  @@index([status])\n  @@index([reporter_id, created_at])\n  @@index([admin_id])\n}\n","description":"Retrieve all reports associated with a target comment. This operation supports advanced filtering, searching, and pagination, which is essential for moderation workflows where multiple reports may exist for a single comment. Callers can filter by status, report reason, or other metadata depending on the IRequest parameters.\n\nAccess to this API is role-restricted: admins can view all reports, while members can view only their own reports. Pagination allows efficient moderation, surfacing the most relevant or critical cases first. The response data includes summary or detailed report information, ideal for moderation UIs or report histories.\n\nError handling ensures that requests for invalid comment IDs, insufficient permissions, or access to non-owned data are rejected with appropriate error messages.","summary":"Retrieve a paginated, filterable list of reports for a specific comment","parameters":[{"name":"commentId","description":"Unique identifier for the comment whose reports should be listed","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Filter, search, and pagination parameters for comment report listing","typeName":"ICommunityPlatformCommentReport.IRequest"},"responseBody":{"description":"Page of comment report summaries matching the request parameters","typeName":"IPageICommunityPlatformCommentReport.ISummary"},"authorizationRoles":["admin","member"],"name":"index","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves the details of a specific report for a given comment. The operation accesses the community_platform_comment_reports table, returning all fields related to a single report instance, such as type, reason, status, reporter, admin handler, creation and update timestamps, and resolution data. The API is essential for moderation workflows, allowing admins and reporting members to view the status and complete history of a moderation request. Related audit or escalation records may be available via linked APIs but are outside the direct scope of this endpoint.","path":"/communityPlatform/admin/comments/{commentId}/reports/{reportId}","method":"get","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Returns all fields for a single report instance tied to a specific comment. This operation ensures that the full lifecycle (reason, status, assigned admin, timestamps) and resolution notes are available for review. Security logic restricts access: admins can retrieve any report; members may retrieve reports they filed. The call will fail with appropriate errors for invalid IDs, lack of permission, or attempts to access unrelated resources.\n\nThis endpoint is typically used in moderation dashboards, admin appeals, and user self-service views for checking report status or dispute workflows.","summary":"Retrieve details of a specific comment report by reportId","parameters":[{"name":"commentId","description":"Identifier of the target comment for which this report applies","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"Unique ID of the comment report to retrieve","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed information about the requested comment report","typeName":"ICommunityPlatformCommentReport"},"authorizationRoles":["admin","member"],"name":"at","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves the details of a specific report for a given comment. The operation accesses the community_platform_comment_reports table, returning all fields related to a single report instance, such as type, reason, status, reporter, admin handler, creation and update timestamps, and resolution data. The API is essential for moderation workflows, allowing admins and reporting members to view the status and complete history of a moderation request. Related audit or escalation records may be available via linked APIs but are outside the direct scope of this endpoint.","path":"/communityPlatform/member/comments/{commentId}/reports/{reportId}","method":"get","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Returns all fields for a single report instance tied to a specific comment. This operation ensures that the full lifecycle (reason, status, assigned admin, timestamps) and resolution notes are available for review. Security logic restricts access: admins can retrieve any report; members may retrieve reports they filed. The call will fail with appropriate errors for invalid IDs, lack of permission, or attempts to access unrelated resources.\n\nThis endpoint is typically used in moderation dashboards, admin appeals, and user self-service views for checking report status or dispute workflows.","summary":"Retrieve details of a specific comment report by reportId","parameters":[{"name":"commentId","description":"Identifier of the target comment for which this report applies","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"Unique ID of the comment report to retrieve","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed information about the requested comment report","typeName":"ICommunityPlatformCommentReport"},"authorizationRoles":["admin","member"],"name":"at","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation allows an authenticated member to create a new report for a specific comment, typically in response to spam, abuse, or rule violations. The operation inserts a new row in the community_platform_comment_reports table, linking the reporting member to the target comment, and requires report reason and type fields. The system enforces the uniqueness constraint (one report per member per comment) and supports moderation escalation flows. Admins may also use this API via moderation tooling for testing or policy purposes.","path":"/communityPlatform/admin/comments/{commentId}/reports","method":"post","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Create a new report for a specified comment. Members can file one report per comment, specifying a report reason, type, and optional details. The system validates that duplicate reports are not allowed and ties the created report to the requesting member and comment.\n\nUpon creation, the report status is set to the initial moderation value. The response contains the created report, including assigned status and timestamps. Attempts to report nonexistent or already-deleted comments, or to file duplicate reports, return standard error messages.","summary":"Create a new report for a comment (one report per member per comment)","parameters":[{"name":"commentId","description":"Identifier of the comment being reported","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Report creation info (reason, type, details) for the comment report","typeName":"ICommunityPlatformCommentReport.ICreate"},"responseBody":{"description":"The created comment report record","typeName":"ICommunityPlatformCommentReport"},"authorizationRoles":["admin","member"],"name":"create","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows an authenticated member to create a new report for a specific comment, typically in response to spam, abuse, or rule violations. The operation inserts a new row in the community_platform_comment_reports table, linking the reporting member to the target comment, and requires report reason and type fields. The system enforces the uniqueness constraint (one report per member per comment) and supports moderation escalation flows. Admins may also use this API via moderation tooling for testing or policy purposes.","path":"/communityPlatform/member/comments/{commentId}/reports","method":"post","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Create a new report for a specified comment. Members can file one report per comment, specifying a report reason, type, and optional details. The system validates that duplicate reports are not allowed and ties the created report to the requesting member and comment.\n\nUpon creation, the report status is set to the initial moderation value. The response contains the created report, including assigned status and timestamps. Attempts to report nonexistent or already-deleted comments, or to file duplicate reports, return standard error messages.","summary":"Create a new report for a comment (one report per member per comment)","parameters":[{"name":"commentId","description":"Identifier of the comment being reported","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Report creation info (reason, type, details) for the comment report","typeName":"ICommunityPlatformCommentReport.ICreate"},"responseBody":{"description":"The created comment report record","typeName":"ICommunityPlatformCommentReport"},"authorizationRoles":["admin","member"],"name":"create","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation allows updating an existing report on a comment, typically restricted to admins or the reporting member (for editing their own report while still open). The operation targets the community_platform_comment_reports table, allowing updates to fields such as reason, status, resolution, or reassignment. All business validation rules (status transitions, field mutability, escalation state) are enforced via the IUpdate DTO. This enables moderation workflow (e.g., resolving, escalating, or annotating report outcomes).","path":"/communityPlatform/admin/comments/{commentId}/reports/{reportId}","method":"put","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Update the details or status of a given comment report. Admins may use this operation to resolve, escalate, or annotate moderation outcomes. The reporting member may, depending on business logic, edit certain fields on their own unresolved reports.\n\nAll field-level and state-transition rules are enforced. Attempts to update a report outside allowed transitions, or without proper authority, will return permission or validation errors. Operation returns the updated report.","summary":"Update an existing report for a specific comment","parameters":[{"name":"commentId","description":"Identifier of the comment whose report is updated","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"Unique ID of the report being updated","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Update info for the comment report - such as reason, status, resolution","typeName":"ICommunityPlatformCommentReport.IUpdate"},"responseBody":{"description":"Updated report with new field values","typeName":"ICommunityPlatformCommentReport"},"authorizationRoles":["admin","member"],"name":"update","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows updating an existing report on a comment, typically restricted to admins or the reporting member (for editing their own report while still open). The operation targets the community_platform_comment_reports table, allowing updates to fields such as reason, status, resolution, or reassignment. All business validation rules (status transitions, field mutability, escalation state) are enforced via the IUpdate DTO. This enables moderation workflow (e.g., resolving, escalating, or annotating report outcomes).","path":"/communityPlatform/member/comments/{commentId}/reports/{reportId}","method":"put","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Update the details or status of a given comment report. Admins may use this operation to resolve, escalate, or annotate moderation outcomes. The reporting member may, depending on business logic, edit certain fields on their own unresolved reports.\n\nAll field-level and state-transition rules are enforced. Attempts to update a report outside allowed transitions, or without proper authority, will return permission or validation errors. Operation returns the updated report.","summary":"Update an existing report for a specific comment","parameters":[{"name":"commentId","description":"Identifier of the comment whose report is updated","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"Unique ID of the report being updated","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Update info for the comment report - such as reason, status, resolution","typeName":"ICommunityPlatformCommentReport.IUpdate"},"responseBody":{"description":"Updated report with new field values","typeName":"ICommunityPlatformCommentReport"},"authorizationRoles":["admin","member"],"name":"update","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation permanently deletes a specific report for a comment from the community_platform_comment_reports table. It is restricted to members (for their own non-processed/unresolved reports) or admins for moderation actions. Business logic ensures that deleted reports cannot be recovered, and cascade deletion rules are not required since reports do not own other entities in the schema. This is a hard delete, as the community_platform_comment_reports schema does not utilize a soft delete column.","path":"/communityPlatform/admin/comments/{commentId}/reports/{reportId}","method":"delete","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Permanently delete this comment report. This operation allows either the report author (while unresolved) or an admin to delete the report from the database. The deletion is permanent and cannot be undone. Operation is transactional and will return an error for unauthorized or invalid deletion attempts.","summary":"Permanently delete this comment report","parameters":[{"name":"commentId","description":"ID of the comment to which the report is linked","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"ID of the report to delete","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin","member"],"name":"erase","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"This operation permanently deletes a specific report for a comment from the community_platform_comment_reports table. It is restricted to members (for their own non-processed/unresolved reports) or admins for moderation actions. Business logic ensures that deleted reports cannot be recovered, and cascade deletion rules are not required since reports do not own other entities in the schema. This is a hard delete, as the community_platform_comment_reports schema does not utilize a soft delete column.","path":"/communityPlatform/member/comments/{commentId}/reports/{reportId}","method":"delete","prisma_schemas":"model community_platform_comment_reports {\n  id String @id @db.Uuid\n  comment_id String @db.Uuid\n  reporter_id String @db.Uuid\n  admin_id String? @db.Uuid\n  report_reason String\n  status String\n  resolution String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  resolved_at DateTime? @db.Timestamptz\n}","description":"Permanently delete this comment report. This operation allows either the report author (while unresolved) or an admin to delete the report from the database. The deletion is permanent and cannot be undone. Operation is transactional and will return an error for unauthorized or invalid deletion attempts.","summary":"Permanently delete this comment report","parameters":[{"name":"commentId","description":"ID of the comment to which the report is linked","schema":{"type":"string","format":"uuid"}},{"name":"reportId","description":"ID of the report to delete","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin","member"],"name":"erase","model_name":"community_platform_comment_reports","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves a filtered and paginated list of all votes cast on posts or comments, supporting advanced searching and aggregation. It operates on the community_platform_votes table, which stores all user votes (upvote, downvote, neutral) associated with posts or comments. The search supports flexible filter criteria such as voter ID, post/comment ID, value, and creation date, as well as sorting and pagination. This endpoint is typically used in moderation dashboards, analytics, or user voting history views. Role-based access control allows users to view their voting history, while admins can see all voting records.","path":"/communityPlatform/admin/votes","method":"patch","prisma_schemas":"model community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","description":"Return a paginated list of votes cast by users on posts and comments. This API supports advanced filters including by voter, post/comment, vote value (up, down, neutral), and timestamp ranges for reviewing platform activity or personal voting history.\n\nAccess control permits admins to view all voting records, while members may only retrieve their own. Pagination, searching, and sorting allow efficient bulk review or individual account history. Proper error handling is provided for invalid filters or unauthorized access attempts.","summary":"Retrieve paginated, filtered vote records across posts and comments","parameters":[],"requestBody":{"description":"Advanced filter, search, and pagination criteria for votes","typeName":"ICommunityPlatformVote.IRequest"},"responseBody":{"description":"Paginated list of vote summaries matching filter/search criteria","typeName":"IPageICommunityPlatformVote.ISummary"},"authorizationRoles":["admin","member"],"name":"index","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves a filtered and paginated list of all votes cast on posts or comments, supporting advanced searching and aggregation. It operates on the community_platform_votes table, which stores all user votes (upvote, downvote, neutral) associated with posts or comments. The search supports flexible filter criteria such as voter ID, post/comment ID, value, and creation date, as well as sorting and pagination. This endpoint is typically used in moderation dashboards, analytics, or user voting history views. Role-based access control allows users to view their voting history, while admins can see all voting records.","path":"/communityPlatform/member/votes","method":"patch","prisma_schemas":"model community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","description":"Return a paginated list of votes cast by users on posts and comments. This API supports advanced filters including by voter, post/comment, vote value (up, down, neutral), and timestamp ranges for reviewing platform activity or personal voting history.\n\nAccess control permits admins to view all voting records, while members may only retrieve their own. Pagination, searching, and sorting allow efficient bulk review or individual account history. Proper error handling is provided for invalid filters or unauthorized access attempts.","summary":"Retrieve paginated, filtered vote records across posts and comments","parameters":[],"requestBody":{"description":"Advanced filter, search, and pagination criteria for votes","typeName":"ICommunityPlatformVote.IRequest"},"responseBody":{"description":"Paginated list of vote summaries matching filter/search criteria","typeName":"IPageICommunityPlatformVote.ISummary"},"authorizationRoles":["admin","member"],"name":"index","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"This operation retrieves the details of a specific voting record, by its unique voteId, from the community_platform_votes table. The returned record contains all vote fields including voter, target post or comment, vote value (1 for upvote, -1 for downvote, or 0 for neutral), and timestamps. Typical use cases include audit trails, reviewing voting behavior, or confirming vote results. Access is role-restricted: admins can see all votes; members only their own.","path":"/communityPlatform/admin/votes/{voteId}","method":"get","prisma_schemas":"model community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","description":"Returns a single voting record including full field data: who voted, the target (post or comment), vote value, and creation/update metadata. Useful for per-user or moderation review. Access is restricted by role.\n\nErrors are returned for requests with invalid or unauthorized vote IDs. Common usage includes review of individual voting actions or for platform moderation purposes.","summary":"Get detailed voting record by voteId","parameters":[{"name":"voteId","description":"The unique identifier (UUID) of the vote record","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full information of the specified vote record","typeName":"ICommunityPlatformVote"},"authorizationRoles":["admin","member"],"name":"at","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation retrieves the details of a specific voting record, by its unique voteId, from the community_platform_votes table. The returned record contains all vote fields including voter, target post or comment, vote value (1 for upvote, -1 for downvote, or 0 for neutral), and timestamps. Typical use cases include audit trails, reviewing voting behavior, or confirming vote results. Access is role-restricted: admins can see all votes; members only their own.","path":"/communityPlatform/member/votes/{voteId}","method":"get","prisma_schemas":"model community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","description":"Returns a single voting record including full field data: who voted, the target (post or comment), vote value, and creation/update metadata. Useful for per-user or moderation review. Access is restricted by role.\n\nErrors are returned for requests with invalid or unauthorized vote IDs. Common usage includes review of individual voting actions or for platform moderation purposes.","summary":"Get detailed voting record by voteId","parameters":[{"name":"voteId","description":"The unique identifier (UUID) of the vote record","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Full information of the specified vote record","typeName":"ICommunityPlatformVote"},"authorizationRoles":["admin","member"],"name":"at","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"This operation allows an authenticated member (or admin) to create a new voting record (upvote, downvote, or neutral) for a post or comment, by inserting a row into the community_platform_votes table. The system enforces uniqueness per user/target, replacing any previous vote with the newest value (i.e., users may change their vote state). Users cannot vote on their own content (enforced in business logic, not by schema). The response returns the resulting voting record, including computed value and timestamps.","path":"/communityPlatform/admin/votes","method":"post","prisma_schemas":"model community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","description":"Create or update a user's vote on a specified post or comment. Only one vote per user-target is retained; submitting a new vote overwrites any prior. The value may be 1 (upvote), -1 (downvote), or 0 (neutral/remove vote state). Voting on own content is forbidden in business logic and checked at request time.\n\nDuplicate or conflicting votes are resolved by keeping the latest state. Unauthorized or illogical attempts (e.g., voting on non-existent or own content) result in standard error responses. On success, full vote record is returned.","summary":"Create or update a vote for a post or comment","parameters":[],"requestBody":{"description":"Vote creation info: voter, target post/comment, and vote value","typeName":"ICommunityPlatformVote.ICreate"},"responseBody":{"description":"The created or updated voting record; latest state reflected","typeName":"ICommunityPlatformVote"},"authorizationRoles":["admin","member"],"name":"create","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"This operation allows an authenticated member (or admin) to create a new voting record (upvote, downvote, or neutral) for a post or comment, by inserting a row into the community_platform_votes table. The system enforces uniqueness per user/target, replacing any previous vote with the newest value (i.e., users may change their vote state). Users cannot vote on their own content (enforced in business logic, not by schema). The response returns the resulting voting record, including computed value and timestamps.","path":"/communityPlatform/member/votes","method":"post","prisma_schemas":"model community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n}","description":"Create or update a user's vote on a specified post or comment. Only one vote per user-target is retained; submitting a new vote overwrites any prior. The value may be 1 (upvote), -1 (downvote), or 0 (neutral/remove vote state). Voting on own content is forbidden in business logic and checked at request time.\n\nDuplicate or conflicting votes are resolved by keeping the latest state. Unauthorized or illogical attempts (e.g., voting on non-existent or own content) result in standard error responses. On success, full vote record is returned.","summary":"Create or update a vote for a post or comment","parameters":[],"requestBody":{"description":"Vote creation info: voter, target post/comment, and vote value","typeName":"ICommunityPlatformVote.ICreate"},"responseBody":{"description":"The created or updated voting record; latest state reflected","typeName":"ICommunityPlatformVote"},"authorizationRoles":["admin","member"],"name":"create","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Allows updating an existing vote (upvote, downvote, or none) on a post or comment. Only the user who cast the vote (or an admin) may perform this action. Enforces all voting and ownership business logic.","prisma_schemas":"/// Records each user's vote (upvote, downvote, or neutral) on either a post\n/// or a comment. Each vote is uniquely defined per user and target (post or\n/// comment); a user cannot vote more than once on a single post or comment,\n/// and cannot vote on their own content (enforced in business logic, not in\n/// schema). Either post or comment foreign key must be set (mutually\n/// exclusive, never both). Deleting a target (post/comment) or voter\n/// (member) cascades to delete votes. This model enables independent\n/// creation, update, and removal of votes, supports audit and rollback via\n/// snapshots ({@link community_platform_vote_snapshots}).\nmodel community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  voter community_platform_members @relation(fields: [voter_id], references: [id], onDelete: Cascade)\n  post community_platform_posts? @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  comment community_platform_comments? @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  @@unique([voter_id, post_id])\n  @@unique([voter_id, comment_id])\n  @@index([post_id])\n  @@index([comment_id])\n  @@index([voter_id])\n}","authorizationRoles":["member"],"description":"This operation allows a logged-in user to update their own vote on a post or comment. It accepts the unique vote ID as a path parameter, checks that the authenticated user is the owner of the vote (unless an admin override is present), and updates the vote's value to either upvote (1), downvote (-1), or none (0). The vote update is tracked with an updated_at timestamp for audit compliance and history. Appropriate business logic is enforced to prevent users from updating votes on their own content or multiple votes per target. Admin users may update votes for moderation. The changed vote value is instantly reflected in the net score and UI state.","summary":"Update a user's existing vote on a post or comment in the community platform.","path":"/communityPlatform/member/votes/{voteId}","parameters":[{"name":"voteId","description":"Unique ID of the vote to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updated vote information (vote value as 1, -1 or 0, and target identifiers).","typeName":"ICommunityPlatformVote.IUpdate"},"responseBody":{"description":"The updated vote record, including target and user info.","typeName":"ICommunityPlatformVote"},"name":"update","method":"put","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"Performs soft deletion of a user's vote on a post or comment. Accessible by the original voter or admin. Soft delete preserves the record for audit and rollback.","prisma_schemas":"/// Records each user's vote (upvote, downvote, or neutral) on either a post\n/// or a comment. Each vote is uniquely defined per user and target (post or\n/// comment); a user cannot vote more than once on a single post or comment,\n/// and cannot vote on their own content (enforced in business logic, not in\n/// schema). Either post or comment foreign key must be set (mutually\n/// exclusive, never both). Deleting a target (post/comment) or voter\n/// (member) cascades to delete votes. This model enables independent\n/// creation, update, and removal of votes, supports audit and rollback via\n/// snapshots ({@link community_platform_vote_snapshots}).\nmodel community_platform_votes {\n  id String @id @db.Uuid\n  voter_id String @db.Uuid\n  post_id String? @db.Uuid\n  comment_id String? @db.Uuid\n  value Int @db.Integer\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  voter community_platform_members @relation(fields: [voter_id], references: [id], onDelete: Cascade)\n  post community_platform_posts? @relation(fields: [post_id], references: [id], onDelete: Cascade)\n  comment community_platform_comments? @relation(fields: [comment_id], references: [id], onDelete: Cascade)\n  community_platform_vote_snapshots community_platform_vote_snapshots[]\n  @@unique([voter_id, post_id])\n  @@unique([voter_id, comment_id])\n  @@index([post_id])\n  @@index([comment_id])\n  @@index([voter_id])\n}","authorizationRoles":["member"],"description":"This operation allows an authenticated user to remove (soft-delete) their own vote on a post or comment, or for an admin to remove a user's vote as part of moderation. It uses the vote's unique ID as a path parameter, checks business rules for permission (ownership/admin), and sets the deleted_at timestamp for soft deletion. The operation is tracked in audit logs and affects the live score displayed for the target post or comment.","summary":"Soft-delete (remove) a user's vote on a post or comment.","path":"/communityPlatform/member/votes/{voteId}","parameters":[{"name":"voteId","description":"Unique ID of the vote to remove (soft delete).","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","method":"delete","model_name":"community_platform_votes","soft_delete_column":"deleted_at","authorizationRole":"member","authorizationType":null},{"specification":"List and search all admin/moderation actions performed in the community platform. Returns paginated audit records. Allows detailed query and filtering for compliance/audit.","prisma_schemas":"/// Records all administrative actions performed by admins within the\n/// platform, including create, delete, suspend, restore operations across\n/// all major entities (communities, posts, comments, users). This provides a\n/// full audit trail for moderation, enables accountability, and supports\n/// moderation escalations and investigations. References both the admin\n/// performing the action and the affected entity type and ID.\nmodel community_platform_admin_actions {\n  id String @id @db.Uuid\n  admin_id String @db.Uuid\n  action_type String\n  target_entity String\n  target_entity_id String @db.Uuid\n  reason String?\n  result String\n  created_at DateTime @db.Timestamptz\n  admin community_platform_admins @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  community_platform_appeals community_platform_appeals[]\n  @@index([admin_id, created_at])\n  @@index([target_entity, target_entity_id], map: \"community_platform_admin_actions_target_entity_target__f80f4112\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Returns a paginated, filterable list of all admin actions executed on the platform for monitoring and compliance purposes. Filtering is available by admin ID, target entity type/ID, action type, date range, and action result. Results are paginated and sorted for dashboard or audit tool consumption. This endpoint is critical for transparency and enables audits of all moderation/admin activity.","summary":"Retrieve a paginated list of admin/moderation actions with advanced filters.","path":"/communityPlatform/admin/adminActions","parameters":[],"requestBody":{"description":"Admin action search and pagination/filter parameters.","typeName":"ICommunityPlatformAdminAction.IRequest"},"responseBody":{"description":"Paginated list of admin action records matching filters and pagination.","typeName":"IPageICommunityPlatformAdminAction"},"name":"index","method":"patch","model_name":"community_platform_admin_actions","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Gets all available details for a specific admin/moderation action record. Used within admin dashboards and investigations.","prisma_schemas":"/// Records all administrative actions performed by admins within the\n/// platform, including create, delete, suspend, restore operations across\n/// all major entities (communities, posts, comments, users). This provides a\n/// full audit trail for moderation, enables accountability, and supports\n/// moderation escalations and investigations. References both the admin\n/// performing the action and the affected entity type and ID.\nmodel community_platform_admin_actions {\n  id String @id @db.Uuid\n  admin_id String @db.Uuid\n  action_type String\n  target_entity String\n  target_entity_id String @db.Uuid\n  reason String?\n  result String\n  created_at DateTime @db.Timestamptz\n  admin community_platform_admins @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  community_platform_appeals community_platform_appeals[]\n  @@index([admin_id, created_at])\n  @@index([target_entity, target_entity_id], map: \"community_platform_admin_actions_target_entity_target__f80f4112\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Fetch all available details regarding a specific admin/moderation action for auditing or dispute review. Administrators can examine the action type, affected entity, rationale, and outcome, supporting regulatory and operational compliance. The operation uses the action's unique ID and enforces that only admin accounts can retrieve this sensitive audit data.","summary":"Get details for a specific admin/moderation action by ID.","path":"/communityPlatform/admin/adminActions/{adminActionId}","parameters":[{"name":"adminActionId","description":"Unique ID of the admin action record to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Complete details for the requested admin/moderation action.","typeName":"ICommunityPlatformAdminAction"},"name":"at","method":"get","model_name":"community_platform_admin_actions","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Creates a new administrative action record for audit and moderation purposes. Only admin users can perform this operation.","prisma_schemas":"/// Records all administrative actions performed by admins within the\n/// platform, including create, delete, suspend, restore operations across\n/// all major entities (communities, posts, comments, users). This provides a\n/// full audit trail for moderation, enables accountability, and supports\n/// moderation escalations and investigations. References both the admin\n/// performing the action and the affected entity type and ID.\nmodel community_platform_admin_actions {\n  id String @id @db.Uuid\n  admin_id String @db.Uuid\n  action_type String\n  target_entity String\n  target_entity_id String @db.Uuid\n  reason String?\n  result String\n  created_at DateTime @db.Timestamptz\n  admin community_platform_admins @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  community_platform_appeals community_platform_appeals[]\n  @@index([admin_id, created_at])\n  @@index([target_entity, target_entity_id], map: \"community_platform_admin_actions_target_entity_target__f80f4112\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Logs a new administrative or moderation action to support full audit trails and regulatory transparency. Admin users must supply the action type, affected business entity and ID, rationale, and outcome. The operation ensures all necessary relationships are respected, and audit information is attached, supporting both business reporting and moderation compliance. Only admin users can submit such records.","summary":"Create a new admin/moderation action in the platform's audit trails.","path":"/communityPlatform/admin/adminActions","parameters":[],"requestBody":{"description":"Information required to create a new admin/moderation action record.","typeName":"ICommunityPlatformAdminAction.ICreate"},"responseBody":{"description":"The created admin/moderation action record.","typeName":"ICommunityPlatformAdminAction"},"name":"create","method":"post","model_name":"community_platform_admin_actions","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Updates an existing admin action record. Used for completion, modification, or clarification of previously logged actions. Admin-only access.","prisma_schemas":"/// Records all administrative actions performed by admins within the\n/// platform, including create, delete, suspend, restore operations across\n/// all major entities (communities, posts, comments, users). This provides a\n/// full audit trail for moderation, enables accountability, and supports\n/// moderation escalations and investigations. References both the admin\n/// performing the action and the affected entity type and ID.\nmodel community_platform_admin_actions {\n  id String @id @db.Uuid\n  admin_id String @db.Uuid\n  action_type String\n  target_entity String\n  target_entity_id String @db.Uuid\n  reason String?\n  result String\n  created_at DateTime @db.Timestamptz\n  admin community_platform_admins @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  community_platform_appeals community_platform_appeals[]\n  @@index([admin_id, created_at])\n  @@index([target_entity, target_entity_id], map: \"community_platform_admin_actions_target_entity_target__f80f4112\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Allows updating an existing admin action record, such as supplying additional resolution notes or revising the moderation rationale. Used by admins to ensure audit records are accurate, complete, and reflect the real resolution to moderation cases. Admins may update only records they are responsible for or have permission to modify. All updates are audited and appended to the compliance trail.","summary":"Update an existing admin/moderation action record by ID.","path":"/communityPlatform/admin/adminActions/{adminActionId}","parameters":[{"name":"adminActionId","description":"Unique ID of the admin/moderation action record to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updated information for the admin/moderation action record.","typeName":"ICommunityPlatformAdminAction.IUpdate"},"responseBody":{"description":"The updated admin/moderation action record.","typeName":"ICommunityPlatformAdminAction"},"name":"update","method":"put","model_name":"community_platform_admin_actions","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Deletes an admin/moderation action record (hard delete from the audit log). Use with extreme caution and accountability. Restricted to audit remediation/super-admin scenarios.","prisma_schemas":"/// Records all administrative actions performed by admins within the\n/// platform, including create, delete, suspend, restore operations across\n/// all major entities (communities, posts, comments, users). This provides a\n/// full audit trail for moderation, enables accountability, and supports\n/// moderation escalations and investigations. References both the admin\n/// performing the action and the affected entity type and ID.\nmodel community_platform_admin_actions {\n  id String @id @db.Uuid\n  admin_id String @db.Uuid\n  action_type String\n  target_entity String\n  target_entity_id String @db.Uuid\n  reason String?\n  result String\n  created_at DateTime @db.Timestamptz\n  admin community_platform_admins @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  community_platform_appeals community_platform_appeals[]\n  @@index([admin_id, created_at])\n  @@index([target_entity, target_entity_id], map: \"community_platform_admin_actions_target_entity_target__f80f4112\")\n  @@index([reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Removes an existing admin action record from the audit log. This is intended for critical error correction, audit remediation, or appeal scenarios only. Super-admin or designated audit staff access is required under strict business rules to prevent tampering. This action is logged and deeply reviewed for compliance reasons.","summary":"Hard-delete an admin/moderation action from the audit log.","path":"/communityPlatform/admin/adminActions/{adminActionId}","parameters":[{"name":"adminActionId","description":"Unique ID of the admin action record to delete.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"name":"erase","method":"delete","model_name":"community_platform_admin_actions","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"List/search moderation and admin audit logs for all business and compliance events. With filtering, sorting, and pagination.","prisma_schemas":"/// Comprehensive append-only audit trail capturing all critical moderation,\n/// escalation, and administrative actions for compliance and traceability.\n/// Stores cross-entity context, responsible actors (admin/member), JSON\n/// payloads of action metadata, and outcome. This table provides immutable\n/// historical records for all business-sensitive moderation and admin\n/// events. Used for forensic and regulatory processes.\nmodel community_platform_audit_logs {\n  id String @id @db.Uuid\n  admin_id String? @db.Uuid\n  member_id String? @db.Uuid\n  event_type String\n  entity_type String\n  entity_id String @db.Uuid\n  metadata_json String?\n  result String\n  created_at DateTime @db.Timestamptz\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  member community_platform_members? @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  @@index([member_id])\n  @@index([admin_id, created_at])\n  @@index([entity_type, entity_id])\n  @@index([event_type, created_at])\n  @@index([metadata_json(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","authorizationRoles":["admin"],"description":"Returns a paginated, filterable list of all audit logs covering moderation, admin, and business-sensitive events. Filtering parameters and pagination enable incident review for compliance, business reporting, and regulatory audits. Each entry links to both admin and member where relevant, as well as impacted entities. Used by forensic and compliance staff to examine the full trace of platform actions.","summary":"Paginated search of moderation and admin audit logs for compliance review.","path":"/communityPlatform/admin/auditLogs","parameters":[],"requestBody":{"description":"Filter and pagination criteria for searching moderation/admin audit logs.","typeName":"ICommunityPlatformAuditLog.IRequest"},"responseBody":{"description":"Paginated audit log entry records matching search/filter criteria.","typeName":"IPageICommunityPlatformAuditLog"},"name":"index","method":"patch","model_name":"community_platform_audit_logs","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Fetch detailed information for a specific audit log record using its unique identifier. This operation targets the community_platform_audit_logs table in the Prisma schema, which stores audit trail records for all moderation, escalation, and administrative events. This endpoint retrieves all fields from the audit log record corresponding to the given auditLogId, allowing admins and security auditors to view the exact metadata, event context, and outcome for a single event. This operation is used as part of the detailed audit review workflow and supports investigation, compliance, and forensic analysis.","path":"/communityPlatform/admin/auditLogs/{auditLogId}","method":"get","prisma_schemas":"model community_platform_audit_logs {\n  id String @id @db.Uuid\n  admin_id String? @db.Uuid\n  member_id String? @db.Uuid\n  event_type String\n  entity_type String\n  entity_id String @db.Uuid\n  metadata_json String?\n  result String\n  created_at DateTime @db.Timestamptz\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  member community_platform_members? @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  @@index([member_id])\n  @@index([admin_id, created_at])\n  @@index([entity_type, entity_id])\n  @@index([event_type, created_at])\n  @@index([metadata_json(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"This operation retrieves a full audit log record by its unique identifier. The audit log includes details such as the admin or member involved, the type of event (e.g., admin_action, escalation, data_access), the entity type and ID impacted, complete metadata in JSON format, the result of the action, and the timestamp. Audit logs are read-only and not user-editable. Access to this endpoint is restricted to admin users for purposes of compliance, historical traceability, and legal audit obligations. Related operations include listing audit logs for a date range and fetching all actions taken by a specific admin or on a specific entity. Care must be taken to ensure sensitive metadata is handled according to policy.","summary":"Retrieve a community platform audit log entry by its ID from the audit log table.","parameters":[{"name":"auditLogId","description":"Unique identifier of the target audit log entry to fetch.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed audit log information for the specified event, including event details, initiator, entity involved, metadata, result, and timestamp.","typeName":"ICommunityPlatformAuditLog"},"authorizationRoles":["admin"],"name":"at","model_name":"community_platform_audit_logs","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Search and filter member-initiated appeals for moderation/admin actions. This targets the community_platform_appeals table, which lets members appeal administrative actions against them or their content. The endpoint provides pagination, advanced filtering by status, member, admin action ID, full-text search of decision notes, and sorting. Designed for both admins (to process and review appeals) and members (to track their own). Used for dispute resolution, moderation escalations, and process accountability.","path":"/communityPlatform/admin/appeals","method":"patch","prisma_schemas":"model community_platform_appeals {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  admin_action_id String @db.Uuid\n  appeal_status String\n  decision_reason String?\n  admin_id String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  adminAction community_platform_admin_actions @relation(fields: [admin_action_id], references: [id], onDelete: Cascade)\n  @@index([member_id, created_at])\n  @@index([admin_action_id])\n  @@index([appeal_status, updated_at])\n  @@index([decision_reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Retrieve a paginated, filterable list of moderation or admin action appeals. Members may view their own appeals, while admins have access to all appeals for processing, review, and analytics. Supports filtering by appeal status (submitted, under_review, resolved, rejected), member, admin, admin action, and decision reason text. Used to administer and process appeals workflows, track appeal status, and support transparency in moderation. Includes support for pagination, sorting by updated_at or created_at, and searching by text in decision rationale. Tied closely to the admin/moderation subsystem, and integrated into the main dispute mediation flow.","summary":"Search and retrieve a paginated, filterable list of moderation/admin appeals.","parameters":[],"requestBody":{"description":"Request parameters specifying search filters (status, member, admin), text query, pagination, and sorting model for searching moderation/admin appeals.","typeName":"ICommunityPlatformAppeal.IRequest"},"responseBody":{"description":"Paginated list of appeal summary entities matching query/filter, with status, rationale, member/admin references, and metadata.","typeName":"IPageICommunityPlatformAppeal.ISummary"},"authorizationRoles":["admin"],"name":"index","model_name":"community_platform_appeals","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Fetch detailed information about a specific appeal record based on its unique identifier. This operation is based on the community_platform_appeals table, which supports tracking and resolution of appeals filed by members regarding moderation or admin actions. Returns all details including references to the appealed admin action, appeal status, rationale, recorded decisions, and involved parties. Used by admins and (own record only) members as part of the dispute/appeal transparency and tracking workflow.","path":"/communityPlatform/admin/appeals/{appealId}","method":"get","prisma_schemas":"model community_platform_appeals {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  admin_action_id String @db.Uuid\n  appeal_status String\n  decision_reason String?\n  admin_id String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  adminAction community_platform_admin_actions @relation(fields: [admin_action_id], references: [id], onDelete: Cascade)\n  @@index([member_id, created_at])\n  @@index([admin_action_id])\n  @@index([appeal_status, updated_at])\n  @@index([decision_reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Retrieve a detailed record of a specific moderation/admin appeal including its status, rationale, related admin action, decision reasoning, and the full update and creation history. May be used by members (if they are the appellant) and by admins (for all appeals) to track and resolve issues arising from moderation or admin actions. Ensures transparency, due process, and auditability in the dispute management workflow. Responds with all fields from the corresponding appeals table entry.","summary":"Retrieve a single moderation/admin appeal record by ID.","parameters":[{"name":"appealId","description":"Unique identifier of the appeal to retrieve.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Detailed appeal record for specified ID, including all appeal event data, admin action reference, appellant, and status.","typeName":"ICommunityPlatformAppeal"},"authorizationRoles":["admin"],"name":"at","model_name":"community_platform_appeals","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Create a new appeal record for a moderation/admin action, allowing a member to request review of an admin's decision. Operates on the community_platform_appeals table. Requires key details: member initiating appeal, referenced admin action ID, initial status, optional rationale. On success, entry is saved for admin review and further processing. This operation is part of the formal appeals process, tied to the moderation and dispute review workflow. Only members may create appeals regarding actions that impact them; admins cannot file appeals here.","path":"/communityPlatform/member/appeals","method":"post","prisma_schemas":"model community_platform_appeals {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  admin_action_id String @db.Uuid\n  appeal_status String\n  decision_reason String?\n  admin_id String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  adminAction community_platform_admin_actions @relation(fields: [admin_action_id], references: [id], onDelete: Cascade)\n  @@index([member_id, created_at])\n  @@index([admin_action_id])\n  @@index([appeal_status, updated_at])\n  @@index([decision_reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Create a new appeal on behalf of a member against a specific admin action. The new appeal includes references to the member, the admin action record, the appeal status (e.g., 'submitted'), and initial rationale if provided. After the appeal is created, it enters the admin review workflow for handling and resolution. Members may file appeals for actions taken against their own accounts or content, and status is initially set to a submitted or pending value. Subsequent updates/processes are handled via moderation workflow.","summary":"Create a moderation/admin appeal for a specific admin action on behalf of a member.","parameters":[],"requestBody":{"description":"Appeal creation data: member ID, referenced admin action ID, status, and optional rationale/notes.","typeName":"ICommunityPlatformAppeal.ICreate"},"responseBody":{"description":"The created appeal entity, including all input data plus system metadata (IDs, timestamps).","typeName":"ICommunityPlatformAppeal"},"authorizationRoles":["member"],"name":"create","model_name":"community_platform_appeals","soft_delete_column":null,"authorizationRole":"member","authorizationType":null},{"specification":"Update the details of an existing appeal, such as changing its status (e.g., to under_review, resolved, rejected), providing decision reasoning, or associating an admin handler. This operation works upon the community_platform_appeals table and requires the unique appeal identifier in the path. Only authorized parties (typically admins) may perform updates; standard members may not modify appeals except via filing new information for review. The endpoint is an essential part of the moderation/process tracking workflow, ensuring up-to-date appeal information. Updates are audit-trailed and support comprehensive tracking of dispute resolutions.","path":"/communityPlatform/admin/appeals/{appealId}","method":"put","prisma_schemas":"model community_platform_appeals {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  admin_action_id String @db.Uuid\n  appeal_status String\n  decision_reason String?\n  admin_id String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  adminAction community_platform_admin_actions @relation(fields: [admin_action_id], references: [id], onDelete: Cascade)\n  @@index([member_id, created_at])\n  @@index([admin_action_id])\n  @@index([appeal_status, updated_at])\n  @@index([decision_reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Modify or update a moderation/admin appeal record, identified by a unique appeal ID. Updates supported include changing the appeal status, assigning an admin reviewer, and adding or updating the admin's decision rationale. This operation is permissioned to admins as part of the dispute/appeal workflow. Each update is fully audit-logged, and only authorized changes by appropriate roles are permitted. The operation supports business process adherence, dispute transparency, and appeal closure/finality.","summary":"Update an existing moderation/admin appeal record by ID.","parameters":[{"name":"appealId","description":"Unique identifier of the appeal to update.","schema":{"type":"string","format":"uuid"}}],"requestBody":{"description":"Updated fields for the appeal record, including status, assigned admin, rationale, or other updatable fields.","typeName":"ICommunityPlatformAppeal.IUpdate"},"responseBody":{"description":"Updated appeal record including all new field values and metadata.","typeName":"ICommunityPlatformAppeal"},"authorizationRoles":["admin"],"name":"update","model_name":"community_platform_appeals","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Erase (hard delete) an appeal record by its unique identifier. Removes the corresponding row from the community_platform_appeals table completely—used for appeals that were invalid, erroneous, or withdrawn. This operation is restricted to admins for moderation/compliance reasons. Appeals should generally be kept for audit, so use is limited to clear errors or compliance-mandated destruction. Operation is NOT a soft delete; no deleted_at column is present; the row is wiped from storage. This is a dangerous/destructive operation—always double check intent!","path":"/communityPlatform/admin/appeals/{appealId}","method":"delete","prisma_schemas":"model community_platform_appeals {\n  id String @id @db.Uuid\n  member_id String @db.Uuid\n  admin_action_id String @db.Uuid\n  appeal_status String\n  decision_reason String?\n  admin_id String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  member community_platform_members @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  adminAction community_platform_admin_actions @relation(fields: [admin_action_id], references: [id], onDelete: Cascade)\n  @@index([member_id, created_at])\n  @@index([admin_action_id])\n  @@index([appeal_status, updated_at])\n  @@index([decision_reason(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Permanently remove an appeal record by its unique ID. This operation is reserved for appeals that were filed in error, invalid, withdrawn, or need to be removed for compliance reasons. No recovery is possible—this directly deletes the entry from storage. Admin permissions are strictly enforced. It is recommended to maintain logs of erasures for compliance and historic reference purposes.","summary":"Permanently erase a moderation/admin appeal by ID.","parameters":[{"name":"appealId","description":"Unique identifier of the appeal to erase.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":null,"authorizationRoles":["admin"],"name":"erase","model_name":"community_platform_appeals","soft_delete_column":null,"authorizationRole":"admin","authorizationType":null},{"specification":"Search and filter search query logs for analytical or audit purposes. This endpoint operates over the community_platform_search_queries table, which records every search event (query string, performer, context, entity searched). The operation is used for moderation, abuse analysis, user analytics, and system monitoring—not user-facing functionality. Access is restricted to admins, and supports pagination, advanced filtering, sorting by performed_at, query text, performer (member/admin ID), and search type. Designed for log/audit usage, not user business flows.","path":"/communityPlatform/admin/search/queries","method":"patch","prisma_schemas":"model community_platform_search_queries {\n  id String @id @db.Uuid\n  member_id String? @db.Uuid\n  admin_id String? @db.Uuid\n  query_text String\n  search_type String\n  performed_at DateTime @db.Timestamptz\n  context String?\n  ip String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@index([admin_id])\n  @@index([member_id, performed_at])\n  @@index([query_text, search_type])\n  @@index([performed_at])\n  @@index([query_text(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Retrieve a paginated, filterable list of search query logs. Results may be filtered by date/time, performer (member/admin), IP/context, query text (full-text search), search_type (post/community/comment), and sorted by performed_at or query. Used for auditing, investigation, trend analysis, and abuse/compliance reporting. Sensitive endpoint, not exposed to regular users. Pagination and advanced query support required for high-volume logs. May be integrated with system dashboard analytics.","summary":"Search and retrieve a paginated/filterable list of search query logs (admin only).","parameters":[],"requestBody":{"description":"Search filters, pagination, sorting, and advanced query parameters for search query log retrieval.","typeName":"ICommunityPlatformSearchQuery.IRequest"},"responseBody":{"description":"Paginated list of search query log summary objects matching the query/filter for auditing.","typeName":"IPageICommunityPlatformSearchQuery.ISummary"},"authorizationRoles":["admin"],"name":"index","model_name":"community_platform_search_queries","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null},{"specification":"Fetch full details of a specific search query log entry given its unique identifier. This endpoint interacts with the community_platform_search_queries table, which stores all search events for user/admin/guest analytics and auditing. Provides the complete search query record including user/admin ID, search text, search type (e.g. post/community/comment), context, performer IP if recorded, and timestamps. Utilized by admins or auditors as part of user behavior monitoring, investigation, and compliance reporting flows. Log records are system-generated only, not user-editable.","path":"/communityPlatform/admin/search/queries/{searchQueryId}","method":"get","prisma_schemas":"model community_platform_search_queries {\n  id String @id @db.Uuid\n  member_id String? @db.Uuid\n  admin_id String? @db.Uuid\n  query_text String\n  search_type String\n  performed_at DateTime @db.Timestamptz\n  context String?\n  ip String?\n  created_at DateTime @db.Timestamptz\n  updated_at DateTime @db.Timestamptz\n  deleted_at DateTime? @db.Timestamptz\n  member community_platform_members? @relation(fields: [member_id], references: [id], onDelete: Cascade)\n  admin community_platform_admins? @relation(fields: [admin_id], references: [id], onDelete: Cascade)\n  @@index([admin_id])\n  @@index([member_id, performed_at])\n  @@index([query_text, search_type])\n  @@index([performed_at])\n  @@index([query_text(ops: raw(\"gin_trgm_ops\"))], type: Gin)\n}","description":"Retrieve the complete event record for a single search query log, specified by its unique ID. Includes all event metadata: searcher (member/admin), search text, search type, context, IP, and full timing/audit data. This operation is primarily used for admin review, compliance, abuse investigations, and log forensics. As search queries are system-generated, this endpoint is not for regular user business needs, and access is restricted to appropriate roles. Connected reporting/analytics endpoints may aggregate this data for dashboards.","summary":"Get a specific search query log record by its ID (admin only).","parameters":[{"name":"searchQueryId","description":"Unique identifier of the search query log record.","schema":{"type":"string","format":"uuid"}}],"requestBody":null,"responseBody":{"description":"Complete detail for the search query log entry, including all query fields, metadata, timestamps, and performer references.","typeName":"ICommunityPlatformSearchQuery"},"authorizationRoles":["admin"],"name":"at","model_name":"community_platform_search_queries","soft_delete_column":"deleted_at","authorizationRole":"admin","authorizationType":null}],"components":{"authorization":[{"name":"guest","description":"A non-authenticated user. Guests can read all public content, browse communities, posts, and comments but cannot post, comment, vote, join communities, or create content. Used for read-only access and exploration.","kind":"guest"},{"name":"member","description":"A registered and logged-in user. Members can create, edit, and delete their own posts and comments, vote on others' posts and comments, join/leave communities, and create new sub-communities. Membership is required for all content interaction except reading.","kind":"member"},{"name":"admin","description":"A privileged user with extended system powers. Admins can delete any post, comment, or community, manage user accounts, resolve disputes, and moderate community-wide rules violations. Has all permissions of member plus global management rights.","kind":"admin"}],"schemas":{"IAuthorizationToken":{"type":"object","properties":{"access":{"type":"string","description":"JWT access token for authenticated requests.\n\nThis token should be included in the Authorization header for subsequent\nauthenticated API requests as `Bearer {token}`."},"refresh":{"type":"string","description":"Refresh token for obtaining new access tokens.\n\nThis token can be used to request new access tokens when the current access\ntoken expires, extending the user's session."},"expired_at":{"type":"string","format":"date-time","description":"Access token expiration timestamp.\n\nISO 8601 date-time string indicating when the access token will expire and\ncan no longer be used for authentication."},"refreshable_until":{"type":"string","format":"date-time","description":"Refresh token expiration timestamp.\n\nISO 8601 date-time string indicating the latest time until which the\nrefresh token can be used to obtain new access tokens."}},"required":["access","refresh","expired_at","refreshable_until"],"description":"Authorization token response structure.\n\nThis interface defines the structure of the authorization token response\nreturned after successful user authentication. It contains both access and\nrefresh tokens along with their expiration information.\n\nThis token structure is automatically included in API schemas when the system\ndetects authorization roles in the requirements analysis phase. It provides a\nstandard format for JWT-based authentication across the generated backend\napplications."},"ICommunityPlatformGuest.ICreate":{"type":"object","properties":{},"description":"Guest account creation requires no client-side payload. The backend will generate a new guest identity, tracking only device/session info.","required":[]},"ICommunityPlatformGuest.IRefreshRequest":{"type":"object","properties":{"refresh_token":{"type":"string","description":"The refresh token previously issued to the guest for session renewal. Must be a valid JWT string."}},"required":["refresh_token"],"description":"Payload with refresh_token to renew a guest (anonymous) session."},"ICommunityPlatformGuest.IAuthorized":{"type":"object","properties":{"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"guest":{"$ref":"#/components/schemas/ICommunityPlatformGuest"}},"required":["token","guest"],"description":"Response object for guest session authorization, returning JWT tokens and guest identity info."},"ICommunityPlatformGuest":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique persistent identifier for guest analytics record."},"guest_identifier":{"type":"string","description":"Pseudonymous browser/user identifier used for analytics (cookie/fp)."},"ip_address":{"oneOf":[{"type":"string","description":"IP address (may be null, pseudo-anonymized)."},{"type":"null"}],"description":"IP address (may be null, pseudo-anonymized)."},"user_agent":{"oneOf":[{"type":"string","description":"Browser or device user agent info (may be null)."},{"type":"null"}],"description":"Browser or device user agent info (may be null)."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp for guest entity."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"If set, time when guest was removed from analytics."},{"type":"null"}],"description":"If set, time when guest was removed from analytics."}},"required":["id","guest_identifier","created_at"],"description":"External guest/anonymous session for analytics/audit. Pseudonymous persistent identifier, IP, UA, and timestamps. Used for non-authenticated interaction logs. Public business APIs do not expose PII, only statistical references. Used internally for analytics and to power read-only guest flows. Guests cannot create content, join, or interact beyond viewing public site data. No email, password, or personal info. Retained as long as required by analytics retention policy."},"ICommunityPlatformMember.ICreate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Unique email address for the member. Must not already be in use. Required."},"password":{"type":"string","description":"User's chosen password. Must be minimum 8 characters, including at least one letter and one number. Will be securely hashed server-side."},"display_name":{"oneOf":[{"type":"string","description":"Optional alias or display name (max 32 chars). Defaults to 'Anonymous' if not set."},{"type":"null","description":"Optional alias or display name (max 32 chars). Defaults to 'Anonymous' if not set."}],"description":"Optional alias or display name (max 32 chars). Defaults to 'Anonymous' if not set."}},"required":["email","password"],"description":"Payload for creating a new member (user) identity. Client must provide a unique email and password. Display name is optional."},"ICommunityPlatformMember.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Registered email address for login."},"password":{"type":"string","description":"Password for authentication (never stored or echoed on server)."}},"required":["email","password"],"description":"Login credentials for member authentication. Email and password are both required."},"ICommunityPlatformMember.IRefreshRequest":{"type":"object","properties":{"refresh_token":{"type":"string","description":"Member's JWT refresh token; must be valid and within expiration."}},"required":["refresh_token"],"description":"Payload for member session renewal via JWT refresh_token."},"ICommunityPlatformMember.IAuthorized":{"type":"object","properties":{"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"member":{"$ref":"#/components/schemas/ICommunityPlatformMember"}},"required":["token","member"],"description":"Response object for member session and login/registration. Returns issued tokens and full member identity (excluding password/hash)."},"ICommunityPlatformMember":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"System-generated unique identifier for the member."},"email":{"type":"string","format":"email","description":"The email address of the member, used as the login/account identifier."},"display_name":{"oneOf":[{"type":"string","description":"Preferred display name for the user, up to 32 chars. Used as author name in posts/comments. If null, displays as 'Anonymous'."},{"type":"null","description":"Preferred display name for the user, up to 32 chars. Used as author name in posts/comments. If null, displays as 'Anonymous'."}],"description":"Preferred display name for the user, up to 32 chars. Used as author name in posts/comments. If null, displays as 'Anonymous'."},"is_active":{"type":"boolean","description":"Active account flag for business logic. Set to false if banned/inactive/deleted."},"last_login_at":{"oneOf":[{"type":"string","format":"date-time","description":"Most recent successful login timestamp, updated on every login."},{"type":"null","format":"date-time","description":"Most recent successful login timestamp, updated on every login."}],"description":"Most recent successful login timestamp, updated on every login."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when member account was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of member account update/metadata change."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Timestamp when account was soft-deleted. Null for normal accounts."},{"type":"null","format":"date-time","description":"Timestamp when account was soft-deleted. Null for normal accounts."}],"description":"Timestamp when account was soft-deleted. Null for normal accounts."}},"required":["id","email","is_active","created_at","updated_at"],"description":"Represents a registered member (user) identity for the community platform, excluding password-related fields."},"ICommunityPlatformMember.IPasswordResetInitiate":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"The member's email address. Must be provided to initiate the password reset workflow."}},"required":["email"],"description":"Request payload for initiating a member password reset. Provides the email address; no indication given as to whether it is found in the system, for security."},"ICommunityPlatformMember.IPasswordResetInitiateResponse":{"type":"object","properties":{"status":{"type":"string","description":"A status message indicating that the password reset process was initiated.\n\nThis field confirms that the reset workflow has started and does not leak account existence."}},"required":["status"],"description":"Status message confirming initiation of the member password reset workflow.\n\nReturned after a successful call to the password reset initiation endpoint."},"ICommunityPlatformMember.IPasswordResetComplete":{"type":"object","properties":{"reset_token":{"type":"string","description":"The one-time use secure password reset token sent to the member's email address during the reset initiation step.\n\nRequired for verifying and completing the password reset process."},"new_password":{"type":"string","description":"The new password supplied by the member for account recovery.\nMust meet system password complexity rules (e.g., at least 8 characters, mix of letters/numbers).\nThis password is never stored directly, only as a secure hash."}},"required":["reset_token","new_password"],"description":"Input for completing a member's password reset using the provided token and new password.\n\nUsed by the password reset completion endpoint for members."},"ICommunityPlatformMember.IPasswordResetCompleteResponse":{"type":"object","properties":{"status":{"type":"string","description":"A status message confirming the completion of the password reset process.\n\nIndicates that the password has been successfully changed and the member must re-authenticate."}},"required":["status"],"description":"Response body for successful completion of a member password reset.\n\nConfirms to the user that their password is now changed and ready for login."},"ICommunityPlatformAdmin.IJoin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Email address for the admin account. Must be unique.\nUsed as the login identifier and for system notifications."},"password":{"type":"string","description":"Raw password for the new admin account. Will be hashed for storage.\nMust meet platform password complexity requirements."},"display_name":{"oneOf":[{"type":"string","maxLength":64,"description":"Optional administrative display name for audit logs/UI.\nDefaults to the email account if not provided."},{"type":"null"}],"description":"Optional administrative display name for audit logs/UI.\nDefaults to the email account if not provided."}},"required":["email","password"],"description":"Body for creating/registering a new admin account.\n\nEmail and password fields are required; display_name is optional."},"ICommunityPlatformAdmin.IAuthorized":{"type":"object","properties":{"token":{"$ref":"#/components/schemas/IAuthorizationToken","description":"JWT token information for authentication"},"admin":{"$ref":"#/components/schemas/ICommunityPlatformAdmin","description":"The admin profile/entity associated with the session.\nIncludes ID, email, display name, status/privileges."}},"required":["token","admin"],"description":"Authorization response type for admin endpoints after join/login/refresh.\n\nContains token (JWT access/refresh) and the authenticated admin entity."},"ICommunityPlatformAdmin.ILogin":{"type":"object","properties":{"email":{"type":"string","format":"email","description":"Admin account email address used for login.\nMust match an active registered admin in the system."},"password":{"type":"string","description":"Raw password for admin authentication. Handled securely server-side."}},"required":["email","password"],"description":"Request body for admin authentication (login) endpoint.\n\nRequires both email and password fields."},"ICommunityPlatformAdmin.IRefresh":{"type":"object","properties":{"refresh_token":{"type":"string","description":"A valid, unexpired refresh_token associated with a prior admin session.\n\nRequired to obtain new access/refresh JWT tokens on refresh endpoint."}},"required":["refresh_token"],"description":"Request body for admin JWT token refresh operation.\n\nContains only the required refresh_token."},"ICommunityPlatformCategory.IRequest":{"type":"object","properties":{"search":{"type":"string","description":"Search term to filter by name or code."},"code":{"type":"string","description":"Exact code filter (optional)."},"name":{"type":"string","description":"Exact name filter (optional)."},"page":{"type":"integer","description":"Page number for pagination.","minimum":1},"limit":{"type":"integer","description":"Records per page (default 20, max 100).","minimum":1},"orderBy":{"oneOf":[{"const":"created_at","description":"Field to order by."},{"const":"name","description":"Field to order by."},{"const":"code","description":"Field to order by."}],"description":"Field to order by."},"direction":{"oneOf":[{"const":"asc","description":"Sort direction."},{"const":"desc","description":"Sort direction."}],"description":"Sort direction."}},"required":[],"description":"Request filter object for searching and paginating categories."},"ICommunityPlatformAdmin":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"UUID primary key for the admin account."},"email":{"type":"string","format":"email","description":"Unique email for admin authentication."},"display_name":{"oneOf":[{"type":"string","maxLength":64,"description":"Display name for audit logs and admin UIs. Optional."},{"type":"null"}],"description":"Display name for audit logs and admin UIs. Optional."},"is_active":{"type":"boolean","description":"Flag indicating if the admin account is currently active."},"is_super_admin":{"type":"boolean","description":"True if this account has super-admin privileges; can manage other admins."},"last_login_at":{"oneOf":[{"type":"string","format":"date-time","description":"Timestamp of the last successful login to the admin account.\nNull if never logged in."},{"type":"null"}],"description":"Timestamp of the last successful login to the admin account.\nNull if never logged in."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the admin account was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of the most recent modification of this admin account."}},"required":["id","email","is_active","is_super_admin","created_at","updated_at"],"description":"Admin user profile entity for privileged platform access.\n\nIncludes audit fields, privilege level, and personal information."},"ICommunityPlatformCategory":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"The unique identifier for the community category. UUID generated by the system."},"code":{"type":"string","description":"A unique code or slug identifying the category, typically slug-form (e.g., 'tech_programming'). Used for lookup and API filtering. Must be unique system-wide."},"name":{"type":"string","description":"Human-friendly display name for the category (e.g., 'Tech & Programming'). Must be unique and required for UI lists and selection."},"description":{"oneOf":[{"type":"string","description":"Optional long-form description of the category (max 200 chars). Provides UI helpers or admin documentation. May be null."},{"type":"null","description":"Optional long-form description of the category (max 200 chars). Provides UI helpers or admin documentation. May be null."}],"description":"Optional long-form description of the category (max 200 chars). Provides UI helpers or admin documentation. May be null."},"created_at":{"type":"string","format":"date-time","description":"Timestamp for when the category was created (ISO 8601). Set by the database."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp for most recent category update (ISO 8601). Set on create and each write."}},"required":["id","code","name","created_at","updated_at"],"description":"Community category entity reference for classifying sub-communities. Mirrors Prisma model community_platform_categories. Contains unique code, name, description, and audit fields."},"ICommunityPlatformCategory.ICreate":{"type":"object","properties":{"code":{"type":"string","description":"Slug or code for category. Unique and required (e.g., 'movies_tv')."},"name":{"type":"string","description":"Display label for UI selection. Required and unique."},"description":{"oneOf":[{"type":"string","description":"Optional category description for UI or admin use."},{"type":"null","description":"Optional category description for UI or admin use."}],"description":"Optional category description for UI or admin use."}},"required":["code","name"],"description":"Request: create a new community category. Maps to community_platform_categories Prisma model."},"ICommunityPlatformCategory.IUpdate":{"type":"object","properties":{"name":{"type":"string","description":"New display name for the category."},"description":{"oneOf":[{"type":"string","description":"Updated category description. May be null to clear."},{"type":"null","description":"Updated category description. May be null to clear."}],"description":"Updated category description. May be null to clear."}},"required":[],"description":"Request: update mutable fields for a category. Only 'name' or 'description' may be updated."},"ICommunityPlatformCategory.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique category identifier (UUID)."},"code":{"type":"string","description":"System-unique slug/code for lookup and filtering"},"name":{"type":"string","description":"Display name"},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp"},"updated_at":{"type":"string","format":"date-time","description":"Update timestamp"}},"required":["id","code","name","created_at","updated_at"],"description":"Summary object for category list/pagination APIs. Used in paginated response. Subset of the full category entity."},"IPageICommunityPlatformCategory.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCategory.ISummary"},"description":"Paginated array of category summary records."}},"required":["pagination","data"],"description":"Paginated result for category summary records as shown in admin lists. Follows IPage structure."},"ICommunityPlatformBannedWord.IRequest":{"type":"object","properties":{"search":{"type":"string","description":"Search term to filter by phrase"},"category":{"type":"string","description":"Filter by moderation category"},"enabled":{"type":"boolean","description":"Filter for enabled/disabled rows"},"page":{"type":"integer","description":"Page number","minimum":1},"limit":{"type":"integer","description":"Results per page (default 20)","minimum":1},"orderBy":{"oneOf":[{"const":"created_at","description":"Sort field"},{"const":"phrase","description":"Sort field"},{"const":"category","description":"Sort field"}],"description":"Sort field"},"direction":{"oneOf":[{"const":"asc","description":"Sort direction"},{"const":"desc","description":"Sort direction"}],"description":"Sort direction"}},"required":[],"description":"Request DTO for paginated/filter/search query for banned word moderation dictionary."},"ICommunityPlatformBannedWord":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for banned word entry"},"phrase":{"type":"string","description":"Banned word or phrase. Must be unique."},"category":{"oneOf":[{"type":"string","description":"Optional moderation category (profanity, spam, hate). For admin use."},{"type":"null","description":"Optional moderation category (profanity, spam, hate). For admin use."}],"description":"Optional moderation category (profanity, spam, hate). For admin use."},"enabled":{"type":"boolean","description":"Whether the word/phrase is currently enforced for moderation (true=active)"},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp"},"updated_at":{"type":"string","format":"date-time","description":"Update timestamp"}},"required":["id","phrase","enabled","created_at","updated_at"],"description":"Banned word entity definition for moderation, content vetting, policy enforcement. Mirrors Prisma schema."},"ICommunityPlatformBannedWord.ICreate":{"type":"object","properties":{"phrase":{"type":"string","description":"Unique banned word or phrase (cannot duplicate existing entries)"},"category":{"oneOf":[{"type":"string","description":"Moderation category (e.g., 'profanity', 'spam'). Optional."},{"type":"null","description":"Moderation category (e.g., 'profanity', 'spam'). Optional."}],"description":"Moderation category (e.g., 'profanity', 'spam'). Optional."},"enabled":{"type":"boolean","description":"Whether enforcement should be active immediately (true/false)"}},"required":["phrase","enabled"],"description":"Request: create a banned word for moderation dictionary."},"ICommunityPlatformBannedWord.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier"},"phrase":{"type":"string","description":"Banned phrase"},"enabled":{"type":"boolean","description":"Currently enforced for moderation"},"created_at":{"type":"string","format":"date-time","description":"When this entry was created"},"updated_at":{"type":"string","format":"date-time","description":"When this was last updated"}},"required":["id","phrase","enabled","created_at","updated_at"],"description":"Summary for paginated list of banned words. Used in IPage* ISummary lists."},"IPageICommunityPlatformBannedWord.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformBannedWord.ISummary"},"description":"Paginated array of banned word summary rows."}},"required":["pagination","data"],"description":"Paginated banned words dictionary results following platform standard IPage* structure."},"IPage.IPagination":{"type":"object","properties":{"current":{"type":"integer","format":"uint32","description":"Current page number of paginated results.\n\nReflects the position of the search within the available pages."},"limit":{"type":"integer","format":"uint32","description":"Page size (number of results per page).\n\nDefines pagination window size."},"records":{"type":"integer","format":"uint32","description":"Total number of result records matched by the search/filter."},"pages":{"type":"integer","format":"uint32","description":"Total number of pages in the result set (computed as records / limit, rounded up).\n\nUsed for pagination navigation."}},"required":["current","limit","records","pages"],"description":"Standard schema describing pagination metadata for page containers.\n\nUsed across all paginated API responses as a required, common component."},"ICommunityPlatformBannedWord.IUpdate":{"type":"object","properties":{"phrase":{"type":"string","description":"The forbidden word or phrase. Supports Unicode (case-insensitive, up to internal limit). Required to be unique for all banned entries. Use for changing the target phrase to be filtered in moderation or content checks."},"category":{"oneOf":[{"type":"string","description":"Optional category/label for the word (e.g., 'profanity','spam','hate'). Used to segment moderation tagging and reporting. Null to remove any category."},{"type":"null","description":"Optional category/label for the word (e.g., 'profanity','spam','hate'). Used to segment moderation tagging and reporting. Null to remove any category."}],"description":"Optional category/label for the word (e.g., 'profanity','spam','hate'). Used to segment moderation tagging and reporting. Null to remove any category."},"enabled":{"type":"boolean","description":"Whether the banned word is active for enforcement. If false, the word/phrase is ignored by content moderation. Toggle to (de)activate filtering temporarily."}},"required":[],"description":"Request object for updating a banned word or phrase entry for moderation. Any field may be omitted if not changing that property. Only phrase/category/enabled are editable."},"ICommunityPlatformConfiguration.IRequest":{"type":"object","properties":{"q":{"type":"string","description":"Fulltext or partial search query for key/description/values."},"key":{"type":"string","description":"Limits results to configuration with the exact given key."},"includeDeleted":{"type":"boolean","description":"If true, include soft-deleted configurations in search results."},"page":{"type":"number","description":"Pagination: page number (1-based)."},"limit":{"type":"number","description":"Pagination: number of results per page."}},"required":[],"description":"Request shape for performing a filtered/paginated configuration search."},"IPageICommunityPlatformConfiguration":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformConfiguration"},"description":"Array with one element per configuration parameter in the result set."}},"required":["pagination","data"],"description":"Paginated collection of configuration parameter results."},"ICommunityPlatformConfiguration":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for system configuration entry."},"key":{"type":"string","description":"Configuration key (unique). Used for lookups, references, and programmatic retrieval throughout business logic."},"value":{"type":"string","description":"Raw configuration value (string-encoded). Supports values that are numbers, JSON, booleans, or codes, but always stored/read as string."},"description":{"oneOf":[{"type":"string","description":"Optional human-readable description to clarify/explain configuration for admins/auditors."},{"type":"null","description":"Optional human-readable description to clarify/explain configuration for admins/auditors."}],"description":"Optional human-readable description to clarify/explain configuration for admins/auditors."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the configuration parameter was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of last update to this configuration entry."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"If set, marks this configuration as soft-deleted (inactive); otherwise null (active)."},{"type":"null","format":"date-time","description":"If set, marks this configuration as soft-deleted (inactive); otherwise null (active)."}],"description":"If set, marks this configuration as soft-deleted (inactive); otherwise null (active)."}},"required":["id","key","value","created_at","updated_at"],"description":"System-wide configuration parameter as defined in platform configuration table."},"ICommunityPlatformConfiguration.ICreate":{"type":"object","properties":{"key":{"type":"string","description":"Configuration key (must be unique). Used for programmatic access and reference in the system."},"value":{"type":"string","description":"Raw value for configuration entry (string-encoded). Interpreted at business logic layer."},"description":{"oneOf":[{"type":"string","description":"Optional long-form description for admins, explaining what this configuration controls."},{"type":"null","description":"Optional long-form description for admins, explaining what this configuration controls."}],"description":"Optional long-form description for admins, explaining what this configuration controls."}},"required":["key","value"],"description":"Request object for creating a new system configuration parameter."},"ICommunityPlatformConfiguration.IUpdate":{"type":"object","properties":{"key":{"type":"string","description":"Updates configuration's key (must remain unique if changed)."},"value":{"type":"string","description":"New value to assign (string-encoded, business logic interprets format)."},"description":{"oneOf":[{"type":"string","description":"New configuration description, if annotated/clarified."},{"type":"null","description":"New configuration description, if annotated/clarified."}],"description":"New configuration description, if annotated/clarified."}},"required":[],"description":"Request object for updating one or more fields of an existing configuration parameter."},"ICommunityPlatformGuest.IRequest":{"type":"object","properties":{"guest_identifier":{"type":"string","description":"Pseudonymous unique identifier for the guest (session token, cookie, etc.)"},"ip_address":{"type":"string","description":"IP address (string, typically dotted-decimal IPv4 or IPv6 hex) for filtering analytics data."},"user_agent":{"type":"string","description":"User agent/browser/device fingerprint for filtering guest records."},"created_after":{"type":"string","format":"date-time","description":"Return only records created after this timestamp (ISO8601 UTC)."},"created_before":{"type":"string","format":"date-time","description":"Return only guest records created before this timestamp (ISO8601 UTC)."},"page":{"type":"number","description":"Current page number (1-based) for pagination."},"limit":{"type":"number","description":"Records per page to return in results."}},"required":[],"description":"Request object for advanced, paginated/filterable queries over unauthenticated guest visitor records."},"IPageICommunityPlatformGuest":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformGuest"},"description":"Array of guest analytics records submitted for the result set."}},"required":["pagination","data"],"description":"Paginated set of guest visitor analytics objects."},"ICommunityPlatformSession.IRequest":{"type":"object","properties":{"page":{"type":"integer","format":"uint32","description":"Page number for pagination. Optional. Must be a positive integer or null for default."},"limit":{"type":"integer","format":"uint32","description":"How many records to return per page. Optional. Default 100."},"memberId":{"type":"string","format":"uuid","description":"Filter results to sessions belonging to this member (UUID). Optional."},"adminId":{"type":"string","format":"uuid","description":"Filter results to sessions belonging to this admin (UUID). Optional."},"activeOnly":{"type":"boolean","description":"If true, return only active (non-deleted, non-expired) sessions."},"expiredOnly":{"type":"boolean","description":"If true, return only expired sessions (expired_at past current time)."},"deviceFingerprint":{"type":"string","description":"Filter by device fingerprint (exact match, optional)."},"fromDate":{"type":"string","format":"date-time","description":"Filter sessions created after this ISO8601 timestamp."},"toDate":{"type":"string","format":"date-time","description":"Filter sessions created before this ISO8601 timestamp."},"search":{"type":"string","description":"Free-text search field for device, browser, etc. Optional."},"sortBy":{"oneOf":[{"const":"created_at","description":"Sort sessions by specified field. Optional."},{"const":"expires_at","description":"Sort sessions by specified field. Optional."},{"const":"invalidated_at","description":"Sort sessions by specified field. Optional."},{"const":"device_fingerprint","description":"Sort sessions by specified field. Optional."}],"description":"Sort sessions by specified field. Optional."},"direction":{"oneOf":[{"const":"asc","description":"Sort direction: ascending or descending. Optional."},{"const":"desc","description":"Sort direction: ascending or descending. Optional."}],"description":"Sort direction: ascending or descending. Optional."}},"description":"Request parameters for searching and filtering session (community_platform_sessions) records. Supports pagination, member/admin filtering, activity/expiry filter, device/browser searching, and sort fields. All parameters are optional.","required":[]},"IPageICommunityPlatformSession":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformSession"}}},"required":["pagination","data"],"description":"Paginated collection of session entities according to IPage<T> contract. Used for listing current, historical, or filtered session lists. Data array contains one or more full ICommunityPlatformSession objects."},"ICommunityPlatformSession":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the session record."},"community_platform_member_id":{"oneOf":[{"type":"string","format":"uuid","description":"ID of the member (if this is a member session). Null for admin-only sessions."},{"type":"null"}],"description":"ID of the member (if this is a member session). Null for admin-only sessions."},"community_platform_admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"ID of the admin (if this is an admin session). Null for member-only sessions."},{"type":"null"}],"description":"ID of the admin (if this is an admin session). Null for member-only sessions."},"jwt_token":{"type":"string","description":"JWT access token for this session. Sensitive; returned only in authentication response."},"refresh_token":{"type":"string","description":"Refresh token for this session. Sensitive; returned only in initial login/join/refresh responses."},"device_fingerprint":{"oneOf":[{"type":"string","description":"Device or browser fingerprint for this session. Optional; provides additional security and audit information."},{"type":"null"}],"description":"Device or browser fingerprint for this session. Optional; provides additional security and audit information."},"expires_at":{"type":"string","format":"date-time","description":"ISO 8601 timestamp of the session's expiration."},"invalidated_at":{"oneOf":[{"type":"string","format":"date-time","description":"If set, time when this session was revoked or invalidated via logout."},{"type":"null"}],"description":"If set, time when this session was revoked or invalidated via logout."},"created_at":{"type":"string","format":"date-time","description":"ISO 8601 creation timestamp for the session."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"If set, time when this session was soft deleted (no longer valid)."},{"type":"null"}],"description":"If set, time when this session was soft deleted (no longer valid)."}},"required":["id","jwt_token","refresh_token","expires_at","created_at"],"description":"Session entity storing device, member/admin reference, access/refresh token, expiry, and audit information. Used throughout all platform authentication workflows. Do NOT expose sensitive tokens in non-authenticated responses. Device/admin/member references are all UUID. Fields are nullable as per schema (see comments)."},"ICommunityPlatformCommunity.IRequest":{"type":"object","properties":{"page":{"type":"integer","format":"uint32","description":"Page number for pagination. Optional."},"limit":{"type":"integer","format":"uint32","description":"Records per page to return. Optional. Default: 20."},"owner_id":{"type":"string","format":"uuid","description":"Return only communities created/owned by this user (admin filtering)."},"category_id":{"type":"string","format":"uuid","description":"Return only communities matching this category."},"name":{"type":"string","description":"Where clause: Like/exact match on unique community name (alphanumeric, hyphen/underscore)."},"display_title":{"type":"string","description":"Like/exact search for community display title. Optional."},"description":{"type":"string","description":"Like/exact search for community description. Optional."},"search":{"type":"string","description":"Free-text search for community, matches name, title, and description."},"sortBy":{"oneOf":[{"const":"created_at","description":"Sort by key. Default = created_at."},{"const":"updated_at","description":"Sort by key. Default = created_at."},{"const":"name","description":"Sort by key. Default = created_at."},{"const":"display_title","description":"Sort by key. Default = created_at."}],"description":"Sort by key. Default = created_at."},"direction":{"oneOf":[{"const":"asc","description":"Sort order ascending or descending."},{"const":"desc","description":"Sort order ascending or descending."}],"description":"Sort order ascending or descending."}},"description":"Advanced parameters for searching/filtering a paginated list of communities. Used for community discovery features and explore/search endpoints. All properties are optional. Supports filtering by ownership, category, exact or partial name/title, textual search, and return sort order.","required":[]},"IPageICommunityPlatformCommunity.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCommunity.ISummary"}}},"required":["pagination","data"],"description":"Paginated results (IPage<T>) for community summary data. Provides paging, total record counts, and an array of summary community card data. Used in home feed, explore, and search results."},"ICommunityPlatformCommunity.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the community entity."},"name":{"type":"string","description":"Unique, immutable community code name (slug) as per business rules."},"display_title":{"oneOf":[{"type":"string","description":"Display title for the community. Optional; may be null."},{"type":"null"}],"description":"Display title for the community. Optional; may be null."},"category_id":{"type":"string","format":"uuid","description":"Category reference ID (FK to categories table)."},"owner_id":{"type":"string","format":"uuid","description":"Owner/creator member ID."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp of this community."}},"required":["id","name","category_id","owner_id","created_at"],"description":"Summary card for a community entity, returned in listings/search results. Only safe, public-facing fields included. Excludes full descriptions or deleted state."},"ICommunityPlatformCommunity":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique id for the community platform community entity."},"category_id":{"type":"string","format":"uuid","description":"Foreign key to the community category (must match category table)."},"owner_id":{"type":"string","format":"uuid","description":"Foreign key to the member who created/owns this community."},"name":{"type":"string","description":"Unique, immutable, validated presentation name (slug) of community (see business rules, immutable)."},"display_title":{"oneOf":[{"type":"string","description":"Optional display title shown in UI interfaces (up to 64 chars)."},{"type":"null"}],"description":"Optional display title shown in UI interfaces (up to 64 chars)."},"description":{"oneOf":[{"type":"string","description":"Long community description, up to 200 chars. Optional."},{"type":"null"}],"description":"Long community description, up to 200 chars. Optional."},"logo_uri":{"oneOf":[{"type":"string","description":"Image URI for community's logo (optional, up to 5MB, 80k chars)."},{"type":"null"}],"description":"Image URI for community's logo (optional, up to 5MB, 80k chars)."},"banner_uri":{"oneOf":[{"type":"string","description":"Image URI for community's banner (optional, up to 5MB, 80k chars)."},{"type":"null"}],"description":"Image URI for community's banner (optional, up to 5MB, 80k chars)."},"created_at":{"type":"string","format":"date-time","description":"Created timestamp (UTC, platform default)."},"updated_at":{"type":"string","format":"date-time","description":"Last updated timestamp (UTC, platform default)."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"If set, timestamp for soft-deletion audit. Null if active."},{"type":"null"}],"description":"If set, timestamp for soft-deletion audit. Null if active."}},"required":["id","category_id","owner_id","name","created_at","updated_at"],"description":"Full community entity with all platform business data for sub-communities. All major fields required for create, edit, and display are present. Returned in detail/GET endpoints. Note: owner_id and name are immutable after create. Public-facing; never exposes member PII in responses."},"ICommunityPlatformCommunity.ICreate":{"type":"object","properties":{"category_id":{"type":"string","format":"uuid","description":"Required. Category ID from categories table for new community."},"name":{"type":"string","description":"Required. Unique, immutable slug for new community (validated, 3-32 chars, alphanumeric/hyphen/underscore, lower-case)."},"display_title":{"type":"string","description":"Optional. Display title (max 64 chars)."},"description":{"type":"string","description":"Optional. Community description (max 200 chars)."},"logo_uri":{"type":"string","description":"Optional. Logo image URI (up to 80,000 chars, soft cap 5MB image)."},"banner_uri":{"type":"string","description":"Optional. Banner image URI (up to 80,000 chars, soft cap 5MB image)."}},"required":["category_id","name"],"description":"Input data to create a new community entry. Used in POST endpoints for member/admin community creation. Validates all creation business requirements (name uniqueness, required category, slug rules). Name and category cannot be changed afterward. Optional logo, banner, description, or display_title are supported. All URI fields are expected to be valid image references per business rule. No owner_id—that comes from authentication context. Never includes created_at/updated_at/deleted_at: those are set by system/business logic at creation. Never accepts or exposes deleted status for created entries."},"ICommunityPlatformSession.IUpdate":{"type":"object","properties":{"device_fingerprint":{"oneOf":[{"type":"string","description":"The device or browser fingerprint. Optional; can be null for server-annotated or privacy contexts."},{"type":"null","description":"The device or browser fingerprint. Optional; can be null for server-annotated or privacy contexts."}],"description":"The device or browser fingerprint. Optional; can be null for server-annotated or privacy contexts."},"expires_at":{"type":"string","format":"date-time","description":"The UTC datetime when the session will expire. Optional for patch/put."},"invalidated_at":{"oneOf":[{"type":"string","format":"date-time","description":"The time the session was force-invalidated (e.g., logout everywhere). Optional; set or null."},{"type":"null","format":"date-time","description":"The time the session was force-invalidated (e.g., logout everywhere). Optional; set or null."}],"description":"The time the session was force-invalidated (e.g., logout everywhere). Optional; set or null."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Soft-deletion timestamp. Set to null if session is active; update for soft delete."},{"type":"null","format":"date-time","description":"Soft-deletion timestamp. Set to null if session is active; update for soft delete."}],"description":"Soft-deletion timestamp. Set to null if session is active; update for soft delete."}},"description":"Represents the update DTO schema for modifying an existing session record in the community_platform_sessions table. Used for PATCH/PUT methods on session records in the OpenAPI operations. Only metadata fields can be updated; tokens cannot be changed via this schema. See property descriptions for session management and device context details.","required":[]},"ICommunityPlatformCommunity.IUpdate":{"type":"object","properties":{"display_title":{"oneOf":[{"type":"string","description":"The display title of the community, up to 64 characters. Optional; null to clear."},{"type":"null","description":"The display title of the community, up to 64 characters. Optional; null to clear."}],"description":"The display title of the community, up to 64 characters. Optional; null to clear."},"description":{"oneOf":[{"type":"string","description":"Summary description for the community. Up to 200 characters; null to clear."},{"type":"null","description":"Summary description for the community. Up to 200 characters; null to clear."}],"description":"Summary description for the community. Up to 200 characters; null to clear."},"logo_uri":{"oneOf":[{"type":"string","description":"URI for the community's logo image. Optional and nullable."},{"type":"null","description":"URI for the community's logo image. Optional and nullable."}],"description":"URI for the community's logo image. Optional and nullable."},"banner_uri":{"oneOf":[{"type":"string","description":"URI for the community's banner image. Optional and nullable."},{"type":"null","description":"URI for the community's banner image. Optional and nullable."}],"description":"URI for the community's banner image. Optional and nullable."},"category_id":{"type":"string","description":"The UUID of the category this community is assigned to. Required if changing category."}},"description":"Schema for updating editable fields of a community (display_title, description, logo/banner, category). The name is immutable and cannot be changed. Used in PUT or PATCH APIs for community metadata management.","required":[]},"ICommunityPlatformCommunityMembership.IRequest":{"type":"object","properties":{"page":{"oneOf":[{"type":"integer","format":"uint32","description":"Current page number (1-based). May be null for default."},{"type":"null","format":"uint32","description":"Current page number (1-based). May be null for default."}],"description":"Current page number (1-based). May be null for default."},"limit":{"oneOf":[{"type":"integer","format":"uint32","description":"Page size limit (default 20). Nullable if not specified."},{"type":"null","format":"uint32","description":"Page size limit (default 20). Nullable if not specified."}],"description":"Page size limit (default 20). Nullable if not specified."},"sort":{"type":"string","description":"Field and direction to sort returned members by (e.g., \"joined_at desc\")."},"search":{"type":"string","description":"Optional free-text search keywords (applies to member display name or email as determined by business logic)."},"joined_after":{"oneOf":[{"type":"string","format":"date-time","description":"Filter for memberships joined after this datetime."},{"type":"null","format":"date-time","description":"Filter for memberships joined after this datetime."}],"description":"Filter for memberships joined after this datetime."},"joined_before":{"oneOf":[{"type":"string","format":"date-time","description":"Filter for memberships joined before this datetime."},{"type":"null","format":"date-time","description":"Filter for memberships joined before this datetime."}],"description":"Filter for memberships joined before this datetime."},"member_display_name":{"type":"string","description":"Filter by (partial) member display name for advanced UI or moderation search."}},"description":"Advanced query, filter, and pagination structure for searching community members (paginated roster-style read). Used in PATCH/POST APIs for member listing.","required":[]},"IPageICommunityPlatformCommunityMembership.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCommunityMembership.ISummary"}}},"required":["pagination","data"],"description":"Paginated collection of community membership summary records. Used for paginated community member lists in roster UIs or moderation/member management APIs. Always contains pagination and data fields (never business properties directly)."},"ICommunityPlatformCommunityMembership.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier (UUID) of the membership record in the community_platform_community_memberships table."},"member_id":{"type":"string","format":"uuid","description":"UUID of the member joined to this record."},"community_id":{"type":"string","format":"uuid","description":"UUID of the community the member joined."},"joined_at":{"type":"string","format":"date-time","description":"Timestamp UTC when membership was established."}},"required":["id","member_id","community_id","joined_at"],"description":"Summary view of a community membership entity with key fields: id, member_id, community_id, joined_at. For use in paginated list views or summary cards."},"ICommunityPlatformCommunityMembership":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the membership record."},"member_id":{"type":"string","format":"uuid","description":"ID for the member in the membership (references community_platform_members.id)."},"community_id":{"type":"string","format":"uuid","description":"ID for the community in the membership (references community_platform_communities.id)."},"joined_at":{"type":"string","format":"date-time","description":"UTC timestamp for when this member joined the community."}},"required":["id","member_id","community_id","joined_at"],"description":"Represents a single membership record relating a member to a community (community_platform_community_memberships table). Used by detailed APIs and single-record queries."},"ICommunityPlatformCommunityMembership.ICreate":{"type":"object","properties":{},"description":"No client-writable properties. Membership creation uses the currently authenticated member and communityId context from the route, not from the request body. All required fields are filled by backend from business context.","required":[]},"ICommunityPlatformRecentCommunity.IRequest":{"type":"object","properties":{"page":{"oneOf":[{"type":"integer","format":"uint32","description":"Current page number for pagination (1-based)."},{"type":"null","format":"uint32","description":"Current page number for pagination (1-based)."}],"description":"Current page number for pagination (1-based)."},"limit":{"oneOf":[{"type":"integer","format":"uint32","description":"Number of records per page (default 5 for sidebar UIs, etc.)."},{"type":"null","format":"uint32","description":"Number of records per page (default 5 for sidebar UIs, etc.)."}],"description":"Number of records per page (default 5 for sidebar UIs, etc.)."},"sort":{"type":"string","description":"Field/direction combo for sorting; e.g., 'touched_at desc'."},"search":{"type":"string","description":"General search string (applies to member display name, community name, etc.)."},"touched_after":{"oneOf":[{"type":"string","format":"date-time","description":"Only records touched after this UTC datetime."},{"type":"null","format":"date-time","description":"Only records touched after this UTC datetime."}],"description":"Only records touched after this UTC datetime."},"touched_before":{"oneOf":[{"type":"string","format":"date-time","description":"Only records touched before this UTC datetime."},{"type":"null","format":"date-time","description":"Only records touched before this UTC datetime."}],"description":"Only records touched before this UTC datetime."},"member_display_name":{"type":"string","description":"Filter by member display name for personalized views."}},"description":"Structure for paginated, filtered, and sorted listing of user recent community visits/interactions. Used for populating sidebars or recent communities UIs with advanced context.","required":[]},"IPageICommunityPlatformRecentCommunity.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformRecentCommunity.ISummary"}}},"required":["pagination","data"],"description":"Paginated list of recent community summary records. Each shows the ID, member_id, community_id, and last interaction (touched_at). Used for sidebar UIs, quick navigation, or recent community widgets."},"ICommunityPlatformRecentCommunity.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"ID of the recent_community mapping row."},"member_id":{"type":"string","format":"uuid","description":"UUID of the member performing the recent interaction."},"community_id":{"type":"string","format":"uuid","description":"UUID of the community recently visited."},"touched_at":{"type":"string","format":"date-time","description":"Timestamp of the last member activity in this community."}},"required":["id","member_id","community_id","touched_at"],"description":"Single summary row for a recent_community mapping (recent visit/contact/interaction). For use in recent sidebar or navigation UIs."},"ICommunityPlatformRecentCommunity":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key. Unique identifier for this recent community mapping record."},"member_id":{"type":"string","format":"uuid","description":"Member ID (user) who recently engaged with the community. Maps to community_platform_members.id."},"community_id":{"type":"string","format":"uuid","description":"Community ID that was recently visited. Maps to community_platform_communities.id."},"touched_at":{"type":"string","format":"date-time","description":"Timestamp (ISO8601) of most recent interaction with this community by this member."}},"required":["id","member_id","community_id","touched_at"],"description":"Represents an entry in a member's recent communities list for sidebar/quick navigation. Each row records the last time the user engaged with or visited a community. Used for personalized navigation and UI enhancement."},"ICommunityPlatformRecentCommunity.ICreate":{"type":"object","properties":{"community_id":{"type":"string","format":"uuid","description":"ID of the community to add to the member's recent list. Required."}},"required":["community_id"],"description":"Input for adding a community to the member's recent communities list. Only community_id is required; member_id and timestamp are determined from authentication/session."},"ICommunityPlatformCommunityRule":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier (primary key) for the rule record."},"community_id":{"type":"string","format":"uuid","description":"ID of the parent community this rule belongs to."},"rule_index":{"type":"integer","minimum":0,"maximum":9,"description":"Ordering of this rule in the list (0-9 for up to 10 rules per community). Must be unique per community."},"rule_line":{"type":"string","maxLength":50,"description":"Text content of the rule (single line, max 50 characters, no breaks)."}},"required":["id","community_id","rule_index","rule_line"],"description":"A single rule/guideline entry for a community. Specifies behavioral or participation rules for members. Up to 10 rules per community. Each rule_line is a short, single-line string."},"ICommunityPlatformCommunityRule.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number (1-based) for pagination."},"limit":{"type":"integer","minimum":1,"description":"Maximum number of results per page."},"sort":{"oneOf":[{"const":"rule_index","description":"Sorting field for the rule list."},{"const":"created_at","description":"Sorting field for the rule list."}],"description":"Sorting field for the rule list."},"rule_index":{"type":"integer","minimum":0,"maximum":9,"description":"Optional filter for a specific rule index."},"query":{"type":"string","maxLength":50,"description":"Optional substring filter for searching rule_line contents."}},"required":[],"description":"Filtering, sorting, and pagination options for listing/searching rules within a community. Designed for use with rule management UI and admin tools."},"IPageICommunityPlatformCommunityRule":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCommunityRule"},"description":"Array of rule records for the current page."}},"required":["pagination","data"],"description":"Paginated set of community rule entries for use in rule list, curation, or search results UIs."},"ICommunityPlatformCommunityRule.ICreate":{"type":"object","properties":{"rule_index":{"type":"integer","minimum":0,"maximum":9,"description":"The index (position) for the rule, in the range 0-9 (max 10 rules per community). Required."},"rule_line":{"type":"string","maxLength":50,"description":"Text of the new rule (max 50 characters, one line, no breaks). Required."}},"required":["rule_index","rule_line"],"description":"Input payload for creating a new rule on a community. Both rule_index (position/order) and rule_line (content) are required."},"ICommunityPlatformCommunityRule.IUpdate":{"type":"object","properties":{"rule_index":{"type":"integer","minimum":0,"maximum":9,"description":"(Optional) New index (position) for the rule if reordering."},"rule_line":{"type":"string","maxLength":50,"description":"(Optional) Updated text (max 50 chars)."}},"required":[],"description":"Fields for updating (editing or reordering) a community rule. All fields optional; only changed ones need be present."},"ICommunityPlatformPost.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number for result pagination, 1-based."},"limit":{"type":"integer","minimum":1,"description":"Maximum number of posts per page."},"community_platform_community_id":{"type":"string","format":"uuid","description":"Optional: Filter by community (by UUID)."},"author_id":{"type":"string","format":"uuid","description":"Optional: Filter by author/member (by UUID)."},"query":{"type":"string","description":"Text search filter (title/body keywords)."},"sort_by":{"oneOf":[{"const":"created_at","description":"Sort mode for results — by creation date or 'top' posts (algorithmic)."},{"const":"top","description":"Sort mode for results — by creation date or 'top' posts (algorithmic)."}],"description":"Sort mode for results — by creation date or 'top' posts (algorithmic)."},"order":{"oneOf":[{"const":"asc","description":"Order direction: ascending or descending (for date or algorithmic order)."},{"const":"desc","description":"Order direction: ascending or descending (for date or algorithmic order)."}],"description":"Order direction: ascending or descending (for date or algorithmic order)."},"min_date":{"type":"string","format":"date-time","description":"Filter for posts created after/before (inclusive) — ISO8601 date-time."},"max_date":{"type":"string","format":"date-time","description":"Filter for posts created before/at (inclusive) — ISO8601 date-time."}},"required":[],"description":"Filtering, sorting, and pagination options for post listing/search API. Used for Home Feed, Community Feed, and full-text search results."},"IPageICommunityPlatformPost.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformPost.ISummary"}}},"required":["pagination","data"],"description":"Paginated collection of post summary objects. Returns multiple post summary records with pagination information. Used for feed/list views, provides lightweight details for each post."},"ICommunityPlatformPost.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier of the post. Primary key from Prisma model."},"title":{"type":"string","description":"Title of the post. Required, 5-120 characters, plain text."},"community_platform_community_id":{"type":"string","format":"uuid","description":"ID of the community the post belongs to."},"author_display_name":{"oneOf":[{"type":"string","description":"Optional display name of author; null or omitted means default/Anonymous."},{"type":"null","description":"Optional display name of author; null or omitted means default/Anonymous."}],"description":"Optional display name of author; null or omitted means default/Anonymous."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the post was created (ISO 8601)."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp when the post was last edited (ISO 8601)."}},"required":["id","title","community_platform_community_id","created_at","updated_at"],"description":"Summary type for community platform posts. For list/feed/discovery; omits body, votes, detailed status."},"ICommunityPlatformPost":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique post ID (UUID)."},"community_platform_community_id":{"type":"string","format":"uuid","description":"ID of the community of the post."},"community_platform_member_id":{"type":"string","format":"uuid","description":"ID of the authoring member (user) for this post."},"title":{"type":"string","description":"Title of the post. 5-120 characters, plain text."},"body":{"type":"string","description":"Plain text content of the post. 10–10,000 characters. No scripts, code, etc."},"author_display_name":{"oneOf":[{"type":"string","description":"Optional display name for the post. Used as author alias with up to 32 chars."},{"type":"null","description":"Optional display name for the post. Used as author alias with up to 32 chars."}],"description":"Optional display name for the post. Used as author alias with up to 32 chars."},"created_at":{"type":"string","format":"date-time","description":"When the post was created (ISO 8601 UTC)."},"updated_at":{"type":"string","format":"date-time","description":"When the post was last updated (ISO 8601 UTC)."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Soft delete timestamp. Null if active; set if deleted."},{"type":"null","format":"date-time","description":"Soft delete timestamp. Null if active; set if deleted."}],"description":"Soft delete timestamp. Null if active; set if deleted."}},"required":["id","community_platform_community_id","community_platform_member_id","title","body","created_at","updated_at"],"description":"Represents a single post entity as stored in the database. Contains all major business fields and audit fields from Prisma schema."},"ICommunityPlatformPost.ICreate":{"type":"object","properties":{"community_platform_community_id":{"type":"string","format":"uuid","description":"ID of the community to post in."},"title":{"type":"string","description":"Title for the post: 5-120 chars."},"body":{"type":"string","description":"Body/content for the post: 10-10,000 chars, plain text only."},"author_display_name":{"oneOf":[{"type":"string","description":"Optional display name for the post's author."},{"type":"null","description":"Optional display name for the post's author."}],"description":"Optional display name for the post's author."}},"required":["community_platform_community_id","title","body"],"description":"Request body for creating a new community platform post. Only required fields + business-optional display name."},"ICommunityPlatformPost.IUpdate":{"type":"object","properties":{"title":{"type":"string","description":"Updated title (5-120 chars, plain text)."},"body":{"type":"string","description":"Updated body (10-10,000 chars, plain text)."},"author_display_name":{"oneOf":[{"type":"string","description":"Optional new display name for the author."},{"type":"null","description":"Optional new display name for the author."}],"description":"Optional new display name for the author."}},"description":"Request body for updating an existing post. Fields are optional and may be patched individually.","required":[]},"IPageICommunityPlatformPostSnapshot":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformPostSnapshot"}}},"required":["pagination","data"],"description":"Paginated result for post snapshots (edit/version history)."},"ICommunityPlatformPostSnapshot":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique ID of the snapshot record."},"community_platform_post_id":{"type":"string","format":"uuid","description":"Associated post's ID."},"community_platform_member_id":{"type":"string","format":"uuid","description":"ID of the member who authored this snapshot version."},"title":{"type":"string","description":"Snapshot of the post's title at this version."},"body":{"type":"string","description":"Snapshot of the post's body at this version."},"author_display_name":{"oneOf":[{"type":"string","description":"Display name used in this version; possible null for Anonymous."},{"type":"null","description":"Display name used in this version; possible null for Anonymous."}],"description":"Display name used in this version; possible null for Anonymous."},"created_at":{"type":"string","format":"date-time","description":"When this snapshot was created."}},"required":["id","community_platform_post_id","community_platform_member_id","title","body","created_at"],"description":"Point-in-time snapshot of a post version, used for audit/moderation. Read-only historical object."},"ICommunityPlatformPostSnapshot.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number, default 1."},"limit":{"type":"integer","minimum":1,"description":"Page size, default 20."},"order":{"oneOf":[{"const":"asc","description":"Sort order for created_at."},{"const":"desc","description":"Sort order for created_at."}],"description":"Sort order for created_at."}},"description":"Request query for snapshot pagination and ordering.","required":[]},"ICommunityPlatformPostReport.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number, default 1."},"limit":{"type":"integer","minimum":1,"description":"Items/page, default 20."},"status":{"type":"string","description":"Optional filter: report status (open, resolved, etc)."},"report_type":{"type":"string","description":"Optional filter: report type/category."},"order":{"oneOf":[{"const":"asc","description":"Sort order (by creation time or other key)."},{"const":"desc","description":"Sort order (by creation time or other key)."}],"description":"Sort order (by creation time or other key)."}},"description":"Query for paginated/filterable report result set.","required":[]},"IPageICommunityPlatformPostReport":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformPostReport"}}},"required":["pagination","data"],"description":"Paginated collection of post report records. Includes pagination metadata and array of ICommunityPlatformPostReport records. Used for moderation workflows, reporting UIs, and system-level audit queries."},"ICommunityPlatformPostReport":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key of the post report. Uniquely identifies this report in the database. Referenced by moderation and appeal workflows."},"community_platform_post_id":{"type":"string","format":"uuid","description":"The ID of the post to which this report applies. Foreign key to posts table."},"reported_by_member_id":{"type":"string","format":"uuid","description":"Member ID who reported the post. Links to reporting member's identity."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"ID of the admin who handled the report. Nullable until assignment."},{"type":"null","format":"uuid","description":"ID of the admin who handled the report. Nullable until assignment."}],"description":"ID of the admin who handled the report. Nullable until assignment."},"report_type":{"type":"string","description":"Type/category of report (e.g., spam, abuse, etc.). Must match platform-allowed values."},"reason":{"type":"string","description":"Detailed reason or explanation for the report, up to 1000 characters. Business logic typically enforces non-empty and plain text format."},"status":{"type":"string","description":"Current workflow status of the report (e.g., open, resolved, dismissed, etc.). Driven by moderation queue."},"resolution_notes":{"oneOf":[{"type":"string","description":"Notes or rationale by admin after handling the case. Nullable."},{"type":"null","description":"Notes or rationale by admin after handling the case. Nullable."}],"description":"Notes or rationale by admin after handling the case. Nullable."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when the report was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of last report update or admin intervention."},"resolved_at":{"oneOf":[{"type":"string","format":"date-time","description":"Timestamp when the report was resolved/closed. Nullable for open reports."},{"type":"null","format":"date-time","description":"Timestamp when the report was resolved/closed. Nullable for open reports."}],"description":"Timestamp when the report was resolved/closed. Nullable for open reports."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Soft delete timestamp for report, if applicable. Nullable when active."},{"type":"null","format":"date-time","description":"Soft delete timestamp for report, if applicable. Nullable when active."}],"description":"Soft delete timestamp for report, if applicable. Nullable when active."}},"required":["id","community_platform_post_id","reported_by_member_id","report_type","reason","status","created_at","updated_at"],"description":"Post report entity representing a user-initiated or admin-initiated report/flag on a particular post in the system. Includes links to post, reporter, and resolver admin, with moderation workflow fields and audit timestamps."},"ICommunityPlatformPostReport.ICreate":{"type":"object","properties":{"report_type":{"type":"string","description":"Type/category of report (e.g., spam, abuse, etc.). Required. Must match platform-allowed values."},"reason":{"type":"string","description":"Explanation for the report, up to 1000 characters. Non-empty plain text required."}},"required":["report_type","reason"],"description":"Request body for creating a post report. Only fields required from the reporter; admin and workflow fields are set server-side."},"ICommunityPlatformPostReport.IUpdate":{"type":"object","properties":{"report_type":{"type":"string","description":"Type/category of report. Optional for updates."},"reason":{"type":"string","description":"Update the explanation/reason for this report."},"status":{"type":"string","description":"Status transition for the report (e.g., open → resolved, etc.)."},"resolution_notes":{"type":"string","description":"Administrative notes/rationale for status or resolution."}},"required":[],"description":"Request body for updating a post report. Allows updates for type, reason, status, or admin notes per workflow."},"ICommunityPlatformComment.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number for pagination. Optional. Defaults to 1."},"limit":{"type":"integer","minimum":1,"description":"Maximum comments per page. Optional. Defaults to admin or system value."},"sort_by":{"type":"string","description":"Sort order or column (e.g., 'created_at', 'score', etc.). Optional."},"query":{"type":"string","description":"Search string (content substring, full-text, etc.). Optional."},"post_id":{"type":"string","format":"uuid","description":"Restrict search to comments for a single post. Optional."},"author_id":{"type":"string","format":"uuid","description":"Filter by specific comment author. Optional."},"created_from":{"type":"string","format":"date-time","description":"Start of creation date range filter, ISO 8601 format. Optional."},"created_to":{"type":"string","format":"date-time","description":"End of creation date range filter, ISO 8601 format. Optional."}},"required":[],"description":"Request body payload for searching, filtering, and paginating comments, supporting text search, sorting, and field-based filtering. For advanced comment search and listing APIs."},"IPageICommunityPlatformComment.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformComment.ISummary"}}},"required":["pagination","data"],"description":"Paginated list of summarized comment records. Used for comment search, feeds, and bulk display operations. Data is an array of ICommunityPlatformComment.ISummary objects."},"ICommunityPlatformComment.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique ID of the comment. Primary key."},"post_id":{"type":"string","format":"uuid","description":"Post ID to which this comment is attached."},"author_id":{"type":"string","format":"uuid","description":"Member ID who authored the comment."},"content":{"type":"string","description":"Text content of the comment. Truncated or summarized for list views."},"created_at":{"type":"string","format":"date-time","description":"Timestamp of comment creation."},"score":{"oneOf":[{"type":"integer","description":"Current net vote score at time of retrieval, may be null for no votes yet."},{"type":"null","description":"Current net vote score at time of retrieval, may be null for no votes yet."}],"description":"Current net vote score at time of retrieval, may be null for no votes yet."},"edited":{"type":"boolean","description":"Whether the comment has been edited since creation."}},"required":["id","post_id","author_id","content","created_at","edited"],"description":"Summary view of a comment for lists, search results, or paginated displays. Omits thread/parent, deleted_at, and deep linkages."},"ICommunityPlatformComment":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key for the comment entity (UUID)."},"post_id":{"type":"string","format":"uuid","description":"ID of post to which this comment belongs."},"author_id":{"type":"string","format":"uuid","description":"ID of member who created this comment."},"parent_id":{"oneOf":[{"type":"string","format":"uuid","description":"If present, the UUID of the parent comment for threaded replies. Nullable for top-level comments."},{"type":"null","format":"uuid","description":"If present, the UUID of the parent comment for threaded replies. Nullable for top-level comments."}],"description":"If present, the UUID of the parent comment for threaded replies. Nullable for top-level comments."},"content":{"type":"string","description":"Text content of the comment (plain text, 2-2000 characters, scripts/markup forbidden)."},"edited":{"type":"boolean","description":"Indicates whether the comment has been edited after creation."},"score":{"oneOf":[{"type":"integer","description":"Net vote score (upvotes minus downvotes). May be null for no votes."},{"type":"null","description":"Net vote score (upvotes minus downvotes). May be null for no votes."}],"description":"Net vote score (upvotes minus downvotes). May be null for no votes."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp (ISO 8601 UTC, required)."},"updated_at":{"type":"string","format":"date-time","description":"Last modification timestamp."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Soft-deletion timestamp; comment is hidden if present. Nullable for active comments."},{"type":"null","format":"date-time","description":"Soft-deletion timestamp; comment is hidden if present. Nullable for active comments."}],"description":"Soft-deletion timestamp; comment is hidden if present. Nullable for active comments."}},"required":["id","post_id","author_id","content","edited","created_at","updated_at"],"description":"Primary business entity for comments on posts. Contains author, parent, threading, vote score, and all audit timestamps. Used for both top-level and threaded replies."},"ICommunityPlatformComment.ICreate":{"type":"object","properties":{"post_id":{"type":"string","format":"uuid","description":"ID of the post to which the comment is being added."},"parent_id":{"oneOf":[{"type":"string","format":"uuid","description":"If the comment is a reply, the parent comment's UUID; null if top-level."},{"type":"null","format":"uuid","description":"If the comment is a reply, the parent comment's UUID; null if top-level."}],"description":"If the comment is a reply, the parent comment's UUID; null if top-level."},"content":{"type":"string","description":"Text content of the comment (2-2000 chars, plain text)."}},"required":["post_id","content"],"description":"Request body for creating a new comment. Contains post reference, optional parent, and plain text content for the new comment."},"ICommunityPlatformComment.IUpdate":{"type":"object","properties":{"content":{"type":"string","minLength":2,"maxLength":2000,"description":"New plain-text content for the comment (2-2000 chars, no code/scripts)."}},"required":["content"],"description":"Payload for updating a comment.\n\nUsed for editing the content of an existing comment. Only `content` is editable; other fields remain unchanged. The input must comply with length constraints and must not contain scripts or code."},"ICommunityPlatformCommentReport.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number for pagination (optional)."},"limit":{"type":"integer","minimum":1,"description":"Items per page (optional)."},"report_reason":{"type":"string","description":"Filter by report reason substring."},"status":{"type":"string","description":"Filter by status (pending, resolved, rejected, etc.)."},"reporter_id":{"type":"string","format":"uuid","description":"Filter by reporter_id (UUID of member)."},"admin_id":{"type":"string","format":"uuid","description":"Filter by admin_id (UUID of admin)."},"sort":{"type":"string","description":"Sort order (created_at desc/asc, etc.)."}},"description":"Request parameters for searching/filtering comment reports. Supports pagination, filtering by reason, reporter, admin, or status, and sorting.","required":[]},"IPageICommunityPlatformCommentReport.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformCommentReport.ISummary"}}},"required":["pagination","data"],"description":"Paginated collection of comment report summaries.\n\nProvides a list of comment report summaries matching filter/search criteria, with standard pagination info."},"ICommunityPlatformCommentReport.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the report (UUID)."},"comment_id":{"type":"string","format":"uuid","description":"The comment this report targets."},"reporter_id":{"type":"string","format":"uuid","description":"Member who reported the comment (UUID)."},"status":{"type":"string","description":"Current status of the report (e.g. pending, resolved)."},"created_at":{"type":"string","format":"date-time","description":"Timestamp this report was created (ISO 8601)."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Admin assigned to handle/report (UUID/null)."},{"type":"null","format":"uuid","description":"Admin assigned to handle/report (UUID/null)."}],"description":"Admin assigned to handle/report (UUID/null)."}},"required":["id","comment_id","reporter_id","status","created_at"],"description":"Summary representation for a comment report, for collections/options or IPage. Includes only key fields for search/index screens."},"ICommunityPlatformCommentReport":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier for the report."},"comment_id":{"type":"string","format":"uuid","description":"The comment this report targets."},"reporter_id":{"type":"string","format":"uuid","description":"Member who reported the comment (UUID)."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Admin assigned to handle/report (UUID/null)."},{"type":"null","format":"uuid","description":"Admin assigned to handle/report (UUID/null)."}],"description":"Admin assigned to handle/report (UUID/null)."},"report_reason":{"type":"string","description":"The member-supplied reason/explanation for this report."},"status":{"type":"string","description":"Current status of the report (e.g., pending, under_review, rejected, resolved)."},"resolution":{"oneOf":[{"type":"string","description":"Resolution notes/decision (optional, may be null if unresolved)."},{"type":"null","description":"Resolution notes/decision (optional, may be null if unresolved)."}],"description":"Resolution notes/decision (optional, may be null if unresolved)."},"created_at":{"type":"string","format":"date-time","description":"Timestamp this report was created (ISO 8601)."},"updated_at":{"type":"string","format":"date-time","description":"When this report was last updated (ISO 8601)."},"resolved_at":{"oneOf":[{"type":"string","format":"date-time","description":"When this report was resolved (ISO 8601, null if unresolved)."},{"type":"null","format":"date-time","description":"When this report was resolved (ISO 8601, null if unresolved)."}],"description":"When this report was resolved (ISO 8601, null if unresolved)."}},"required":["id","comment_id","reporter_id","report_reason","status","created_at","updated_at"],"description":"Full information for a comment report entity. Used for detail view, moderation, and audit purposes. Contains all business and moderation-relevant fields."},"ICommunityPlatformCommentReport.ICreate":{"type":"object","properties":{"report_reason":{"type":"string","minLength":2,"maxLength":500,"description":"Textual user-supplied report reason (required, plain text, 2-500 chars)."},"status":{"type":"string","description":"Initial report status (per moderation process; typically 'pending')."}},"required":["report_reason","status"],"description":"Required fields for submitting a new comment report. Members must specify a reason and initial status."},"ICommunityPlatformCommentReport.IUpdate":{"type":"object","properties":{"report_reason":{"type":"string","description":"(Optional) Reason text, for reporter/admin update."},"status":{"type":"string","description":"(Optional) New status to set on the report."},"resolution":{"oneOf":[{"type":"string","description":"Resolution/decision annotation from admin for this report (may be null if not resolved)."},{"type":"null","description":"Resolution/decision annotation from admin for this report (may be null if not resolved)."}],"description":"Resolution/decision annotation from admin for this report (may be null if not resolved)."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"(Optional) Assign or re-assign an admin (UUID/null)."},{"type":"null","format":"uuid","description":"(Optional) Assign or re-assign an admin (UUID/null)."}],"description":"(Optional) Assign or re-assign an admin (UUID/null)."}},"description":"Fields allowed to be updated on an existing comment report. Status changes, rationale, and admin assignment/resolution notes are allowed according to moderation rules.","required":[]},"ICommunityPlatformVote.IRequest":{"type":"object","properties":{"page":{"type":"integer","minimum":1,"description":"Page number for pagination (optional)."},"limit":{"type":"integer","minimum":1,"description":"Items per page (optional)."},"post_id":{"type":"string","format":"uuid","description":"Restrict vote search to a specific post (optional)."},"comment_id":{"type":"string","format":"uuid","description":"Restrict vote search to a specific comment (optional)."},"voter_id":{"type":"string","format":"uuid","description":"Filter by member voter UUID (optional)."},"value":{"type":"integer","description":"Filter by value: 1 (upvote), -1 (downvote), 0 (neutral)."},"sort":{"type":"string","description":"Sort order (created_at desc/asc, etc.)."}},"description":"Query/Filter parameters for vote search. Supports pagination and arbitrary filtering by voter, target (post/comment), value, and creation time.","required":[]},"IPageICommunityPlatformVote.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformVote.ISummary"}}},"required":["pagination","data"],"description":"Paginated response with a list of summarized vote records matching the query or filter criteria."},"ICommunityPlatformVote.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Vote record UUID."},"voter_id":{"type":"string","format":"uuid","description":"Member who cast this vote (UUID)."},"post_id":{"oneOf":[{"type":"string","format":"uuid","description":"If this vote is on a post, target's UUID; may be null."},{"type":"null","format":"uuid","description":"If this vote is on a post, target's UUID; may be null."}],"description":"If this vote is on a post, target's UUID; may be null."},"comment_id":{"oneOf":[{"type":"string","format":"uuid","description":"If this vote is on a comment, target's UUID; may be null."},{"type":"null","format":"uuid","description":"If this vote is on a comment, target's UUID; may be null."}],"description":"If this vote is on a comment, target's UUID; may be null."},"value":{"oneOf":[{"const":1,"description":"Vote value: 1=upvote, -1=downvote, 0=neutral (vote removal)."},{"const":-1,"description":"Vote value: 1=upvote, -1=downvote, 0=neutral (vote removal)."},{"const":0,"description":"Vote value: 1=upvote, -1=downvote, 0=neutral (vote removal)."}],"description":"Vote value: 1=upvote, -1=downvote, 0=neutral (vote removal)."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp (ISO 8601)."}},"required":["id","voter_id","value","created_at"],"description":"Summary record for a vote, suitable for paginated collections or business review. Shows which user voted, target, value, and creation time."},"ICommunityPlatformVote":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key. UUID for the vote record."},"voter_id":{"type":"string","format":"uuid","description":"UUID of the member who cast the vote on a post or comment. References 'community_platform_members.id'."},"post_id":{"oneOf":[{"type":"string","format":"uuid","description":"UUID of the post that is the target of this vote (if a post vote). Null if not a post vote."},{"type":"null","format":"uuid","description":"UUID of the post that is the target of this vote (if a post vote). Null if not a post vote."}],"description":"UUID of the post that is the target of this vote (if a post vote). Null if not a post vote."},"comment_id":{"oneOf":[{"type":"string","format":"uuid","description":"UUID of the comment that is the target of this vote (if a comment vote). Null if not a comment vote."},{"type":"null","format":"uuid","description":"UUID of the comment that is the target of this vote (if a comment vote). Null if not a comment vote."}],"description":"UUID of the comment that is the target of this vote (if a comment vote). Null if not a comment vote."},"value":{"oneOf":[{"const":1,"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal. Only these values are valid."},{"const":-1,"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal. Only these values are valid."},{"const":0,"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal. Only these values are valid."}],"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal. Only these values are valid."},"created_at":{"type":"string","format":"date-time","description":"UTC ISO 8601 timestamp when this vote was created."},"updated_at":{"type":"string","format":"date-time","description":"UTC ISO 8601 timestamp when this vote was last updated."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Soft-delete timestamp. If null, this vote is currently active; otherwise, the ISO datetime when the vote was deleted."},{"type":"null","format":"date-time","description":"Soft-delete timestamp. If null, this vote is currently active; otherwise, the ISO datetime when the vote was deleted."}],"description":"Soft-delete timestamp. If null, this vote is currently active; otherwise, the ISO datetime when the vote was deleted."}},"required":["id","voter_id","value","created_at","updated_at"],"description":"Vote record for a post or comment. Indicates a single user's upvote, downvote, or neutral action on either a post or a comment. One vote per user/target is enforced. Follows the 'community_platform_votes' Prisma table design. Value must be 1, -1, or 0."},"ICommunityPlatformVote.ICreate":{"type":"object","properties":{"post_id":{"oneOf":[{"type":"string","format":"uuid","description":"UUID of the post being voted on, or null if this is a comment vote. Optional; at least one of post_id or comment_id must be present."},{"type":"null","format":"uuid","description":"UUID of the post being voted on, or null if this is a comment vote. Optional; at least one of post_id or comment_id must be present."}],"description":"UUID of the post being voted on, or null if this is a comment vote. Optional; at least one of post_id or comment_id must be present."},"comment_id":{"oneOf":[{"type":"string","format":"uuid","description":"UUID of the comment being voted on, or null if this is a post vote. Optional; at least one of post_id or comment_id must be present."},{"type":"null","format":"uuid","description":"UUID of the comment being voted on, or null if this is a post vote. Optional; at least one of post_id or comment_id must be present."}],"description":"UUID of the comment being voted on, or null if this is a post vote. Optional; at least one of post_id or comment_id must be present."},"value":{"oneOf":[{"const":1,"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."},{"const":-1,"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."},{"const":0,"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."}],"description":"Vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."}},"required":["value"],"description":"Request body for creating a new vote record (upvote/downvote/neutral) on a post or comment. One of post_id or comment_id required per business rule."},"ICommunityPlatformVote.IUpdate":{"type":"object","properties":{"value":{"oneOf":[{"const":1,"description":"Updated vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."},{"const":-1,"description":"Updated vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."},{"const":0,"description":"Updated vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."}],"description":"Updated vote value: 1 for upvote, -1 for downvote, 0 for neutral/removal."}},"required":["value"],"description":"Request body for updating the value of an existing vote (upvote, downvote, or neutral). Can only update value."},"ICommunityPlatformAdminAction.IRequest":{"type":"object","properties":{"admin_id":{"type":"string","format":"uuid","description":"UUID of the admin who performed the action. Optional filter."},"action_type":{"type":"string","description":"Type of action taken (e.g. delete_post, suspend_user). Optional filter."},"target_entity":{"type":"string","description":"Type of entity affected (e.g. post, comment, user). Optional filter."},"target_entity_id":{"type":"string","format":"uuid","description":"UUID of the targeted business entity (community/post/comment/user). Optional filter."},"reason":{"type":"string","description":"Filter on admin reason for action. Optional."},"result":{"type":"string","description":"Filter based on result value (success, error, etc). Optional."},"created_from":{"type":"string","format":"date-time","description":"Filter for actions created after this UTC datetime (inclusive). Optional."},"created_to":{"type":"string","format":"date-time","description":"Filter for actions created before this UTC datetime (inclusive). Optional."},"page":{"type":"integer","minimum":1,"description":"Pagination: page number (optional, default 1)."},"limit":{"type":"integer","minimum":1,"description":"Pagination: items per page (optional, default 100)."},"sort_by":{"type":"string","description":"Sort by a specific field (e.g. created_at). Optional."},"sort_dir":{"oneOf":[{"const":"asc","description":"Sort direction. Optional."},{"const":"desc","description":"Sort direction. Optional."}],"description":"Sort direction. Optional."}},"required":[],"description":"Request body for searching, filtering, sorting, and paginating admin/moderation actions. Used for querying audit records."},"IPageICommunityPlatformAdminAction":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformAdminAction"}}},"required":["pagination","data"],"description":"Paginated collection of admin/moderation action records (audit log entries for admin/mod actions). Includes the page information and results, following the standard paginated object structure."},"ICommunityPlatformAdminAction":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Primary key for this admin/moderation action record (UUID)."},"admin_id":{"type":"string","format":"uuid","description":"UUID of the admin who performed this action."},"action_type":{"type":"string","description":"Type of moderation or admin action taken (e.g., delete_post, suspend_user, restore_community)."},"target_entity":{"type":"string","description":"Type of entity affected by this action, such as 'community', 'post', 'comment', 'user', 'membership', etc."},"target_entity_id":{"type":"string","format":"uuid","description":"UUID of the affected entity linked by this admin action."},"reason":{"oneOf":[{"type":"string","description":"Optional explanation or rationale for the action as provided by admin."},{"type":"null","description":"Optional explanation or rationale for the action as provided by admin."}],"description":"Optional explanation or rationale for the action as provided by admin."},"result":{"type":"string","description":"Result/outcome of the action (e.g., success, error, restored, etc.)."},"created_at":{"type":"string","format":"date-time","description":"UTC ISO 8601 timestamp when this admin action was created."}},"required":["id","admin_id","action_type","target_entity","target_entity_id","result","created_at"],"description":"Audit log record for a moderation or admin action. This entity records the action taken by an admin on a target business entity (community, post, comment, user, etc.), including action type, affected entity, admin, rationale (optional), result, and timestamp. Schema matches 'community_platform_admin_actions' table."},"ICommunityPlatformAdminAction.ICreate":{"type":"object","properties":{"admin_id":{"type":"string","format":"uuid","description":"UUID of the admin user performing this action (required)."},"action_type":{"type":"string","description":"Type of moderation/admin action (e.g. delete_post, suspend_user). Required."},"target_entity":{"type":"string","description":"Business entity affected by the admin action. E.g. 'community', 'post', 'comment', 'user'."},"target_entity_id":{"type":"string","format":"uuid","description":"UUID of the entity being acted upon (required)."},"reason":{"oneOf":[{"type":"string","description":"Optional rationale/message for the action. Accepts null."},{"type":"null","description":"Optional rationale/message for the action. Accepts null."}],"description":"Optional rationale/message for the action. Accepts null."},"result":{"type":"string","description":"Outcome/result of action (e.g. success, error). Required."}},"required":["admin_id","action_type","target_entity","target_entity_id","result"],"description":"Request body for creating a new admin/moderation action entry for the audit log. Includes required entity references and result; rationale is optional."},"ICommunityPlatformAdminAction.IUpdate":{"type":"object","properties":{"reason":{"oneOf":[{"type":"string","description":"New/updated rationale for this action. Accepts null to clear."},{"type":"null","description":"New/updated rationale for this action. Accepts null to clear."}],"description":"New/updated rationale for this action. Accepts null to clear."},"result":{"type":"string","description":"Updated outcome/result field for the action."}},"required":[],"description":"Request body for updating admin/moderation action audit log records. Reason/result may be updated separately after action creation."},"ICommunityPlatformAuditLog.IRequest":{"type":"object","properties":{"page":{"type":"integer","format":"int32","description":"Current page number for pagination of audit logs."},"limit":{"type":"integer","format":"int32","description":"Maximum number of audit log entries to return per page."},"event_type":{"type":"string","description":"Type of audit event (e.g., 'admin_action', 'escalation', 'policy_override', etc.)"},"entity_type":{"type":"string","description":"Entity (e.g., post, comment, community, user) affected by the audit event."},"entity_id":{"type":"string","format":"uuid","description":"UUID of the entity related to the audit log event."},"result":{"type":"string","description":"Outcome status of the event (e.g., success, error, reverted, escalated)."},"created_at_from":{"type":"string","format":"date-time","description":"Filter: lower bound created_at (ISO8601 date-time)."},"created_at_to":{"type":"string","format":"date-time","description":"Filter: upper bound created_at (ISO8601 date-time)."}},"description":"Audit log search and filter parameters. Used to retrieve paged, filtered audit trail records. All filtering fields are optional.","required":[]},"IPageICommunityPlatformAuditLog":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformAuditLog"}}},"required":["pagination","data"],"description":"Paginated collection of community platform audit log records. Contains the pagination info and data array of audit log objects."},"ICommunityPlatformAuditLog":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique UUID primary key for this audit log entry."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Admin ID associated with this event, if applicable (nullable)."},{"type":"null","format":"uuid","description":"Admin ID associated with this event, if applicable (nullable)."}],"description":"Admin ID associated with this event, if applicable (nullable)."},"member_id":{"oneOf":[{"type":"string","format":"uuid","description":"Member/user ID involved in this event, if applicable (nullable)."},{"type":"null","format":"uuid","description":"Member/user ID involved in this event, if applicable (nullable)."}],"description":"Member/user ID involved in this event, if applicable (nullable)."},"event_type":{"type":"string","description":"Business event type (e.g. admin_action, policy_override) per Prisma schema."},"entity_type":{"type":"string","description":"Entity type affected by the event (community, post, comment, user, etc.)."},"entity_id":{"type":"string","format":"uuid","description":"UUID identifying the affected business entity."},"metadata_json":{"oneOf":[{"type":"string","description":"Optional JSON string with event-specific metadata or payload."},{"type":"null","description":"Optional JSON string with event-specific metadata or payload."}],"description":"Optional JSON string with event-specific metadata or payload."},"result":{"type":"string","description":"Outcome/result string for the event (e.g., 'success', 'error', 'reverted')."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when this audit log was created."}},"required":["id","event_type","entity_type","entity_id","result","created_at"],"description":"Audit log entity reflecting moderation, escalation and admin actions, with full event and outcome context. Follows Prisma and business rule documentation."},"ICommunityPlatformAppeal.IRequest":{"type":"object","properties":{"page":{"type":"integer","format":"int32","description":"Pagination: current page of appeal search."},"limit":{"type":"integer","format":"int32","description":"Max number of appeals per page."},"member_id":{"type":"string","format":"uuid","description":"Filter for appeals by this member ID."},"admin_id":{"type":"string","format":"uuid","description":"Filter for appeals to or handled by this admin."},"admin_action_id":{"type":"string","format":"uuid","description":"Filter for appeals connected to this admin action."},"appeal_status":{"type":"string","description":"Filter for the status field of appeals (e.g. submitted, resolved, rejected)."},"decision_reason":{"type":"string","description":"Filter/partial match for moderator/admin decision rationale."},"created_at_from":{"type":"string","format":"date-time","description":"Lower time bound for appeal created_at."},"created_at_to":{"type":"string","format":"date-time","description":"Upper time bound for appeal created_at."},"updated_at_from":{"type":"string","format":"date-time","description":"Lower bound for appeal updated_at."},"updated_at_to":{"type":"string","format":"date-time","description":"Upper bound for appeal updated_at."}},"description":"Appeal search and filter request parameters. Used for admin/member pagination, filter, and process analytics.","required":[]},"IPageICommunityPlatformAppeal.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformAppeal.ISummary"}}},"required":["pagination","data"],"description":"Paginated collection of appeal summaries. Contains the list of summary appeal objects and pagination details."},"ICommunityPlatformAppeal":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique UUID primary key for this appeal."},"member_id":{"type":"string","format":"uuid","description":"The member user who filed this appeal. Prisma: member_id."},"admin_action_id":{"type":"string","format":"uuid","description":"Admin action (moderation, suspension, etc.) being appealed. Prisma: admin_action_id."},"appeal_status":{"type":"string","description":"Status of the appeal (e.g. submitted, under_review, resolved, reversed, rejected)."},"decision_reason":{"oneOf":[{"type":"string","description":"Optional moderator/admin rationale for decision on this appeal."},{"type":"null","description":"Optional moderator/admin rationale for decision on this appeal."}],"description":"Optional moderator/admin rationale for decision on this appeal."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Admin who handled this appeal (nullable until processed)."},{"type":"null","format":"uuid","description":"Admin who handled this appeal (nullable until processed)."}],"description":"Admin who handled this appeal (nullable until processed)."},"created_at":{"type":"string","format":"date-time","description":"Timestamp the appeal was created."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp for latest update to this appeal."}},"required":["id","member_id","admin_action_id","appeal_status","created_at","updated_at"],"description":"Appeal entity for moderation/admin appeals workflow, tracing dispute lifecycle. Mirrors Prisma and business rules."},"ICommunityPlatformAppeal.ICreate":{"type":"object","properties":{"admin_action_id":{"type":"string","format":"uuid","description":"The administrative action id being appealed. Prisma: admin_action_id."},"appeal_status":{"type":"string","description":"Initial status for the appeal (typically 'submitted')."},"decision_reason":{"oneOf":[{"type":"string","description":"Explanatory text provided by appellant, if any."},{"type":"null","description":"Explanatory text provided by appellant, if any."}],"description":"Explanatory text provided by appellant, if any."}},"required":["admin_action_id","appeal_status"],"description":"Payload for creating a new member-filed moderation/admin appeal. Only required fields: admin_action_id, appeal_status."},"ICommunityPlatformAppeal.IUpdate":{"type":"object","properties":{"appeal_status":{"type":"string","description":"Updated status for the appeal (e.g. under_review, resolved, rejected, etc.)."},"decision_reason":{"oneOf":[{"type":"string","description":"Updated admin rationale for decision on this appeal."},{"type":"null","description":"Updated admin rationale for decision on this appeal."}],"description":"Updated admin rationale for decision on this appeal."},"admin_id":{"type":"string","format":"uuid","description":"The admin id handling/modifying this appeal (for transitions to reviewed, resolved, etc.)."}},"description":"Appeal update payload for changing status, rationale or assignment. Used by admins to resolve/process appeals.","required":[]},"ICommunityPlatformAppeal.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique UUID primary key for this appeal."},"member_id":{"type":"string","format":"uuid","description":"ID of the member who filed this appeal. Prisma: member_id."},"admin_action_id":{"type":"string","format":"uuid","description":"ID of the admin/moderation action the appeal references. Prisma: admin_action_id."},"appeal_status":{"type":"string","description":"Status of the appeal (e.g. submitted, under_review, resolved, reversed, rejected)."},"decision_reason":{"oneOf":[{"type":"string","description":"Admin or moderator decision notes for this appeal (could be null if unresolved)."},{"type":"null","description":"Admin or moderator decision notes for this appeal (could be null if unresolved)."}],"description":"Admin or moderator decision notes for this appeal (could be null if unresolved)."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Assigned admin handling the appeal (nullable if not assigned yet)."},{"type":"null","format":"uuid","description":"Assigned admin handling the appeal (nullable if not assigned yet)."}],"description":"Assigned admin handling the appeal (nullable if not assigned yet)."},"created_at":{"type":"string","format":"date-time","description":"Creation timestamp for this appeal record."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp for the latest status update."}},"required":["id","member_id","admin_action_id","appeal_status","created_at","updated_at"],"description":"Summary view of appeals for paginated responses. Mirrors full entity except may omit deeply nested or audit-only fields."},"ICommunityPlatformSearchQuery.IRequest":{"type":"object","properties":{"page":{"type":"integer","format":"uint32","description":"Page number for paginated search results.\n\nThis property determines the current page of the paginated search. Used for pagination navigation."},"limit":{"type":"integer","format":"uint32","description":"Maximum results per page for pagination.\n\nControls the number of items to return per page in the results.\n\nDefault: 100."},"query_text":{"oneOf":[{"type":"string","description":"Filter by full or partial search query text.\n\nReturns only search logs that match the specified query text (case-insensitive, trigram search for analytics/audit use).\n\nMay be used to filter logs by keyword presence."},{"type":"null","description":"Filter by full or partial search query text.\n\nReturns only search logs that match the specified query text (case-insensitive, trigram search for analytics/audit use).\n\nMay be used to filter logs by keyword presence."}],"description":"Filter by full or partial search query text.\n\nReturns only search logs that match the specified query text (case-insensitive, trigram search for analytics/audit use).\n\nMay be used to filter logs by keyword presence."},"search_type":{"oneOf":[{"type":"string","description":"Type of entity searched: 'post', 'community', or 'comment'.\n\nRestricts the search query log to the specified entity type. Enum constraint is enforced at application level."},{"type":"null","description":"Type of entity searched: 'post', 'community', or 'comment'.\n\nRestricts the search query log to the specified entity type. Enum constraint is enforced at application level."}],"description":"Type of entity searched: 'post', 'community', or 'comment'.\n\nRestricts the search query log to the specified entity type. Enum constraint is enforced at application level."},"member_id":{"oneOf":[{"type":"string","format":"uuid","description":"Filter by authenticated member (if present).\n\nOnly returns queries performed by the specified member."},{"type":"null","format":"uuid","description":"Filter by authenticated member (if present).\n\nOnly returns queries performed by the specified member."}],"description":"Filter by authenticated member (if present).\n\nOnly returns queries performed by the specified member."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Filter by admin user (if present).\n\nOnly returns queries performed by the specified admin."},{"type":"null","format":"uuid","description":"Filter by admin user (if present).\n\nOnly returns queries performed by the specified admin."}],"description":"Filter by admin user (if present).\n\nOnly returns queries performed by the specified admin."},"performed_at_start":{"oneOf":[{"type":"string","format":"date-time","description":"Return search queries performed after or at this timestamp (inclusive).\n\nSupports querying logs within a time range."},{"type":"null","format":"date-time","description":"Return search queries performed after or at this timestamp (inclusive).\n\nSupports querying logs within a time range."}],"description":"Return search queries performed after or at this timestamp (inclusive).\n\nSupports querying logs within a time range."},"performed_at_end":{"oneOf":[{"type":"string","format":"date-time","description":"Return search queries performed before or at this timestamp (inclusive).\n\nSupports querying logs within a time range."},{"type":"null","format":"date-time","description":"Return search queries performed before or at this timestamp (inclusive).\n\nSupports querying logs within a time range."}],"description":"Return search queries performed before or at this timestamp (inclusive).\n\nSupports querying logs within a time range."},"sort_by":{"oneOf":[{"type":"string","description":"Field to sort results by (e.g. 'performed_at', 'query_text').\n\nDefines the property used for sorting search log results in paginated queries."},{"type":"null","description":"Field to sort results by (e.g. 'performed_at', 'query_text').\n\nDefines the property used for sorting search log results in paginated queries."}],"description":"Field to sort results by (e.g. 'performed_at', 'query_text').\n\nDefines the property used for sorting search log results in paginated queries."},"sort_direction":{"oneOf":[{"const":"asc","description":"Sort order direction: 'asc' for ascending or 'desc' for descending.\n\nControls ascending or descending order of results by sort_by field."},{"const":"desc","description":"Sort order direction: 'asc' for ascending or 'desc' for descending.\n\nControls ascending or descending order of results by sort_by field."},{"type":"null","enum":["asc","desc"],"description":"Sort order direction: 'asc' for ascending or 'desc' for descending.\n\nControls ascending or descending order of results by sort_by field."}],"description":"Sort order direction: 'asc' for ascending or 'desc' for descending.\n\nControls ascending or descending order of results by sort_by field."},"context":{"oneOf":[{"type":"string","description":"Filter by search context/page (e.g. 'home', 'explore', 'sidebar').\n\nRestricts logs to searches performed from specific areas of the UI."},{"type":"null","description":"Filter by search context/page (e.g. 'home', 'explore', 'sidebar').\n\nRestricts logs to searches performed from specific areas of the UI."}],"description":"Filter by search context/page (e.g. 'home', 'explore', 'sidebar').\n\nRestricts logs to searches performed from specific areas of the UI."},"ip":{"oneOf":[{"type":"string","description":"Filter by IP or anonymized session token used at search time.\n\nEnables searches of logs for specific IP addresses or session tracking tokens."},{"type":"null","description":"Filter by IP or anonymized session token used at search time.\n\nEnables searches of logs for specific IP addresses or session tracking tokens."}],"description":"Filter by IP or anonymized session token used at search time.\n\nEnables searches of logs for specific IP addresses or session tracking tokens."}},"description":"Request schema for searching the community_platform_search_queries audit/event log table.\n\nAllows administrators or auditors to query paginated search logs using advanced filters and sorting. All parameters are optional and may be combined for complex admin use cases. Used in search analytics interfaces and compliance workflows.","required":[]},"IPageICommunityPlatformSearchQuery.ISummary":{"type":"object","properties":{"pagination":{"$ref":"#/components/schemas/IPage.IPagination"},"data":{"type":"array","items":{"$ref":"#/components/schemas/ICommunityPlatformSearchQuery.ISummary"}}},"required":["pagination","data"],"description":"Paginated collection of search query summary records.\n\nReturns multiple community platform search log summaries with pagination information."},"ICommunityPlatformSearchQuery.ISummary":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier (UUID) for search query log event.\n\nThis property serves as the primary key for the log record."},"member_id":{"oneOf":[{"type":"string","format":"uuid","description":"Member ID (if logged) who performed the search, or null if guest/admin.\n\nRecords which member (if any) issued this search."},{"type":"null","format":"uuid","description":"Member ID (if logged) who performed the search, or null if guest/admin.\n\nRecords which member (if any) issued this search."}],"description":"Member ID (if logged) who performed the search, or null if guest/admin.\n\nRecords which member (if any) issued this search."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Admin ID (if present) who performed the search, or null for member/guest searches.\n\nIdentifies admin search context where relevant."},{"type":"null","format":"uuid","description":"Admin ID (if present) who performed the search, or null for member/guest searches.\n\nIdentifies admin search context where relevant."}],"description":"Admin ID (if present) who performed the search, or null for member/guest searches.\n\nIdentifies admin search context where relevant."},"query_text":{"type":"string","description":"Raw user-entered search string, as performed.\n\nLogged for analytics/audit."},"search_type":{"type":"string","description":"Type of entity searched (e.g. 'post', 'community', 'comment').\n\nIndicates context of search event."},"performed_at":{"type":"string","format":"date-time","description":"Timestamp (UTC) when the search event occurred.\n\nThis is the canonical search event time."},"context":{"oneOf":[{"type":"string","description":"Origin context or UI page for search (e.g. 'home', 'sidebar', 'explore'), or null if unknown.\n\nUsed for analytics segmentation."},{"type":"null","description":"Origin context or UI page for search (e.g. 'home', 'sidebar', 'explore'), or null if unknown.\n\nUsed for analytics segmentation."}],"description":"Origin context or UI page for search (e.g. 'home', 'sidebar', 'explore'), or null if unknown.\n\nUsed for analytics segmentation."},"ip":{"oneOf":[{"type":"string","description":"Anonymized IP address or session token for the search event, if recorded.\n\nUsed for audit/compliance or abuse monitoring."},{"type":"null","description":"Anonymized IP address or session token for the search event, if recorded.\n\nUsed for audit/compliance or abuse monitoring."}],"description":"Anonymized IP address or session token for the search event, if recorded.\n\nUsed for audit/compliance or abuse monitoring."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when this log entry was created (UTC).\n\nMay be equal to performed_at for real-time logging systems."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of last update to this log entry (UTC).\n\nUsually equals created_at unless backfilled or amended."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Timestamp (UTC, nullable) when this log was soft-deleted (for compliance, retention policy, or GDPR). Null if still active.\n\nIndicates retention status for audit."},{"type":"null","format":"date-time","description":"Timestamp (UTC, nullable) when this log was soft-deleted (for compliance, retention policy, or GDPR). Null if still active.\n\nIndicates retention status for audit."}],"description":"Timestamp (UTC, nullable) when this log was soft-deleted (for compliance, retention policy, or GDPR). Null if still active.\n\nIndicates retention status for audit."}},"required":["id","query_text","search_type","performed_at","created_at","updated_at"],"description":"Summary of a single search query log record for the community platform.\n\nProvides essential metadata for analytics, audit, and compliance use cases. Includes member/admin actor, timestamps, and search context."},"ICommunityPlatformSearchQuery":{"type":"object","properties":{"id":{"type":"string","format":"uuid","description":"Unique identifier (UUID) for search query log event.\n\nThis property serves as the primary key for the log record."},"member_id":{"oneOf":[{"type":"string","format":"uuid","description":"Member ID (if logged) who performed the search, or null if guest/admin.\n\nRecords which member (if any) issued this search."},{"type":"null","format":"uuid","description":"Member ID (if logged) who performed the search, or null if guest/admin.\n\nRecords which member (if any) issued this search."}],"description":"Member ID (if logged) who performed the search, or null if guest/admin.\n\nRecords which member (if any) issued this search."},"admin_id":{"oneOf":[{"type":"string","format":"uuid","description":"Admin ID (if present) who performed the search, or null for member/guest searches.\n\nIdentifies admin search context where relevant."},{"type":"null","format":"uuid","description":"Admin ID (if present) who performed the search, or null for member/guest searches.\n\nIdentifies admin search context where relevant."}],"description":"Admin ID (if present) who performed the search, or null for member/guest searches.\n\nIdentifies admin search context where relevant."},"query_text":{"type":"string","description":"Raw user-entered search string, as performed.\n\nLogged for analytics/audit."},"search_type":{"type":"string","description":"Type of entity searched (e.g. 'post', 'community', 'comment').\n\nIndicates context of search event."},"performed_at":{"type":"string","format":"date-time","description":"Timestamp (UTC) when the search event occurred.\n\nThis is the canonical search event time."},"context":{"oneOf":[{"type":"string","description":"Origin context or UI page for search (e.g. 'home', 'sidebar', 'explore'), or null if unknown.\n\nUsed for analytics segmentation."},{"type":"null","description":"Origin context or UI page for search (e.g. 'home', 'sidebar', 'explore'), or null if unknown.\n\nUsed for analytics segmentation."}],"description":"Origin context or UI page for search (e.g. 'home', 'sidebar', 'explore'), or null if unknown.\n\nUsed for analytics segmentation."},"ip":{"oneOf":[{"type":"string","description":"Anonymized IP address or session token for the search event, if recorded.\n\nUsed for audit/compliance or abuse monitoring."},{"type":"null","description":"Anonymized IP address or session token for the search event, if recorded.\n\nUsed for audit/compliance or abuse monitoring."}],"description":"Anonymized IP address or session token for the search event, if recorded.\n\nUsed for audit/compliance or abuse monitoring."},"created_at":{"type":"string","format":"date-time","description":"Timestamp when this log entry was created (UTC).\n\nMay be equal to performed_at for real-time logging systems."},"updated_at":{"type":"string","format":"date-time","description":"Timestamp of last update to this log entry (UTC).\n\nUsually equals created_at unless backfilled or amended."},"deleted_at":{"oneOf":[{"type":"string","format":"date-time","description":"Timestamp (UTC, nullable) when this log was soft-deleted (for compliance, retention policy, or GDPR). Null if still active.\n\nIndicates retention status for audit."},{"type":"null","format":"date-time","description":"Timestamp (UTC, nullable) when this log was soft-deleted (for compliance, retention policy, or GDPR). Null if still active.\n\nIndicates retention status for audit."}],"description":"Timestamp (UTC, nullable) when this log was soft-deleted (for compliance, retention policy, or GDPR). Null if still active.\n\nIndicates retention status for audit."}},"required":["id","query_text","search_type","performed_at","created_at","updated_at"],"description":"Represents a single search query log event in the community platform.\n\nContains the full details of who performed the search, what was searched for, timestamps, and audit/logging information. Used for compliance, analytics, and security investigation workflows."}}}}